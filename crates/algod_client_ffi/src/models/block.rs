/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use crate::models;
use algod_client::models::Block as RustBlock;
use algokit_transact_ffi::SignedTransaction as AlgokitSignedTransaction;

use crate::models::BlockStateProofTracking;
use crate::models::SignedTxnInBlock;

/// Block contains the BlockHeader and the list of transactions (Payset).
#[derive(Clone, Debug, PartialEq, uniffi::Record)]
pub struct Block {
    /// [rnd] Round number.
    pub round: Option<u64>,
    /// [prev] Previous block hash.
    pub previous_block_hash: Option<Vec<u8>>,
    /// [prev512] Previous block hash using SHA-512.
    pub previous_block_hash_512: Option<Vec<u8>>,
    /// [seed] Sortition seed.
    pub seed: Option<Vec<u8>>,
    /// [txn] Root of transaction merkle tree using SHA512_256.
    pub transactions_root: Option<Vec<u8>>,
    /// [txn256] Root of transaction vector commitment using SHA256.
    pub transactions_root_sha256: Option<Vec<u8>>,
    /// [txn512] Root of transaction vector commitment using SHA512.
    pub transactions_root_sha512: Option<Vec<u8>>,
    /// [ts] Block timestamp in seconds since epoch.
    pub timestamp: Option<u64>,
    /// [gen] Genesis ID.
    pub genesis_id: Option<String>,
    /// [gh] Genesis hash.
    pub genesis_hash: Option<Vec<u8>>,
    /// [prp] Proposer address.
    pub proposer: Option<Vec<u8>>,
    /// [fc] Fees collected in this block.
    pub fees_collected: Option<u64>,
    /// [bi] Bonus incentive for block proposal.
    pub bonus: Option<u64>,
    /// [pp] Proposer payout.
    pub proposer_payout: Option<u64>,
    /// [fees] FeeSink address.
    pub fee_sink: Option<Vec<u8>>,
    /// [rwd] RewardsPool address.
    pub rewards_pool: Option<Vec<u8>>,
    /// [earn] Rewards level.
    pub rewards_level: Option<u64>,
    /// [rate] Rewards rate.
    pub rewards_rate: Option<u64>,
    /// [frac] Rewards residue.
    pub rewards_residue: Option<u64>,
    /// [rwcalr] Rewards recalculation round.
    pub rewards_recalculation_round: Option<u64>,
    /// [proto] Current consensus protocol.
    pub current_protocol: Option<String>,
    /// [nextproto] Next proposed protocol.
    pub next_protocol: Option<String>,
    /// [nextyes] Next protocol approvals.
    pub next_protocol_approvals: Option<u64>,
    /// [nextbefore] Next protocol vote deadline.
    pub next_protocol_vote_before: Option<u64>,
    /// [nextswitch] Next protocol switch round.
    pub next_protocol_switch_on: Option<u64>,
    /// [upgradeprop] Upgrade proposal.
    pub upgrade_propose: Option<String>,
    /// [upgradedelay] Upgrade delay in rounds.
    pub upgrade_delay: Option<u64>,
    /// [upgradeyes] Upgrade approval flag.
    pub upgrade_approve: Option<bool>,
    /// [tc] Transaction counter.
    pub txn_counter: Option<u64>,
    /// [spt] State proof tracking data keyed by state proof type.
    pub state_proof_tracking: Option<BlockStateProofTracking>,
    /// [partupdrmv] Expired participation accounts.
    pub expired_participation_accounts: Option<Vec<Vec<u8>>>,
    /// [partupdabs] Absent participation accounts.
    pub absent_participation_accounts: Option<Vec<Vec<u8>>>,
    /// [txns] Block transactions (Payset).
    pub transactions: Option<Vec<SignedTxnInBlock>>,
}

impl From<RustBlock> for Block {
    fn from(rust_struct: RustBlock) -> Self {
        Self {
            round: rust_struct.round,
            previous_block_hash: rust_struct.previous_block_hash,
            previous_block_hash_512: rust_struct.previous_block_hash_512,
            seed: rust_struct.seed,
            transactions_root: rust_struct.transactions_root,
            transactions_root_sha256: rust_struct.transactions_root_sha256,
            transactions_root_sha512: rust_struct.transactions_root_sha512,
            timestamp: rust_struct.timestamp,
            genesis_id: rust_struct.genesis_id,
            genesis_hash: rust_struct.genesis_hash,
            proposer: rust_struct.proposer,
            fees_collected: rust_struct.fees_collected,
            bonus: rust_struct.bonus,
            proposer_payout: rust_struct.proposer_payout,
            fee_sink: rust_struct.fee_sink,
            rewards_pool: rust_struct.rewards_pool,
            rewards_level: rust_struct.rewards_level,
            rewards_rate: rust_struct.rewards_rate,
            rewards_residue: rust_struct.rewards_residue,
            rewards_recalculation_round: rust_struct.rewards_recalculation_round,
            current_protocol: rust_struct.current_protocol,
            next_protocol: rust_struct.next_protocol,
            next_protocol_approvals: rust_struct.next_protocol_approvals,
            next_protocol_vote_before: rust_struct.next_protocol_vote_before,
            next_protocol_switch_on: rust_struct.next_protocol_switch_on,
            upgrade_propose: rust_struct.upgrade_propose,
            upgrade_delay: rust_struct.upgrade_delay,
            upgrade_approve: rust_struct.upgrade_approve,
            txn_counter: rust_struct.txn_counter,
            state_proof_tracking: rust_struct
                .state_proof_tracking
                .map(|v| v.into_iter().map(|(k, v)| (k, v.into())).collect()),
            expired_participation_accounts: rust_struct.expired_participation_accounts,
            absent_participation_accounts: rust_struct.absent_participation_accounts,
            transactions: rust_struct
                .transactions
                .map(|v| v.into_iter().map(|tx| tx.into()).collect()),
        }
    }
}

impl From<Block> for RustBlock {
    fn from(ffi_struct: Block) -> Self {
        Self {
            round: ffi_struct.round,
            previous_block_hash: ffi_struct.previous_block_hash,
            previous_block_hash_512: ffi_struct.previous_block_hash_512,
            seed: ffi_struct.seed,
            transactions_root: ffi_struct.transactions_root,
            transactions_root_sha256: ffi_struct.transactions_root_sha256,
            transactions_root_sha512: ffi_struct.transactions_root_sha512,
            timestamp: ffi_struct.timestamp,
            genesis_id: ffi_struct.genesis_id,
            genesis_hash: ffi_struct.genesis_hash,
            proposer: ffi_struct.proposer,
            fees_collected: ffi_struct.fees_collected,
            bonus: ffi_struct.bonus,
            proposer_payout: ffi_struct.proposer_payout,
            fee_sink: ffi_struct.fee_sink,
            rewards_pool: ffi_struct.rewards_pool,
            rewards_level: ffi_struct.rewards_level,
            rewards_rate: ffi_struct.rewards_rate,
            rewards_residue: ffi_struct.rewards_residue,
            rewards_recalculation_round: ffi_struct.rewards_recalculation_round,
            current_protocol: ffi_struct.current_protocol,
            next_protocol: ffi_struct.next_protocol,
            next_protocol_approvals: ffi_struct.next_protocol_approvals,
            next_protocol_vote_before: ffi_struct.next_protocol_vote_before,
            next_protocol_switch_on: ffi_struct.next_protocol_switch_on,
            upgrade_propose: ffi_struct.upgrade_propose,
            upgrade_delay: ffi_struct.upgrade_delay,
            upgrade_approve: ffi_struct.upgrade_approve,
            txn_counter: ffi_struct.txn_counter,
            state_proof_tracking: ffi_struct
                .state_proof_tracking
                .map(|v| v.into_iter().map(|(k, v)| (k, v.into())).collect()),
            expired_participation_accounts: ffi_struct.expired_participation_accounts,
            absent_participation_accounts: ffi_struct.absent_participation_accounts,
            transactions: ffi_struct
                .transactions
                .map(|v| v.into_iter().map(|tx| tx.into()).collect()),
        }
    }
}
