#![allow(clippy::let_and_return)]

/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use super::Error;
use super::parameter_enums::*;
use crate::models::{
    AbortCatchup, Account, AccountApplicationInformation, AccountAssetInformation,
    AccountAssetsInformation, AddParticipationKey, Application, Asset, Box, DebugSettingsProf,
    DryrunRequest, ErrorResponse, Genesis, GetApplicationBoxes, GetBlock, GetBlockHash,
    GetBlockLogs, GetBlockTimeStampOffset, GetBlockTxids, GetPendingTransactions,
    GetPendingTransactionsByAddress, GetStatus, GetSupply, GetSyncRound,
    GetTransactionGroupLedgerStateDeltasForRound, LedgerStateDelta, LightBlockHeaderProof,
    ParticipationKey, PendingTransactionResponse, RawTransaction, SimulateRequest,
    SimulateTransaction, StartCatchup, StateProof, TealCompile, TealDisassemble, TealDryrun,
    TransactionParams, TransactionProof, UnknownJsonValue, Version, WaitForBlock,
};
use algod_client::AlgodClient as RustAlgodClient;
use algokit_http_client::{DefaultHttpClient, HttpClient};
use std::sync::Arc;

/// The main Algod API client.
///
/// This client provides convenient access to all Algod API endpoints.
/// It wraps the lower-level endpoint functions with a more ergonomic interface.
/// All methods return a unified `Error` type that can represent any endpoint error.
#[derive(Clone, uniffi::Object)]
pub struct AlgodClient {
    inner_algod_client: Arc<RustAlgodClient>,
}

#[uniffi::export]
impl AlgodClient {
    /// Create a new AlgodClient with a custom http client.
    #[uniffi::constructor]
    pub fn new(http_client: Arc<dyn HttpClient>) -> Self {
        let inner_algod_client = Arc::new(RustAlgodClient::new(http_client.clone()));
        Self { inner_algod_client }
    }

    /// Returns OK if healthy.
    pub async fn health_check(&self) -> Result<(), Error> {
        self.inner_algod_client
            .health_check()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Returns OK if healthy and fully caught up.
    pub async fn get_ready(&self) -> Result<(), Error> {
        self.inner_algod_client
            .get_ready()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Return metrics about algod functioning.
    pub async fn metrics(&self) -> Result<(), Error> {
        self.inner_algod_client
            .metrics()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Gets the genesis information.
    pub async fn get_genesis(&self) -> Result<Genesis, Error> {
        self.inner_algod_client
            .get_genesis()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Gets the current swagger spec.
    pub async fn swagger_json(&self) -> Result<String, Error> {
        self.inner_algod_client
            .swagger_json()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Retrieves the supported API versions, binary build versions, and genesis information.
    pub async fn get_version(&self) -> Result<Version, Error> {
        self.inner_algod_client
            .get_version()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Retrieves the current settings for blocking and mutex profiles
    pub async fn get_debug_settings_prof(&self) -> Result<DebugSettingsProf, Error> {
        self.inner_algod_client
            .get_debug_settings_prof()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Enables blocking and mutex profiles, and returns the old settings
    pub async fn put_debug_settings_prof(&self) -> Result<DebugSettingsProf, Error> {
        self.inner_algod_client
            .put_debug_settings_prof()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Gets the merged config file.
    pub async fn get_config(&self) -> Result<String, Error> {
        self.inner_algod_client
            .get_config()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get account information.
    pub async fn account_information(
        &self,
        address: &str,
        exclude: Option<Exclude>,
        format: Option<Format>,
    ) -> Result<Account, Error> {
        self.inner_algod_client
            .account_information(
                address.into(),
                exclude.map(|v| v.into()),
                format.map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get account information about a given asset.
    pub async fn account_asset_information(
        &self,
        address: &str,
        asset_id: u64,
        format: Option<Format>,
    ) -> Result<AccountAssetInformation, Error> {
        self.inner_algod_client
            .account_asset_information(address.into(), asset_id.into(), format.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a list of assets held by an account, inclusive of asset params.
    pub async fn account_assets_information(
        &self,
        address: &str,
        limit: Option<u64>,
        next: Option<String>,
    ) -> Result<AccountAssetsInformation, Error> {
        self.inner_algod_client
            .account_assets_information(
                address.into(),
                limit.map(|v| v.into()),
                next.as_deref().map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get account information about a given app.
    pub async fn account_application_information(
        &self,
        address: &str,
        application_id: u64,
        format: Option<Format>,
    ) -> Result<AccountApplicationInformation, Error> {
        self.inner_algod_client
            .account_application_information(
                address.into(),
                application_id.into(),
                format.map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a list of unconfirmed transactions currently in the transaction pool by address.
    pub async fn get_pending_transactions_by_address(
        &self,
        address: &str,
        max: Option<u64>,
        format: Option<Format>,
    ) -> Result<GetPendingTransactionsByAddress, Error> {
        self.inner_algod_client
            .get_pending_transactions_by_address(
                address.into(),
                max.map(|v| v.into()),
                format.map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get the block for the given round.
    pub async fn get_block(
        &self,
        round: u64,
        header_only: Option<bool>,
        format: Option<Format>,
    ) -> Result<GetBlock, Error> {
        self.inner_algod_client
            .get_block(
                round.into(),
                header_only.map(|v| v.into()),
                format.map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get the top level transaction IDs for the block on the given round.
    pub async fn get_block_txids(&self, round: u64) -> Result<GetBlockTxids, Error> {
        self.inner_algod_client
            .get_block_txids(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get the block hash for the block on the given round.
    pub async fn get_block_hash(&self, round: u64) -> Result<GetBlockHash, Error> {
        self.inner_algod_client
            .get_block_hash(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a proof for a transaction in a block.
    pub async fn get_transaction_proof(
        &self,
        round: u64,
        txid: &str,
        hashtype: Option<Hashtype>,
        format: Option<Format>,
    ) -> Result<TransactionProof, Error> {
        self.inner_algod_client
            .get_transaction_proof(
                round.into(),
                txid.into(),
                hashtype.map(|v| v.into()),
                format.map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get all of the logs from outer and inner app calls in the given round
    pub async fn get_block_logs(&self, round: u64) -> Result<GetBlockLogs, Error> {
        self.inner_algod_client
            .get_block_logs(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get the current supply reported by the ledger.
    pub async fn get_supply(&self) -> Result<GetSupply, Error> {
        self.inner_algod_client
            .get_supply()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Return a list of participation keys
    pub async fn get_participation_keys(&self) -> Result<Vec<ParticipationKey>, Error> {
        self.inner_algod_client
            .get_participation_keys()
            .await
            .map(|v| v.into_iter().map(|item| item.into()).collect())
            .map_err(|e| e.into())
    }

    /// Add a participation key to the node
    pub async fn add_participation_key(
        &self,
        request: Vec<u8>,
    ) -> Result<AddParticipationKey, Error> {
        self.inner_algod_client
            .add_participation_key(request.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Generate and install participation keys to the node.
    pub async fn generate_participation_keys(
        &self,
        address: &str,
        dilution: Option<u64>,
        first: u64,
        last: u64,
    ) -> Result<String, Error> {
        self.inner_algod_client
            .generate_participation_keys(
                address.into(),
                dilution.map(|v| v.into()),
                first.into(),
                last.into(),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get participation key info given a participation ID
    pub async fn get_participation_key_by_id(
        &self,
        participation_id: &str,
    ) -> Result<ParticipationKey, Error> {
        self.inner_algod_client
            .get_participation_key_by_id(participation_id.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Append state proof keys to a participation key
    pub async fn append_keys(
        &self,
        request: Vec<u8>,
        participation_id: &str,
    ) -> Result<ParticipationKey, Error> {
        self.inner_algod_client
            .append_keys(request.into(), participation_id.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Delete a given participation key by ID
    pub async fn delete_participation_key_by_id(
        &self,
        participation_id: &str,
    ) -> Result<(), Error> {
        self.inner_algod_client
            .delete_participation_key_by_id(participation_id.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
    pub async fn shutdown_node(&self, timeout: Option<u64>) -> Result<UnknownJsonValue, Error> {
        self.inner_algod_client
            .shutdown_node(timeout.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Gets the current node status.
    pub async fn get_status(&self) -> Result<GetStatus, Error> {
        self.inner_algod_client
            .get_status()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Gets the node status after waiting for a round after the given round.
    pub async fn wait_for_block(&self, round: u64) -> Result<WaitForBlock, Error> {
        self.inner_algod_client
            .wait_for_block(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Broadcasts a raw transaction or transaction group to the network.
    pub async fn raw_transaction(&self, request: Vec<u8>) -> Result<RawTransaction, Error> {
        self.inner_algod_client
            .raw_transaction(request.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
    pub async fn raw_transaction_async(&self, request: Vec<u8>) -> Result<(), Error> {
        self.inner_algod_client
            .raw_transaction_async(request.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
    pub async fn simulate_transaction(
        &self,
        request: SimulateRequest,
        format: Option<Format>,
    ) -> Result<SimulateTransaction, Error> {
        self.inner_algod_client
            .simulate_transaction(request.into(), format.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get parameters for constructing a new transaction
    pub async fn transaction_params(&self) -> Result<TransactionParams, Error> {
        self.inner_algod_client
            .transaction_params()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a list of unconfirmed transactions currently in the transaction pool.
    pub async fn get_pending_transactions(
        &self,
        max: Option<u64>,
        format: Option<Format>,
    ) -> Result<GetPendingTransactions, Error> {
        self.inner_algod_client
            .get_pending_transactions(max.map(|v| v.into()), format.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a specific pending transaction.
    pub async fn pending_transaction_information(
        &self,
        txid: &str,
        format: Option<Format>,
    ) -> Result<PendingTransactionResponse, Error> {
        self.inner_algod_client
            .pending_transaction_information(txid.into(), format.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a LedgerStateDelta object for a given round
    pub async fn get_ledger_state_delta(
        &self,
        round: u64,
        format: Option<Format>,
    ) -> Result<LedgerStateDelta, Error> {
        self.inner_algod_client
            .get_ledger_state_delta(round.into(), format.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get LedgerStateDelta objects for all transaction groups in a given round
    pub async fn get_transaction_group_ledger_state_deltas_for_round(
        &self,
        round: u64,
        format: Option<Format>,
    ) -> Result<GetTransactionGroupLedgerStateDeltasForRound, Error> {
        self.inner_algod_client
            .get_transaction_group_ledger_state_deltas_for_round(
                round.into(),
                format.map(|v| v.into()),
            )
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a LedgerStateDelta object for a given transaction group
    pub async fn get_ledger_state_delta_for_transaction_group(
        &self,
        id: &str,
        format: Option<Format>,
    ) -> Result<LedgerStateDelta, Error> {
        self.inner_algod_client
            .get_ledger_state_delta_for_transaction_group(id.into(), format.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get a state proof that covers a given round
    pub async fn get_state_proof(&self, round: u64) -> Result<StateProof, Error> {
        self.inner_algod_client
            .get_state_proof(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Gets a proof for a given light block header inside a state proof commitment
    pub async fn get_light_block_header_proof(
        &self,
        round: u64,
    ) -> Result<LightBlockHeaderProof, Error> {
        self.inner_algod_client
            .get_light_block_header_proof(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get application information.
    pub async fn get_application_by_id(&self, application_id: u64) -> Result<Application, Error> {
        self.inner_algod_client
            .get_application_by_id(application_id.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get all box names for a given application.
    pub async fn get_application_boxes(
        &self,
        application_id: u64,
        max: Option<u64>,
    ) -> Result<GetApplicationBoxes, Error> {
        self.inner_algod_client
            .get_application_boxes(application_id.into(), max.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get box information for a given application.
    pub async fn get_application_box_by_name(
        &self,
        application_id: u64,
        name: &str,
    ) -> Result<crate::models::Box, Error> {
        self.inner_algod_client
            .get_application_box_by_name(application_id.into(), name.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Get asset information.
    pub async fn get_asset_by_id(&self, asset_id: u64) -> Result<Asset, Error> {
        self.inner_algod_client
            .get_asset_by_id(asset_id.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Returns the minimum sync round the ledger is keeping in cache.
    pub async fn get_sync_round(&self) -> Result<GetSyncRound, Error> {
        self.inner_algod_client
            .get_sync_round()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Removes minimum sync round restriction from the ledger.
    pub async fn unset_sync_round(&self) -> Result<(), Error> {
        self.inner_algod_client
            .unset_sync_round()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Given a round, tells the ledger to keep that round in its cache.
    pub async fn set_sync_round(&self, round: u64) -> Result<(), Error> {
        self.inner_algod_client
            .set_sync_round(round.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Compile TEAL source code to binary, produce its hash
    pub async fn teal_compile(
        &self,
        request: Vec<u8>,
        sourcemap: Option<bool>,
    ) -> Result<TealCompile, Error> {
        self.inner_algod_client
            .teal_compile(request.into(), sourcemap.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Disassemble program bytes into the TEAL source code.
    pub async fn teal_disassemble(&self, request: String) -> Result<TealDisassemble, Error> {
        self.inner_algod_client
            .teal_disassemble(request.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Starts a catchpoint catchup.
    pub async fn start_catchup(
        &self,
        catchpoint: &str,
        min: Option<u64>,
    ) -> Result<StartCatchup, Error> {
        self.inner_algod_client
            .start_catchup(catchpoint.into(), min.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Aborts a catchpoint catchup.
    pub async fn abort_catchup(&self, catchpoint: &str) -> Result<AbortCatchup, Error> {
        self.inner_algod_client
            .abort_catchup(catchpoint.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Provide debugging information for a transaction (or group).
    pub async fn teal_dryrun(&self, request: Option<DryrunRequest>) -> Result<TealDryrun, Error> {
        self.inner_algod_client
            .teal_dryrun(request.map(|v| v.into()))
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Returns OK if experimental API is enabled.
    pub async fn experimental_check(&self) -> Result<(), Error> {
        self.inner_algod_client
            .experimental_check()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
    pub async fn get_block_time_stamp_offset(&self) -> Result<GetBlockTimeStampOffset, Error> {
        self.inner_algod_client
            .get_block_time_stamp_offset()
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }

    /// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
    pub async fn set_block_time_stamp_offset(&self, offset: u64) -> Result<(), Error> {
        self.inner_algod_client
            .set_block_time_stamp_offset(offset.into())
            .await
            .map(|v| v.into())
            .map_err(|e| e.into())
    }
}
