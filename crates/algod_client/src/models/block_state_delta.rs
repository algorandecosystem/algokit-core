/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use crate::models::BlockEvalDelta;
use serde::de::{MapAccess, Visitor};
use serde::ser::SerializeMap;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::collections::HashMap;
use std::fmt;
use std::ops::{Deref, DerefMut};

/// BlockStateDelta is a map keyed by state key to BlockEvalDelta.
/// Keys are raw bytes that may come as msgpack strings (which can contain non-UTF8 data).
#[derive(Clone, Default, Debug, PartialEq)]
#[cfg_attr(feature = "ffi_uniffi", derive(uniffi::Record))]
pub struct BlockStateDelta {
    pub entries: HashMap<Vec<u8>, BlockEvalDelta>,
}

impl Deref for BlockStateDelta {
    type Target = HashMap<Vec<u8>, BlockEvalDelta>;

    fn deref(&self) -> &Self::Target {
        &self.entries
    }
}

impl DerefMut for BlockStateDelta {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.entries
    }
}

struct BlockStateDeltaVisitor;

impl<'de> Visitor<'de> for BlockStateDeltaVisitor {
    type Value = BlockStateDelta;

    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        formatter.write_str("a map with string or binary keys")
    }

    fn visit_map<M>(self, mut access: M) -> Result<Self::Value, M::Error>
    where
        M: MapAccess<'de>,
    {
        let mut entries = HashMap::with_capacity(access.size_hint().unwrap_or(0));

        // Use rmpv::Value for keys to handle both string and binary
        while let Some((key, value)) = access.next_entry::<rmpv::Value, BlockEvalDelta>()? {
            let key_bytes = match key {
                rmpv::Value::String(s) => s.into_bytes(),
                rmpv::Value::Binary(b) => b,
                _ => {
                    return Err(serde::de::Error::custom(
                        "expected string or binary key in BlockStateDelta",
                    ))
                }
            };
            entries.insert(key_bytes, value);
        }

        Ok(BlockStateDelta { entries })
    }
}

impl<'de> Deserialize<'de> for BlockStateDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_map(BlockStateDeltaVisitor)
    }
}

impl Serialize for BlockStateDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut map = serializer.serialize_map(Some(self.entries.len()))?;
        for (k, v) in &self.entries {
            // Serialize keys as bytes
            map.serialize_entry(&serde_bytes::Bytes::new(k), v)?;
        }
        map.end()
    }
}
