/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use crate::models;
#[cfg(not(feature = "ffi_uniffi"))]
use algokit_transact::SignedTransaction as AlgokitSignedTransaction;
use serde::{Deserialize, Serialize};
use serde_with::{Bytes, serde_as};

#[cfg(feature = "ffi_uniffi")]
use algokit_transact_ffi::SignedTransaction as AlgokitSignedTransaction;

use algokit_transact::AlgorandMsgpack;

use crate::models::SignedTxnInBlock;

/// Block contains the BlockHeader and the list of transactions (Payset).
#[serde_as]
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
#[cfg_attr(feature = "ffi_uniffi", derive(uniffi::Record))]
pub struct Block {
    /// [rnd] Round number.
    #[serde(rename = "rnd", skip_serializing_if = "Option::is_none")]
    pub round: Option<u64>,
    /// [prev] Previous block hash.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "prev", skip_serializing_if = "Option::is_none")]
    pub previous_block_hash: Option<Vec<u8>>,
    /// [prev512] Previous block hash using SHA-512.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "prev512", skip_serializing_if = "Option::is_none")]
    pub previous_block_hash_512: Option<Vec<u8>>,
    /// [seed] Sortition seed.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "seed", skip_serializing_if = "Option::is_none")]
    pub seed: Option<Vec<u8>>,
    /// [txn] Root of transaction merkle tree using SHA512_256.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "txn", skip_serializing_if = "Option::is_none")]
    pub transactions_root: Option<Vec<u8>>,
    /// [txn256] Root of transaction vector commitment using SHA256.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "txn256", skip_serializing_if = "Option::is_none")]
    pub transactions_root_sha256: Option<Vec<u8>>,
    /// [txn512] Root of transaction vector commitment using SHA512.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "txn512", skip_serializing_if = "Option::is_none")]
    pub transactions_root_sha512: Option<Vec<u8>>,
    /// [ts] Block timestamp in seconds since epoch.
    #[serde(rename = "ts", skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<u64>,
    /// [gen] Genesis ID.
    #[serde(rename = "gen", skip_serializing_if = "Option::is_none")]
    pub genesis_id: Option<String>,
    /// [gh] Genesis hash.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "gh", skip_serializing_if = "Option::is_none")]
    pub genesis_hash: Option<Vec<u8>>,
    /// [prp] Proposer address.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "prp", skip_serializing_if = "Option::is_none")]
    pub proposer: Option<Vec<u8>>,
    /// [fc] Fees collected in this block.
    #[serde(rename = "fc", skip_serializing_if = "Option::is_none")]
    pub fees_collected: Option<u64>,
    /// [bi] Bonus incentive for block proposal.
    #[serde(rename = "bi", skip_serializing_if = "Option::is_none")]
    pub bonus: Option<u64>,
    /// [pp] Proposer payout.
    #[serde(rename = "pp", skip_serializing_if = "Option::is_none")]
    pub proposer_payout: Option<u64>,
    /// [fees] FeeSink address.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "fees", skip_serializing_if = "Option::is_none")]
    pub fee_sink: Option<Vec<u8>>,
    /// [rwd] RewardsPool address.
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "rwd", skip_serializing_if = "Option::is_none")]
    pub rewards_pool: Option<Vec<u8>>,
    /// [earn] Rewards level.
    #[serde(rename = "earn", skip_serializing_if = "Option::is_none")]
    pub rewards_level: Option<u64>,
    /// [rate] Rewards rate.
    #[serde(rename = "rate", skip_serializing_if = "Option::is_none")]
    pub rewards_rate: Option<u64>,
    /// [frac] Rewards residue.
    #[serde(rename = "frac", skip_serializing_if = "Option::is_none")]
    pub rewards_residue: Option<u64>,
    /// [rwcalr] Rewards recalculation round.
    #[serde(rename = "rwcalr", skip_serializing_if = "Option::is_none")]
    pub rewards_recalculation_round: Option<u64>,
    /// [proto] Current consensus protocol.
    #[serde(rename = "proto", skip_serializing_if = "Option::is_none")]
    pub current_protocol: Option<String>,
    /// [nextproto] Next proposed protocol.
    #[serde(rename = "nextproto", skip_serializing_if = "Option::is_none")]
    pub next_protocol: Option<String>,
    /// [nextyes] Next protocol approvals.
    #[serde(rename = "nextyes", skip_serializing_if = "Option::is_none")]
    pub next_protocol_approvals: Option<u64>,
    /// [nextbefore] Next protocol vote deadline.
    #[serde(rename = "nextbefore", skip_serializing_if = "Option::is_none")]
    pub next_protocol_vote_before: Option<u64>,
    /// [nextswitch] Next protocol switch round.
    #[serde(rename = "nextswitch", skip_serializing_if = "Option::is_none")]
    pub next_protocol_switch_on: Option<u64>,
    /// [upgradeprop] Upgrade proposal.
    #[serde(rename = "upgradeprop", skip_serializing_if = "Option::is_none")]
    pub upgrade_propose: Option<String>,
    /// [upgradedelay] Upgrade delay in rounds.
    #[serde(rename = "upgradedelay", skip_serializing_if = "Option::is_none")]
    pub upgrade_delay: Option<u64>,
    /// [upgradeyes] Upgrade approval flag.
    #[serde(rename = "upgradeyes", skip_serializing_if = "Option::is_none")]
    pub upgrade_approve: Option<bool>,
    /// [tc] Transaction counter.
    #[serde(rename = "tc", skip_serializing_if = "Option::is_none")]
    pub txn_counter: Option<u64>,
    /// [spt] State proof tracking data. Map with integer keys in msgpack.
    #[serde(
        with = "crate::msgpack_value_bytes",
        default,
        rename = "spt",
        skip_serializing_if = "Option::is_none"
    )]
    pub state_proof_tracking: Option<Vec<u8>>,
    /// [partupdrmv] Expired participation accounts.
    #[serde_as(as = "Option<Vec<Bytes>>")]
    #[serde(rename = "partupdrmv", skip_serializing_if = "Option::is_none")]
    pub expired_participation_accounts: Option<Vec<Vec<u8>>>,
    /// [partupdabs] Absent participation accounts.
    #[serde_as(as = "Option<Vec<Bytes>>")]
    #[serde(rename = "partupdabs", skip_serializing_if = "Option::is_none")]
    pub absent_participation_accounts: Option<Vec<Vec<u8>>>,
    /// [txns] Block transactions (Payset).
    #[serde(rename = "txns", skip_serializing_if = "Option::is_none")]
    pub transactions: Option<Vec<SignedTxnInBlock>>,
}

impl AlgorandMsgpack for Block {
    const PREFIX: &'static [u8] = b""; // Adjust prefix as needed for your specific type
}

impl Block {
    /// Default constructor for Block
    pub fn new() -> Block {
        Block::default()
    }

    /// Encode this struct to msgpack bytes using AlgorandMsgpack trait
    pub fn to_msgpack(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        Ok(self.encode()?)
    }

    /// Decode msgpack bytes to this struct using AlgorandMsgpack trait
    pub fn from_msgpack(bytes: &[u8]) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self::decode(bytes)?)
    }
}
