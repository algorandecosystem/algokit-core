/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
use algokit_transact::AlgorandMsgpack;

// Import all custom types used by this endpoint
use crate::models::{
    ErrorResponse,
};

// Import request body type if needed

/// struct for typed errors of method [`raw_transaction_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RawTransactionAsyncError {
    Status400(ErrorResponse),
    Status401(ErrorResponse),
    Status404(),
    Status500(ErrorResponse),
    Status503(ErrorResponse),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
pub async fn raw_transaction_async(
    configuration: &configuration::Configuration,
request: Vec<u8>,

) -> Result<(), Error<RawTransactionAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/v2/transactions/async", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);



    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    // Determine content type: use msgpack by default if supported, unless format explicitly requests JSON
    let use_msgpack = true;

    if use_msgpack {
        // For binary data, use directly - detect if it's a binary endpoint or msgpack endpoint
        req_builder = req_builder
            .header("Content-Type", "application/x-binary")
            .body(p_request);
    } else {
        // Use JSON
        req_builder = req_builder.json(&p_request);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RawTransactionAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}