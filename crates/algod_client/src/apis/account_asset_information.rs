/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
use algokit_transact::AlgorandMsgpack;

// Import all custom types used by this endpoint
use crate::models::{
    AccountAssetInformation200Response,
    ErrorResponse,
};

// Import request body type if needed

/// struct for typed errors of method [`account_asset_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAssetInformationError {
    Status400(ErrorResponse),
    Status401(ErrorResponse),
    Status500(ErrorResponse),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Given a specific account public key and asset ID, this call returns the account's asset holding and asset parameters (if either exist). Asset parameters will only be returned if the provided address is the asset's creator.
pub async fn account_asset_information(
    configuration: &configuration::Configuration,
format: Option<&str>,
address: &str,
asset_id: i32,

) -> Result<AccountAssetInformation200Response, Error<AccountAssetInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;
    let p_address = address;
    let p_asset_id = asset_id;

    let uri_str = format!("{}/v2/accounts/{address}/assets/{asset_id}", configuration.base_path, address=crate::apis::urlencode(p_address), asset_id=p_asset_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };


    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::MsgPack => {
                let content = resp.bytes().await?;
                AccountAssetInformation200Response::decode(&content)
                    .map_err(|e| Error::from(serde_json::Error::custom(format!("Failed to decode msgpack response: {}", e))))
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AccountAssetInformation200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AccountAssetInformation200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountAssetInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}