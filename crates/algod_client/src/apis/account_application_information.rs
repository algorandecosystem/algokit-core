/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use algokit_transact::AlgorandMsgpack;
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

// Import all custom types used by this endpoint
use crate::models::{AccountApplicationInformation200Response, ErrorResponse};

// Import request body type if needed

/// struct for typed errors of method [`account_application_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountApplicationInformationError {
    Status400(ErrorResponse),
    Status401(ErrorResponse),
    Status500(ErrorResponse),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// Given a specific account public key and application ID, this call returns the account's application local state and global state (AppLocalState and AppParams, if either exists). Global state will only be returned if the provided address is the application's creator.
pub async fn account_application_information(
    configuration: &configuration::Configuration,
    format: Option<&str>,
    address: &str,
    application_id: i32,
) -> Result<AccountApplicationInformation200Response, Error<AccountApplicationInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;
    let p_address = address;
    let p_application_id = application_id;

    let uri_str = format!(
        "{}/v2/accounts/{address}/applications/{application_id}",
        configuration.base_path,
        address = crate::apis::urlencode(p_address),
        application_id = p_application_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::MsgPack => {
                let content = resp.bytes().await?;
                AccountApplicationInformation200Response::decode(&content)
                    .map_err(|e| Error::from(serde_json::Error::custom(format!("Failed to decode msgpack response: {}", e))))
            },
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AccountApplicationInformation200Response`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AccountApplicationInformation200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountApplicationInformationError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
