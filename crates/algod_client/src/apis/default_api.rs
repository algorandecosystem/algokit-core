/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

// Import all response types
use crate::models::{
    AbortCatchup200Response,
    AccountApplicationInformation200Response,
    AccountAssetInformation200Response,
    AccountAssetsInformation200Response,
    AddParticipationKey200Response,
    GetApplicationBoxes200Response,
    GetBlock200Response,
    GetBlockHash200Response,
    GetBlockLogs200Response,
    GetBlockTimeStampOffset200Response,
    GetBlockTxids200Response,
    GetPendingTransactions200Response,
    GetPendingTransactionsByAddress200Response,
    GetStatus200Response,
    GetSupply200Response,
    GetSyncRound200Response,
    GetTransactionGroupLedgerStateDeltasForRound200Response,
    GetTransactionProof200Response,
    RawTransaction200Response,
    SimulateTransaction200Response,
    StartCatchup200Response,
    StartCatchup201Response,
    TealCompile200Response,
    TealDisassemble200Response,
    TealDryrun200Response,
    TransactionParams200Response,
    WaitForBlock200Response,
};

/// struct for typed errors of method [`health_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthCheckError {
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ready`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetReadyError {
    Status500(),
    Status503(),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetricsError {
    Status404(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_genesis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGenesisError {
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`swagger_j_s_o_n`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SwaggerJsonError {
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVersionError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_debug_settings_prof`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDebugSettingsProfError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_debug_settings_prof`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutDebugSettingsProfError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConfigError {
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountInformationError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_asset_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAssetInformationError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_assets_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountAssetsInformationError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`account_application_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountApplicationInformationError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pending_transactions_by_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPendingTransactionsByAddressError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_block_txids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockTxidsError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_block_hash`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockHashError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_proof`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionProofError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_block_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockLogsError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_supply`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSupplyError {
    Status401(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_participation_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetParticipationKeysError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_participation_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddParticipationKeyError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_participation_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateParticipationKeysError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_participation_key_by_i_d`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetParticipationKeyByIdError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`append_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppendKeysError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_participation_key_by_i_d`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteParticipationKeyByIdError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`shutdown_node`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ShutdownNodeError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStatusError {
    Status401(serde_json::Value),
    Status500(String),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wait_for_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WaitForBlockError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`raw_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RawTransactionError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`raw_transaction_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RawTransactionAsyncError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`simulate_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimulateTransactionError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transaction_params`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionParamsError {
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pending_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPendingTransactionsError {
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pending_transaction_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PendingTransactionInformationError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ledger_state_delta`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLedgerStateDeltaError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status408(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_transaction_group_ledger_state_deltas_for_round`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTransactionGroupLedgerStateDeltasForRoundError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status408(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ledger_state_delta_for_transaction_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLedgerStateDeltaForTransactionGroupError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status408(serde_json::Value),
    Status500(serde_json::Value),
    Status501(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_state_proof`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStateProofError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status408(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_light_block_header_proof`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLightBlockHeaderProofError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status408(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_by_i_d`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationByIdError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationBoxesError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_box_by_name`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationBoxByNameError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_asset_by_i_d`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssetByIdError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sync_round`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSyncRoundError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unset_sync_round`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnsetSyncRoundError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_sync_round`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetSyncRoundError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Status503(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`teal_compile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TealCompileError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`teal_disassemble`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TealDisassembleError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_catchup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartCatchupError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status408(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`abort_catchup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbortCatchupError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`teal_dryrun`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TealDryrunError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`experimental_check`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExperimentalCheckError {
    Status404(),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_block_time_stamp_offset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlockTimeStampOffsetError {
    Status400(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_block_time_stamp_offset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetBlockTimeStampOffsetError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status500(serde_json::Value),
    Statusdefault(),
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}


/// Returns OK if healthy.
pub async fn health_check(
    configuration: &configuration::Configuration,
) -> Result<(), Error<HealthCheckError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/health", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<HealthCheckError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns OK if healthy and fully caught up.
pub async fn get_ready(
    configuration: &configuration::Configuration,
) -> Result<(), Error<GetReadyError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/ready", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetReadyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return metrics about algod functioning.
pub async fn metrics(
    configuration: &configuration::Configuration,
) -> Result<(), Error<MetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/metrics", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the entire genesis file in json.
pub async fn get_genesis(
    configuration: &configuration::Configuration,
) -> Result<serde_json::Value, Error<GetGenesisError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/genesis", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGenesisError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the entire swagger spec in json.
pub async fn swagger_j_s_o_n(
    configuration: &configuration::Configuration,
) -> Result<String, Error<SwaggerJsonError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/swagger.json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SwaggerJsonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the supported API versions, binary build versions, and genesis information.
pub async fn get_version(
    configuration: &configuration::Configuration,
) -> Result<serde_json::Value, Error<GetVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/versions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the current settings for blocking and mutex profiles
pub async fn get_debug_settings_prof(
    configuration: &configuration::Configuration,
) -> Result<serde_json::Value, Error<GetDebugSettingsProfError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/debug/settings/pprof", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDebugSettingsProfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enables blocking and mutex profiles, and returns the old settings
pub async fn put_debug_settings_prof(
    configuration: &configuration::Configuration,
) -> Result<serde_json::Value, Error<PutDebugSettingsProfError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/debug/settings/pprof", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutDebugSettingsProfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the merged (defaults + overrides) config file in json.
pub async fn get_config(
    configuration: &configuration::Configuration,
) -> Result<String, Error<GetConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/debug/settings/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a specific account public key, this call returns the account's status, balance and spendable amounts
pub async fn account_information(
    configuration: &configuration::Configuration,
format: Option<&str>,
address: &str,
exclude: Option<&str>,
) -> Result<serde_json::Value, Error<AccountInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;
    let p_address = address;
    let p_exclude = exclude;

    let uri_str = format!("{}/v2/accounts/{address}", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude {
        req_builder = req_builder.query(&[("exclude", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a specific account public key and asset ID, this call returns the account's asset holding and asset parameters (if either exist). Asset parameters will only be returned if the provided address is the asset's creator.
pub async fn account_asset_information(
    configuration: &configuration::Configuration,
format: Option<&str>,
address: &str,
asset_id: i32,
) -> Result<AccountAssetInformation200Response, Error<AccountAssetInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;
    let p_address = address;
    let p_asset_id = asset_id;

    let uri_str = format!("{}/v2/accounts/{address}/assets/{asset_id}", configuration.base_path, address=crate::apis::urlencode(p_address), asset_id=p_asset_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AccountAssetInformation200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AccountAssetInformation200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountAssetInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lookup an account's asset holdings.
pub async fn account_assets_information(
    configuration: &configuration::Configuration,
address: &str,
limit: Option<i32>,
next: Option<&str>,
) -> Result<AccountAssetsInformation200Response, Error<AccountAssetsInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;
    let p_limit = limit;
    let p_next = next;

    let uri_str = format!("{}/v2/accounts/{address}/assets", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_next {
        req_builder = req_builder.query(&[("next", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AccountAssetsInformation200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AccountAssetsInformation200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountAssetsInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a specific account public key and application ID, this call returns the account's application local state and global state (AppLocalState and AppParams, if either exists). Global state will only be returned if the provided address is the application's creator.
pub async fn account_application_information(
    configuration: &configuration::Configuration,
format: Option<&str>,
address: &str,
application_id: i32,
) -> Result<AccountApplicationInformation200Response, Error<AccountApplicationInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;
    let p_address = address;
    let p_application_id = application_id;

    let uri_str = format!("{}/v2/accounts/{address}/applications/{application_id}", configuration.base_path, address=crate::apis::urlencode(p_address), application_id=p_application_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AccountApplicationInformation200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AccountApplicationInformation200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountApplicationInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of pending transactions by address, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
pub async fn get_pending_transactions_by_address(
    configuration: &configuration::Configuration,
address: &str,
max: Option<i32>,
format: Option<&str>,
) -> Result<GetPendingTransactionsByAddress200Response, Error<GetPendingTransactionsByAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;
    let p_max = max;
    let p_format = format;

    let uri_str = format!("{}/v2/accounts/{address}/transactions/pending", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetPendingTransactionsByAddress200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetPendingTransactionsByAddress200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPendingTransactionsByAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the block for the given round.
pub async fn get_block(
    configuration: &configuration::Configuration,
format: Option<&str>,
round: i32,
header_only: Option<bool>,
) -> Result<GetBlock200Response, Error<GetBlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;
    let p_round = round;
    let p_header_only = header_only;

    let uri_str = format!("{}/v2/blocks/{round}", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_header_only {
        req_builder = req_builder.query(&[("header-only", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetBlock200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetBlock200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the top level transaction IDs for the block on the given round.
pub async fn get_block_txids(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<GetBlockTxids200Response, Error<GetBlockTxidsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/blocks/{round}/txids", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetBlockTxids200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetBlockTxids200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockTxidsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the block hash for the block on the given round.
pub async fn get_block_hash(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<GetBlockHash200Response, Error<GetBlockHashError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/blocks/{round}/hash", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetBlockHash200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetBlockHash200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockHashError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a proof for a transaction in a block.
pub async fn get_transaction_proof(
    configuration: &configuration::Configuration,
round: i32,
txid: &str,
hashtype: Option<&str>,
format: Option<&str>,
) -> Result<GetTransactionProof200Response, Error<GetTransactionProofError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;
    let p_txid = txid;
    let p_hashtype = hashtype;
    let p_format = format;

    let uri_str = format!("{}/v2/blocks/{round}/transactions/{txid}/proof", configuration.base_path, round=p_round, txid=crate::apis::urlencode(p_txid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_hashtype {
        req_builder = req_builder.query(&[("hashtype", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetTransactionProof200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetTransactionProof200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionProofError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all of the logs from outer and inner app calls in the given round
pub async fn get_block_logs(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<GetBlockLogs200Response, Error<GetBlockLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/blocks/{round}/logs", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetBlockLogs200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetBlockLogs200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the current supply reported by the ledger.
pub async fn get_supply(
    configuration: &configuration::Configuration,
) -> Result<GetSupply200Response, Error<GetSupplyError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/ledger/supply", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetSupply200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetSupply200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSupplyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Return a list of participation keys
pub async fn get_participation_keys(
    configuration: &configuration::Configuration,
) -> Result<Vec<serde_json::Value>, Error<GetParticipationKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/participation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec<serde_json::Value>`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec<serde_json::Value>`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetParticipationKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add a participation key to the node
pub async fn add_participation_key(
    configuration: &configuration::Configuration,
) -> Result<AddParticipationKey200Response, Error<AddParticipationKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/participation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AddParticipationKey200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AddParticipationKey200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddParticipationKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate and install participation keys to the node.
pub async fn generate_participation_keys(
    configuration: &configuration::Configuration,
address: &str,
dilution: Option<i32>,
first: i32,
last: i32,
) -> Result<String, Error<GenerateParticipationKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_address = address;
    let p_dilution = dilution;
    let p_first = first;
    let p_last = last;

    let uri_str = format!("{}/v2/participation/generate/{address}", configuration.base_path, address=crate::apis::urlencode(p_address));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_dilution {
        req_builder = req_builder.query(&[("dilution", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("first", &p_first.to_string())]);
    req_builder = req_builder.query(&[("last", &p_last.to_string())]);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateParticipationKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a participation ID, return information about that participation key
pub async fn get_participation_key_by_i_d(
    configuration: &configuration::Configuration,
participation_id: &str,
) -> Result<serde_json::Value, Error<GetParticipationKeyByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_participation_id = participation_id;

    let uri_str = format!("{}/v2/participation/{participation_id}", configuration.base_path, participation_id=crate::apis::urlencode(p_participation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetParticipationKeyByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a participation ID, append state proof keys to a particular set of participation keys
pub async fn append_keys(
    configuration: &configuration::Configuration,
participation_id: &str,
) -> Result<serde_json::Value, Error<AppendKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_participation_id = participation_id;

    let uri_str = format!("{}/v2/participation/{participation_id}", configuration.base_path, participation_id=crate::apis::urlencode(p_participation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppendKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a given participation key by ID
pub async fn delete_participation_key_by_i_d(
    configuration: &configuration::Configuration,
participation_id: &str,
) -> Result<(), Error<DeleteParticipationKeyByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_participation_id = participation_id;

    let uri_str = format!("{}/v2/participation/{participation_id}", configuration.base_path, participation_id=crate::apis::urlencode(p_participation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteParticipationKeyByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
pub async fn shutdown_node(
    configuration: &configuration::Configuration,
timeout: Option<i32>,
) -> Result<serde_json::Value, Error<ShutdownNodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_timeout = timeout;

    let uri_str = format!("{}/v2/shutdown", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ShutdownNodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the current node status.
pub async fn get_status(
    configuration: &configuration::Configuration,
) -> Result<GetStatus200Response, Error<GetStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetStatus200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetStatus200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Waits for a block to appear after round {round} and returns the node's status at the time. There is a 1 minute timeout, when reached the current status is returned regardless of whether or not it is the round after the given round.
pub async fn wait_for_block(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<WaitForBlock200Response, Error<WaitForBlockError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/status/wait_for_block_after/{round}", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `WaitForBlock200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `WaitForBlock200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WaitForBlockError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Broadcasts a raw transaction or transaction group to the network.
pub async fn raw_transaction(
    configuration: &configuration::Configuration,
) -> Result<RawTransaction200Response, Error<RawTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/transactions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `RawTransaction200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `RawTransaction200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RawTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
pub async fn raw_transaction_async(
    configuration: &configuration::Configuration,
) -> Result<(), Error<RawTransactionAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/transactions/async", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RawTransactionAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
pub async fn simulate_transaction(
    configuration: &configuration::Configuration,
format: Option<&str>,
) -> Result<SimulateTransaction200Response, Error<SimulateTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_format = format;

    let uri_str = format!("{}/v2/transactions/simulate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `SimulateTransaction200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `SimulateTransaction200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SimulateTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get parameters for constructing a new transaction
pub async fn transaction_params(
    configuration: &configuration::Configuration,
) -> Result<TransactionParams200Response, Error<TransactionParamsError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/transactions/params", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `TransactionParams200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `TransactionParams200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TransactionParamsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the list of pending transactions, sorted by priority, in decreasing order, truncated at the end at MAX. If MAX = 0, returns all pending transactions.
pub async fn get_pending_transactions(
    configuration: &configuration::Configuration,
max: Option<i32>,
format: Option<&str>,
) -> Result<GetPendingTransactions200Response, Error<GetPendingTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_max = max;
    let p_format = format;

    let uri_str = format!("{}/v2/transactions/pending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetPendingTransactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetPendingTransactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPendingTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a transaction ID of a recently submitted transaction, it returns information about it.  There are several cases when this might succeed:
/// - transaction committed (committed round > 0)
/// - transaction still in the pool (committed round = 0, pool error = "")
/// - transaction removed from pool due to error (committed round = 0, pool error != "")
/// Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
pub async fn pending_transaction_information(
    configuration: &configuration::Configuration,
txid: &str,
format: Option<&str>,
) -> Result<serde_json::Value, Error<PendingTransactionInformationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_txid = txid;
    let p_format = format;

    let uri_str = format!("{}/v2/transactions/pending/{txid}", configuration.base_path, txid=crate::apis::urlencode(p_txid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PendingTransactionInformationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get ledger deltas for a round.
pub async fn get_ledger_state_delta(
    configuration: &configuration::Configuration,
round: i32,
format: Option<&str>,
) -> Result<serde_json::Value, Error<GetLedgerStateDeltaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;
    let p_format = format;

    let uri_str = format!("{}/v2/deltas/{round}", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLedgerStateDeltaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get ledger deltas for transaction groups in a given round.
pub async fn get_transaction_group_ledger_state_deltas_for_round(
    configuration: &configuration::Configuration,
round: i32,
format: Option<&str>,
) -> Result<GetTransactionGroupLedgerStateDeltasForRound200Response, Error<GetTransactionGroupLedgerStateDeltasForRoundError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;
    let p_format = format;

    let uri_str = format!("{}/v2/deltas/{round}/txn/group", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetTransactionGroupLedgerStateDeltasForRound200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetTransactionGroupLedgerStateDeltasForRound200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTransactionGroupLedgerStateDeltasForRoundError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a ledger delta for a given transaction group.
pub async fn get_ledger_state_delta_for_transaction_group(
    configuration: &configuration::Configuration,
id: &str,
format: Option<&str>,
) -> Result<serde_json::Value, Error<GetLedgerStateDeltaForTransactionGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_format = format;

    let uri_str = format!("{}/v2/deltas/txn/group/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLedgerStateDeltaForTransactionGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a state proof that covers a given round
pub async fn get_state_proof(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<serde_json::Value, Error<GetStateProofError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/stateproofs/{round}", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetStateProofError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets a proof for a given light block header inside a state proof commitment
pub async fn get_light_block_header_proof(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<serde_json::Value, Error<GetLightBlockHeaderProofError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/blocks/{round}/lightheader/proof", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLightBlockHeaderProofError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a application ID, it returns application information including creator, approval and clear programs, global and local schemas, and global state.
pub async fn get_application_by_i_d(
    configuration: &configuration::Configuration,
application_id: i32,
) -> Result<serde_json::Value, Error<GetApplicationByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_application_id = application_id;

    let uri_str = format!("{}/v2/applications/{application_id}", configuration.base_path, application_id=p_application_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given an application ID, return all Box names. No particular ordering is guaranteed. Request fails when client or server-side configured limits prevent returning all Box names.
pub async fn get_application_boxes(
    configuration: &configuration::Configuration,
application_id: i32,
max: Option<i32>,
) -> Result<GetApplicationBoxes200Response, Error<GetApplicationBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_application_id = application_id;
    let p_max = max;

    let uri_str = format!("{}/v2/applications/{application_id}/boxes", configuration.base_path, application_id=p_application_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetApplicationBoxes200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetApplicationBoxes200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given an application ID and box name, it returns the round, box name, and value (each base64 encoded). Box names must be in the goal app call arg encoding form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
pub async fn get_application_box_by_name(
    configuration: &configuration::Configuration,
application_id: i32,
name: &str,
) -> Result<serde_json::Value, Error<GetApplicationBoxByNameError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_application_id = application_id;
    let p_name = name;

    let uri_str = format!("{}/v2/applications/{application_id}/box", configuration.base_path, application_id=p_application_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("name", &p_name.to_string())]);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApplicationBoxByNameError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a asset ID, it returns asset information including creator, name, total supply and special addresses.
pub async fn get_asset_by_i_d(
    configuration: &configuration::Configuration,
asset_id: i32,
) -> Result<serde_json::Value, Error<GetAssetByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asset_id = asset_id;

    let uri_str = format!("{}/v2/assets/{asset_id}", configuration.base_path, asset_id=p_asset_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssetByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the minimum sync round for the ledger.
pub async fn get_sync_round(
    configuration: &configuration::Configuration,
) -> Result<GetSyncRound200Response, Error<GetSyncRoundError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/ledger/sync", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetSyncRound200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetSyncRound200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSyncRoundError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unset the ledger sync round.
pub async fn unset_sync_round(
    configuration: &configuration::Configuration,
) -> Result<(), Error<UnsetSyncRoundError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/ledger/sync", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnsetSyncRoundError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the minimum sync round on the ledger.
pub async fn set_sync_round(
    configuration: &configuration::Configuration,
round: i32,
) -> Result<(), Error<SetSyncRoundError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_round = round;

    let uri_str = format!("{}/v2/ledger/sync/{round}", configuration.base_path, round=p_round);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetSyncRoundError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given TEAL source code in plain text, return base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style). This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
pub async fn teal_compile(
    configuration: &configuration::Configuration,
sourcemap: Option<bool>,
) -> Result<TealCompile200Response, Error<TealCompileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sourcemap = sourcemap;

    let uri_str = format!("{}/v2/teal/compile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_sourcemap {
        req_builder = req_builder.query(&[("sourcemap", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `TealCompile200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `TealCompile200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TealCompileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given the program bytes, return the TEAL source code in plain text. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
pub async fn teal_disassemble(
    configuration: &configuration::Configuration,
) -> Result<TealDisassemble200Response, Error<TealDisassembleError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/teal/disassemble", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `TealDisassemble200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `TealDisassemble200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TealDisassembleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a catchpoint, it starts catching up to this catchpoint
pub async fn start_catchup(
    configuration: &configuration::Configuration,
catchpoint: &str,
min: Option<i32>,
) -> Result<StartCatchup200Response, Error<StartCatchupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_catchpoint = catchpoint;
    let p_min = min;

    let uri_str = format!("{}/v2/catchup/{catchpoint}", configuration.base_path, catchpoint=crate::apis::urlencode(p_catchpoint));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_min {
        req_builder = req_builder.query(&[("min", &param_value.to_string())]);
    }

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `StartCatchup200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `StartCatchup200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartCatchupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Given a catchpoint, it aborts catching up to this catchpoint
pub async fn abort_catchup(
    configuration: &configuration::Configuration,
catchpoint: &str,
) -> Result<AbortCatchup200Response, Error<AbortCatchupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_catchpoint = catchpoint;

    let uri_str = format!("{}/v2/catchup/{catchpoint}", configuration.base_path, catchpoint=crate::apis::urlencode(p_catchpoint));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `AbortCatchup200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `AbortCatchup200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AbortCatchupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
pub async fn teal_dryrun(
    configuration: &configuration::Configuration,
) -> Result<TealDryrun200Response, Error<TealDryrunError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/teal/dryrun", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `TealDryrun200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `TealDryrun200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TealDryrunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns OK if experimental API is enabled.
pub async fn experimental_check(
    configuration: &configuration::Configuration,
) -> Result<(), Error<ExperimentalCheckError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/experimental", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExperimentalCheckError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the current timestamp offset.
pub async fn get_block_time_stamp_offset(
    configuration: &configuration::Configuration,
) -> Result<GetBlockTimeStampOffset200Response, Error<GetBlockTimeStampOffsetError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/v2/devmode/blocks/offset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `GetBlockTimeStampOffset200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `GetBlockTimeStampOffset200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlockTimeStampOffsetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the timestamp offset (seconds) for blocks in dev mode. Providing an offset of 0 will unset this value and try to use the real clock for the timestamp.
pub async fn set_block_time_stamp_offset(
    configuration: &configuration::Configuration,
offset: i32,
) -> Result<(), Error<SetBlockTimeStampOffsetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_offset = offset;

    let uri_str = format!("{}/v2/devmode/blocks/offset/{offset}", configuration.base_path, offset=p_offset);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);


    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let _content = resp.text().await?;
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetBlockTimeStampOffsetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

