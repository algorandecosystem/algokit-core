import { toCamelCaseKeysDeep, toKebabCaseKeysDeep } from './casing'
import { BYTES_FIELDS } from './bytes-map'
import type { BodyValue } from './BaseHttpRequest'
{% if uses_stx %}
import { STX_FIELDS } from './stx-map'
import { encodeSignedTransaction, encodeSignedTransactions, decodeSignedTransaction } from '@algorandfoundation/algokit-transact'
import { encodeMsgPack } from './msgpack'
{% endif %}

export type Media = 'application/json' | 'application/msgpack' | 'application/x-binary' | 'application/octet-stream' | string

export function serialize(modelKey: string | undefined, value: BodyValue, mediaType: Media): BodyValue | Uint8Array {
  if (value == null) return value
  if (value instanceof Uint8Array) return value

  if (typeof mediaType === 'string' && mediaType.includes('json')) {
    // Convert Uint8Array bytes fields to base64 for JSON
    const mapped = mapBytesFields(modelKey, value, 'toBase64')
    return toKebabCaseKeysDeep(mapped)
  }

  if (typeof mediaType === 'string' && mediaType.includes('msgpack')) {
    {% if uses_stx %}
    // Encode any nested SignedTransaction fields to msgpack bytes first
    const withStx = encodeNestedSignedTransactions(modelKey, value)
    return toKebabCaseKeysDeep(withStx)
    {% else %}
    // Msgpack gets bytes natively; only key normalization
    return toKebabCaseKeysDeep(value)
    {% endif %}
  }

  return value
}

export function deserialize<T>(modelKey: string | undefined, raw: unknown, mediaType: Media): T {
  if (raw == null) return raw as T

  if (typeof mediaType === 'string' && (mediaType.includes('json') || mediaType.includes('msgpack'))) {
    const camel = toCamelCaseKeysDeep(raw)
    // For JSON, convert base64 strings into Uint8Array for bytes fields
    const mappedBytes = mediaType.includes('json') ? mapBytesFields(modelKey, camel, 'toBytes') : camel
    {% if uses_stx %}
    const withStx = decodeNestedSignedTransactions(modelKey, mappedBytes, mediaType)
    const auto = decodeSignedTransactionsAuto(withStx)
    return auto as T
    {% else %}
    return mappedBytes as T
    {% endif %}
  }

  return raw as T
}

function mapBytesFields(modelKey: string | undefined, value: any, direction: 'toBase64' | 'toBytes'): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (!modelKey || value == null || typeof value !== 'object') return value
  const fields = BYTES_FIELDS[modelKey]
  if (!fields || fields.length === 0) return value
  const out: any = Array.isArray(value) ? [...value] : { ...value }
  for (const f of fields) {
    if (f in out && out[f] != null) {
      if (direction === 'toBase64' && out[f] instanceof Uint8Array) {
        out[f] = btoa(String.fromCharCode(...out[f] as Uint8Array))
      } else if (direction === 'toBytes' && typeof out[f] === 'string') {
        const s = out[f] as string
        const bin = atob(s)
        const bytes = new Uint8Array(bin.length)
        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i)
        out[f] = bytes
      }
    }
  }
  return out
}

{% if uses_stx %}
function decodeNestedSignedTransactions(modelKey: string | undefined, value: any, mediaType: Media): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (!modelKey || value == null || typeof value !== 'object') return value
  const paths = STX_FIELDS[modelKey]
  if (!paths || paths.length === 0) return value
  let out: any = Array.isArray(value) ? [...value] : { ...value }
  for (const path of paths) {
    const tokens = path.split('.')
    out = decodeAtPath(out, tokens, 0, mediaType)
  }
  return out
}

function decodeAtPath(current: any, tokens: string[], idx: number, mediaType: Media): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (current == null) return current
  if (idx >= tokens.length) {
    // Leaf: decode a single STX or an array of STX
    if (Array.isArray(current)) {
      return current.map((item) => decodeLeaf(item, mediaType))
    }
    return decodeLeaf(current, mediaType)
  }
  const token = tokens[idx]
  if (token === '[]') {
    if (!Array.isArray(current)) return current
    return current.map((item) => decodeAtPath(item, tokens, idx + 1, mediaType))
  }
  if (typeof current !== 'object') return current
  const clone: any = Array.isArray(current) ? [...current] : { ...current }
  clone[token] = decodeAtPath((current as any)[token], tokens, idx + 1, mediaType) // eslint-disable-line @typescript-eslint/no-explicit-any
  return clone
}

function decodeLeaf(value: any, mediaType: Media): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (value == null) return value
  if (value instanceof Uint8Array) return decodeSignedTransaction(value)
  if (typeof value === 'string') {
    // For JSON responses STX may be base64 string
    try {
      const bin = atob(value)
      const bytes = new Uint8Array(bin.length)
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i)
      return decodeSignedTransaction(bytes)
    } catch {
      return value
    }
  }
  if (typeof value === 'object') {
    // Server may embed STX as object (DTO keys); re-encode and decode via domain codec
    try {
      const bytes = encodeMsgPack(value)
      return decodeSignedTransaction(bytes)
    } catch {
      return value
    }
  }
  return value
}

function decodeSignedTransactionsAuto(value: any): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (value == null) return value
  if (value instanceof Uint8Array) return value
  if (Array.isArray(value)) return value.map(decodeSignedTransactionsAuto)
  if (typeof value !== 'object') return value

  // Heuristic: object with a 'txn' sub-object that looks like TransactionDto â†’ decode as SignedTransaction
  if ('txn' in value && value.txn && typeof value.txn === 'object') {
    const tx = (value as any).txn
    const type = tx.type
    if (typeof type === 'string' && ['pay', 'axfer', 'afrz', 'acfg', 'keyreg', 'appl', 'stpf', 'hb'].includes(type)) {
      try {
        const prepared = toStxMsgpackReady(value)
        const bytes = encodeMsgPack(prepared)
        return decodeSignedTransaction(bytes)
      } catch {}
    }
  }

  const result: any = {}
  for (const [k, v] of Object.entries(value)) result[k] = decodeSignedTransactionsAuto(v)
  return result
}

function toStxMsgpackReady(value: any): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (value == null || typeof value !== 'object') return value
  const out: any = Array.isArray(value) ? [] : {}
  for (const [k, v] of Object.entries(value)) {
    if (v == null) {
      out[k] = v
      continue
    }
    if (typeof v === 'string' && shouldTreatAsBytesKey(k)) {
      const maybe = tryBase64ToBytes(v)
      out[k] = maybe ?? v
    } else if (Array.isArray(v)) {
      out[k] = v.map((item) => (typeof item === 'string' && shouldTreatAsBytesKey(k) ? tryBase64ToBytes(item) ?? item : toStxMsgpackReady(item)))
    } else if (typeof v === 'object') {
      out[k] = toStxMsgpackReady(v)
    } else {
      out[k] = v
    }
  }
  return out
}

function shouldTreatAsBytesKey(key: string): boolean {
  // Keys in SignedTransactionDto and nested DTOs that are bytes in msgpack
  return (
    key === 'snd' ||
    key === 'rcv' ||
    key === 'gh' ||
    key === 'note' ||
    key === 'lx' ||
    key === 'rekey' ||
    key === 'grp' ||
    key === 'close' ||
    key === 'arcv' ||
    key === 'aclose' ||
    key === 'asnd' ||
    key === 'votekey' ||
    key === 'selkey' ||
    key === 'sprfkey' ||
    key === 'apap' ||
    key === 'apsu' ||
    key === 'apaa' ||
    key === 'apat' ||
    key === 'l' ||
    key === 'arg' ||
    key === 'sig' ||
    key === 'pk' ||
    key === 's' ||
    key === 'sgnr'
  )
}

function tryBase64ToBytes(s: string): Uint8Array | null {
  try {
    const bin = atob(s)
    const bytes = new Uint8Array(bin.length)
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i)
    return bytes
  } catch {
    return null
  }
}
{% endif %}

{% if uses_stx %}
function encodeNestedSignedTransactions(modelKey: string | undefined, value: any): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (!modelKey || value == null || typeof value !== 'object') return value
  const paths = STX_FIELDS[modelKey]
  if (!paths || paths.length === 0) return value
  let out: any = Array.isArray(value) ? [...value] : { ...value }
  for (const path of paths) {
    const tokens = path.split('.')
    out = encodeAtPath(out, tokens, 0)
  }
  return out
}

function encodeAtPath(current: any, tokens: string[], idx: number): any { // eslint-disable-line @typescript-eslint/no-explicit-any
  if (current == null) return current
  if (idx >= tokens.length) {
    // Leaf: encode a single STX or an array of STX
    if (Array.isArray(current)) return encodeSignedTransactions(current as any)
    return encodeSignedTransaction(current as any)
  }
  const token = tokens[idx]
  if (token === '[]') {
    if (!Array.isArray(current)) return current
    return current.map((item) => encodeAtPath(item, tokens, idx + 1))
  }
  if (typeof current !== 'object') return current
  const clone: any = Array.isArray(current) ? [...current] : { ...current }
  clone[token] = encodeAtPath((current as any)[token], tokens, idx + 1)
  return clone
}
{% endif %}


