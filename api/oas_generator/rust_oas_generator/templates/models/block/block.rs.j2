/*
 * Algod REST API.
 *
 * API endpoint for algod operations.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: contact@algorand.com
 * Generated by: Rust OpenAPI Generator
 */

use crate::models;
{% if not ffi %}
use algokit_transact::SignedTransaction as AlgokitSignedTransaction;
use serde::{Deserialize, Serialize};
use serde_with::{Bytes, serde_as};
use algokit_transact::AlgorandMsgpack;
{% else %}
use algokit_transact_ffi::SignedTransaction as AlgokitSignedTransaction;
use algod_client::models::Block as RustBlock;
{% endif %}

use crate::models::SignedTxnInBlock;
use crate::models::BlockStateProofTracking;

/// Block contains the BlockHeader and the list of transactions (Payset).
#[derive(Clone, Debug, PartialEq)]
{% if not ffi %}
#[serde_as]
#[derive(Serialize, Deserialize)]
{% else %}
#[derive(uniffi::Record)]
{% endif %}
pub struct Block {
    /// [rnd] Round number.
    {% if not ffi %}
    #[serde(rename = "rnd", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub round: Option<u64>,
    /// [prev] Previous block hash.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "prev", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub previous_block_hash: Option<Vec<u8>>,
    /// [prev512] Previous block hash using SHA-512.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "prev512", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub previous_block_hash_512: Option<Vec<u8>>,
    /// [seed] Sortition seed.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "seed", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub seed: Option<Vec<u8>>,
    /// [txn] Root of transaction merkle tree using SHA512_256.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "txn", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub transactions_root: Option<Vec<u8>>,
    /// [txn256] Root of transaction vector commitment using SHA256.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "txn256", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub transactions_root_sha256: Option<Vec<u8>>,
    /// [txn512] Root of transaction vector commitment using SHA512.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "txn512", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub transactions_root_sha512: Option<Vec<u8>>,
    /// [ts] Block timestamp in seconds since epoch.
    {% if not ffi %}
    #[serde(rename = "ts", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub timestamp: Option<u64>,
    /// [gen] Genesis ID.
    {% if not ffi %}
    #[serde(rename = "gen", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub genesis_id: Option<String>,
    /// [gh] Genesis hash.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "gh", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub genesis_hash: Option<Vec<u8>>,
    /// [prp] Proposer address.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "prp", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub proposer: Option<Vec<u8>>,
    /// [fc] Fees collected in this block.
    {% if not ffi %}
    #[serde(rename = "fc", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub fees_collected: Option<u64>,
    /// [bi] Bonus incentive for block proposal.
    {% if not ffi %}
    #[serde(rename = "bi", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub bonus: Option<u64>,
    /// [pp] Proposer payout.
    {% if not ffi %}
    #[serde(rename = "pp", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub proposer_payout: Option<u64>,
    /// [fees] FeeSink address.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "fees", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub fee_sink: Option<Vec<u8>>,
    /// [rwd] RewardsPool address.
    {% if not ffi %}
    #[serde_as(as = "Option<Bytes>")]
    #[serde(rename = "rwd", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub rewards_pool: Option<Vec<u8>>,
    /// [earn] Rewards level.
    {% if not ffi %}
    #[serde(rename = "earn", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub rewards_level: Option<u64>,
    /// [rate] Rewards rate.
    {% if not ffi %}
    #[serde(rename = "rate", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub rewards_rate: Option<u64>,
    /// [frac] Rewards residue.
    {% if not ffi %}
    #[serde(rename = "frac", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub rewards_residue: Option<u64>,
    /// [rwcalr] Rewards recalculation round.
    {% if not ffi %}
    #[serde(rename = "rwcalr", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub rewards_recalculation_round: Option<u64>,
    /// [proto] Current consensus protocol.
    {% if not ffi %}
    #[serde(rename = "proto", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub current_protocol: Option<String>,
    /// [nextproto] Next proposed protocol.
    {% if not ffi %}
    #[serde(rename = "nextproto", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub next_protocol: Option<String>,
    /// [nextyes] Next protocol approvals.
    {% if not ffi %}
    #[serde(rename = "nextyes", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub next_protocol_approvals: Option<u64>,
    /// [nextbefore] Next protocol vote deadline.
    {% if not ffi %}
    #[serde(rename = "nextbefore", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub next_protocol_vote_before: Option<u64>,
    /// [nextswitch] Next protocol switch round.
    {% if not ffi %}
    #[serde(rename = "nextswitch", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub next_protocol_switch_on: Option<u64>,
    /// [upgradeprop] Upgrade proposal.
    {% if not ffi %}
    #[serde(rename = "upgradeprop", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub upgrade_propose: Option<String>,
    /// [upgradedelay] Upgrade delay in rounds.
    {% if not ffi %}
    #[serde(rename = "upgradedelay", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub upgrade_delay: Option<u64>,
    /// [upgradeyes] Upgrade approval flag.
    {% if not ffi %}
    #[serde(rename = "upgradeyes", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub upgrade_approve: Option<bool>,
    /// [tc] Transaction counter.
    {% if not ffi %}
    #[serde(rename = "tc", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub txn_counter: Option<u64>,
    /// [spt] State proof tracking data keyed by state proof type.
    {% if not ffi %}
    #[serde(rename = "spt", skip_serializing_if = "Option::is_none", default)]
    {% endif %}
    pub state_proof_tracking: Option<BlockStateProofTracking>,
    /// [partupdrmv] Expired participation accounts.
    {% if not ffi %}
    #[serde_as(as = "Option<Vec<Bytes>>")]
    #[serde(rename = "partupdrmv", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub expired_participation_accounts: Option<Vec<Vec<u8>>>,
    /// [partupdabs] Absent participation accounts.
    {% if not ffi %}
    #[serde_as(as = "Option<Vec<Bytes>>")]
    #[serde(rename = "partupdabs", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub absent_participation_accounts: Option<Vec<Vec<u8>>>,
    /// [txns] Block transactions (Payset).
    {% if not ffi %}
    #[serde(rename = "txns", skip_serializing_if = "Option::is_none")]
    {% endif %}
    pub transactions: Option<Vec<SignedTxnInBlock>>,
}

{% if not ffi %}
impl Default for Block {
    fn default() -> Self {
        Self {
            round: None,
            previous_block_hash: None,
            previous_block_hash_512: None,
            seed: None,
            transactions_root: None,
            transactions_root_sha256: None,
            transactions_root_sha512: None,
            timestamp: None,
            genesis_id: None,
            genesis_hash: None,
            proposer: None,
            fees_collected: None,
            bonus: None,
            proposer_payout: None,
            fee_sink: None,
            rewards_pool: None,
            rewards_level: None,
            rewards_rate: None,
            rewards_residue: None,
            rewards_recalculation_round: None,
            current_protocol: None,
            next_protocol: None,
            next_protocol_approvals: None,
            next_protocol_vote_before: None,
            next_protocol_switch_on: None,
            upgrade_propose: None,
            upgrade_delay: None,
            upgrade_approve: None,
            txn_counter: None,
            state_proof_tracking: None,
            expired_participation_accounts: None,
            absent_participation_accounts: None,
            transactions: None,
        }
    }
}

impl AlgorandMsgpack for Block {
    const PREFIX: &'static [u8] = b"";
}

impl Block {
    /// Default constructor for Block
    pub fn new() -> Block {
        Block::default()
    }

    /// Encode this struct to msgpack bytes using AlgorandMsgpack trait
    pub fn to_msgpack(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        Ok(self.encode()?)
    }

    /// Decode msgpack bytes to this struct using AlgorandMsgpack trait
    pub fn from_msgpack(bytes: &[u8]) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self::decode(bytes)?)
    }
}
{% endif %}

{% if ffi %}
impl From<RustBlock> for Block {
    fn from(rust_struct: RustBlock) -> Self {
        Self {
            round: rust_struct.round,
            previous_block_hash: rust_struct.previous_block_hash,
            previous_block_hash_512: rust_struct.previous_block_hash_512,
            seed: rust_struct.seed,
            transactions_root: rust_struct.transactions_root,
            transactions_root_sha256: rust_struct.transactions_root_sha256,
            transactions_root_sha512: rust_struct.transactions_root_sha512,
            timestamp: rust_struct.timestamp,
            genesis_id: rust_struct.genesis_id,
            genesis_hash: rust_struct.genesis_hash,
            proposer: rust_struct.proposer,
            fees_collected: rust_struct.fees_collected,
            bonus: rust_struct.bonus,
            proposer_payout: rust_struct.proposer_payout,
            fee_sink: rust_struct.fee_sink,
            rewards_pool: rust_struct.rewards_pool,
            rewards_level: rust_struct.rewards_level,
            rewards_rate: rust_struct.rewards_rate,
            rewards_residue: rust_struct.rewards_residue,
            rewards_recalculation_round: rust_struct.rewards_recalculation_round,
            current_protocol: rust_struct.current_protocol,
            next_protocol: rust_struct.next_protocol,
            next_protocol_approvals: rust_struct.next_protocol_approvals,
            next_protocol_vote_before: rust_struct.next_protocol_vote_before,
            next_protocol_switch_on: rust_struct.next_protocol_switch_on,
            upgrade_propose: rust_struct.upgrade_propose,
            upgrade_delay: rust_struct.upgrade_delay,
            upgrade_approve: rust_struct.upgrade_approve,
            txn_counter: rust_struct.txn_counter,
            state_proof_tracking: rust_struct.state_proof_tracking.map(|v| v.into_iter().map(|(k, v)| (k, v.into())).collect()),
            expired_participation_accounts: rust_struct.expired_participation_accounts,
            absent_participation_accounts: rust_struct.absent_participation_accounts,
            transactions: rust_struct.transactions.map(|v| v.into_iter().map(|tx| tx.into()).collect()),
        }
    }
}

impl TryFrom<Block> for RustBlock {
    type Error = algokit_transact_ffi::AlgoKitTransactError;

    fn try_from(ffi_struct: Block) -> Result<Self, Self::Error> {
        Ok(Self {
            round: ffi_struct.round,
            previous_block_hash: ffi_struct.previous_block_hash,
            previous_block_hash_512: ffi_struct.previous_block_hash_512,
            seed: ffi_struct.seed,
            transactions_root: ffi_struct.transactions_root,
            transactions_root_sha256: ffi_struct.transactions_root_sha256,
            transactions_root_sha512: ffi_struct.transactions_root_sha512,
            timestamp: ffi_struct.timestamp,
            genesis_id: ffi_struct.genesis_id,
            genesis_hash: ffi_struct.genesis_hash,
            proposer: ffi_struct.proposer,
            fees_collected: ffi_struct.fees_collected,
            bonus: ffi_struct.bonus,
            proposer_payout: ffi_struct.proposer_payout,
            fee_sink: ffi_struct.fee_sink,
            rewards_pool: ffi_struct.rewards_pool,
            rewards_level: ffi_struct.rewards_level,
            rewards_rate: ffi_struct.rewards_rate,
            rewards_residue: ffi_struct.rewards_residue,
            rewards_recalculation_round: ffi_struct.rewards_recalculation_round,
            current_protocol: ffi_struct.current_protocol,
            next_protocol: ffi_struct.next_protocol,
            next_protocol_approvals: ffi_struct.next_protocol_approvals,
            next_protocol_vote_before: ffi_struct.next_protocol_vote_before,
            next_protocol_switch_on: ffi_struct.next_protocol_switch_on,
            upgrade_propose: ffi_struct.upgrade_propose,
            upgrade_delay: ffi_struct.upgrade_delay,
            upgrade_approve: ffi_struct.upgrade_approve,
            txn_counter: ffi_struct.txn_counter,
            state_proof_tracking: ffi_struct.state_proof_tracking.map(|v| v.into_iter().map(|(k, v)| (k, v.into())).collect()),
            expired_participation_accounts: ffi_struct.expired_participation_accounts,
            absent_participation_accounts: ffi_struct.absent_participation_accounts,
            transactions: ffi_struct.transactions.map(|v| v.into_iter().map(|tx| tx.try_into()).collect::<Result<Vec<_>, _>>()).transpose()?,
        })
    }
}
{% endif %}
