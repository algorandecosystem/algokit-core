// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi.algokit_transact_ffi

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import android.location.Address
import com.sun.jna.Callback
import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicLong

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
  // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
  // When dealing with these fields, make sure to call `toULong()`.
  @JvmField var capacity: Long = 0

  @JvmField var len: Long = 0

  @JvmField var data: Pointer? = null

  class ByValue :
    RustBuffer(),
    Structure.ByValue

  class ByReference :
    RustBuffer(),
    Structure.ByReference

  internal fun setValue(other: RustBuffer) {
    capacity = other.capacity
    len = other.len
    data = other.data
  }

  companion object {
    internal fun alloc(size: ULong = 0UL) =
      uniffiRustCall { status ->
        // Note: need to convert the size to a `Long` value to make this work with JVM.
        UniffiLib.INSTANCE.ffi_algokit_transact_ffi_rustbuffer_alloc(size.toLong(), status)
      }.also {
        if (it.data == null) {
          throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=$size)")
        }
      }

    internal fun create(
      capacity: ULong,
      len: ULong,
      data: Pointer?,
    ): RustBuffer.ByValue {
      var buf = RustBuffer.ByValue()
      buf.capacity = capacity.toLong()
      buf.len = len.toLong()
      buf.data = data
      return buf
    }

    internal fun free(buf: RustBuffer.ByValue) =
      uniffiRustCall { status ->
        UniffiLib.INSTANCE.ffi_algokit_transact_ffi_rustbuffer_free(buf, status)
      }
  }

  @Suppress("TooGenericExceptionThrown")
  fun asByteBuffer() =
    this.data?.getByteBuffer(0, this.len.toLong())?.also {
      it.order(ByteOrder.BIG_ENDIAN)
    }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
  /**
   * Set the pointed-to `RustBuffer` to the given value.
   */
  fun setValue(value: RustBuffer.ByValue) {
    // NOTE: The offsets are as they are in the C-like struct.
    val pointer = getPointer()
    pointer.setLong(0, value.capacity)
    pointer.setLong(8, value.len)
    pointer.setPointer(16, value.data)
  }

  /**
   * Get a `RustBuffer.ByValue` from this reference.
   */
  fun getValue(): RustBuffer.ByValue {
    val pointer = getPointer()
    val value = RustBuffer.ByValue()
    value.writeField("capacity", pointer.getLong(0))
    value.writeField("len", pointer.getLong(8))
    value.writeField("data", pointer.getLong(16))

    return value
  }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
  @JvmField var len: Int = 0

  @JvmField var data: Pointer? = null

  class ByValue :
    ForeignBytes(),
    Structure.ByValue
}

/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
  // Convert an FFI type to a Kotlin type
  fun lift(value: FfiType): KotlinType

  // Convert an Kotlin type to an FFI type
  fun lower(value: KotlinType): FfiType

  // Read a Kotlin type from a `ByteBuffer`
  fun read(buf: ByteBuffer): KotlinType

  // Calculate bytes to allocate when creating a `RustBuffer`
  //
  // This must return at least as many bytes as the write() function will
  // write. It can return more bytes than needed, for example when writing
  // Strings we can't know the exact bytes needed until we the UTF-8
  // encoding, so we pessimistically allocate the largest size possible (3
  // bytes per codepoint).  Allocating extra bytes is not really a big deal
  // because the `RustBuffer` is short-lived.
  fun allocationSize(value: KotlinType): ULong

  // Write a Kotlin type to a `ByteBuffer`
  fun write(
    value: KotlinType,
    buf: ByteBuffer,
  )

  // Lower a value into a `RustBuffer`
  //
  // This method lowers a value into a `RustBuffer` rather than the normal
  // FfiType.  It's used by the callback interface code.  Callback interface
  // returns are always serialized into a `RustBuffer` regardless of their
  // normal FFI type.
  fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
    val rbuf = RustBuffer.alloc(allocationSize(value))
    try {
      val bbuf =
        rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
          it.order(ByteOrder.BIG_ENDIAN)
        }
      write(value, bbuf)
      rbuf.writeField("len", bbuf.position().toLong())
      return rbuf
    } catch (e: Throwable) {
      RustBuffer.free(rbuf)
      throw e
    }
  }

  // Lift a value from a `RustBuffer`.
  //
  // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
  // It's currently only used by the `FfiConverterRustBuffer` class below.
  fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
    val byteBuf = rbuf.asByteBuffer()!!
    try {
      val item = read(byteBuf)
      if (byteBuf.hasRemaining()) {
        throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
      }
      return item
    } finally {
      RustBuffer.free(rbuf)
    }
  }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType> : FfiConverter<KotlinType, RustBuffer.ByValue> {
  override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)

  override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
  @JvmField var code: Byte = 0

  @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

  class ByValue :
    UniffiRustCallStatus(),
    Structure.ByValue

  fun isSuccess(): Boolean = code == UNIFFI_CALL_SUCCESS

  fun isError(): Boolean = code == UNIFFI_CALL_ERROR

  fun isPanic(): Boolean = code == UNIFFI_CALL_UNEXPECTED_ERROR

  companion object {
    fun create(
      code: Byte,
      errorBuf: RustBuffer.ByValue,
    ): UniffiRustCallStatus.ByValue {
      val callStatus = UniffiRustCallStatus.ByValue()
      callStatus.code = code
      callStatus.error_buf = errorBuf
      return callStatus
    }
  }
}

class InternalException(
  message: String,
) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
  fun lift(error_buf: RustBuffer.ByValue): E
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E : kotlin.Exception> uniffiRustCallWithError(
  errorHandler: UniffiRustCallStatusErrorHandler<E>,
  callback: (UniffiRustCallStatus) -> U,
): U {
  var status = UniffiRustCallStatus()
  val return_value = callback(status)
  uniffiCheckCallStatus(errorHandler, status)
  return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun <E : kotlin.Exception> uniffiCheckCallStatus(
  errorHandler: UniffiRustCallStatusErrorHandler<E>,
  status: UniffiRustCallStatus,
) {
  if (status.isSuccess()) {
    return
  } else if (status.isError()) {
    throw errorHandler.lift(status.error_buf)
  } else if (status.isPanic()) {
    // when the rust code sees a panic, it tries to construct a rustbuffer
    // with the message.  but if that code panics, then it just sends back
    // an empty buffer.
    if (status.error_buf.len > 0) {
      throw InternalException(FfiConverterString.lift(status.error_buf))
    } else {
      throw InternalException("Rust panic")
    }
  } else {
    throw InternalException("Unknown rust call status: $status.code")
  }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler : UniffiRustCallStatusErrorHandler<InternalException> {
  override fun lift(error_buf: RustBuffer.ByValue): InternalException {
    RustBuffer.free(error_buf)
    return InternalException("Unexpected CALL_ERROR")
  }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U =
  uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)

internal inline fun <T> uniffiTraitInterfaceCall(
  callStatus: UniffiRustCallStatus,
  makeCall: () -> T,
  writeReturn: (T) -> Unit,
) {
  try {
    writeReturn(makeCall())
  } catch (e: kotlin.Exception) {
    callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
    callStatus.error_buf = FfiConverterString.lower(e.toString())
  }
}

internal inline fun <T, reified E : Throwable> uniffiTraitInterfaceCallWithError(
  callStatus: UniffiRustCallStatus,
  makeCall: () -> T,
  writeReturn: (T) -> Unit,
  lowerError: (E) -> RustBuffer.ByValue,
) {
  try {
    writeReturn(makeCall())
  } catch (e: kotlin.Exception) {
    if (e is E) {
      callStatus.code = UNIFFI_CALL_ERROR
      callStatus.error_buf = lowerError(e)
    } else {
      callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
      callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
  }
}

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T : Any> {
  private val map = ConcurrentHashMap<Long, T>()
  private val counter =
    java.util.concurrent.atomic
      .AtomicLong(0)

  val size: Int
    get() = map.size

  // Insert a new object into the handle map and get a handle for it
  fun insert(obj: T): Long {
    val handle = counter.getAndAdd(1)
    map.put(handle, obj)
    return handle
  }

  // Get an object from the handle map
  fun get(handle: Long): T = map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")

  // Remove an entry from the handlemap and get the Kotlin object back
  fun remove(handle: Long): T = map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
  val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
  if (libOverride != null) {
    return libOverride
  }
  return "algokit_transact_ffi"
}

private inline fun <reified Lib : Library> loadIndirect(componentName: String): Lib =
  Native.load<Lib>(findLibraryName(componentName), Lib::class.java)

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
  fun callback(
    `data`: Long,
    `pollResult`: Byte,
  )
}

internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
  fun callback(`handle`: Long)
}

internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
  fun callback(`handle`: Long)
}

@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
  @JvmField internal var `handle`: Long = 0.toLong(),
  @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
  class UniffiByValue(
    `handle`: Long = 0.toLong(),
    `free`: UniffiForeignFutureFree? = null,
  ) : UniffiForeignFuture(`handle`, `free`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFuture) {
    `handle` = other.`handle`
    `free` = other.`free`
  }
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
  @JvmField internal var `returnValue`: Byte = 0.toByte(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Byte = 0.toByte(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructU8(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructU8.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
  @JvmField internal var `returnValue`: Byte = 0.toByte(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Byte = 0.toByte(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructI8(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructI8.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
  @JvmField internal var `returnValue`: Short = 0.toShort(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Short = 0.toShort(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructU16(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructU16.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
  @JvmField internal var `returnValue`: Short = 0.toShort(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Short = 0.toShort(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructI16(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructI16.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
  @JvmField internal var `returnValue`: Int = 0,
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Int = 0,
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructU32(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructU32.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
  @JvmField internal var `returnValue`: Int = 0,
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Int = 0,
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructI32(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructI32.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
  @JvmField internal var `returnValue`: Long = 0.toLong(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Long = 0.toLong(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructU64(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructU64.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
  @JvmField internal var `returnValue`: Long = 0.toLong(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Long = 0.toLong(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructI64(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructI64.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
  @JvmField internal var `returnValue`: Float = 0.0f,
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Float = 0.0f,
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructF32(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructF32.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
  @JvmField internal var `returnValue`: Double = 0.0,
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Double = 0.0,
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructF64(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructF64.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
  @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: Pointer = Pointer.NULL,
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructPointer(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructPointer.UniffiByValue,
  )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
  @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructRustBuffer(`returnValue`, `callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
    `returnValue` = other.`returnValue`
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,
  )
}

@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
  @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
  class UniffiByValue(
    `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
  ) : UniffiForeignFutureStructVoid(`callStatus`),
    Structure.ByValue

  internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
    `callStatus` = other.`callStatus`
  }
}

internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
  fun callback(
    `callbackData`: Long,
    `result`: UniffiForeignFutureStructVoid.UniffiByValue,
  )
}

// For large crates we prevent `MethodTooLargeException` (see #2340)
// N.B. the name of the extension is very misleading, since it is
// rather `InterfaceTooLargeException`, caused by too many methods
// in the interface for large crates.
//
// By splitting the otherwise huge interface into two parts
// * UniffiLib
// * IntegrityCheckingUniffiLib (this)
// we allow for ~2x as many methods in the UniffiLib interface.
//
// The `ffi_uniffi_contract_version` method and all checksum methods are put
// into `IntegrityCheckingUniffiLib` and these methods are called only once,
// when the library is loaded.
internal interface IntegrityCheckingUniffiLib : Library {
  // Integrity check functions only
  fun uniffi_algokit_transact_ffi_checksum_func_address_from_multisig_signature(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_address_from_public_key(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_apply_multisig_subsignature(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_assign_fee(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_calculate_fee(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_decode_signed_transaction(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_decode_signed_transactions(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_decode_transaction(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_decode_transactions(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_encode_signed_transaction(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_encode_signed_transactions(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_encode_transaction(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_encode_transaction_raw(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_encode_transactions(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_estimate_transaction_size(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_get_algorand_constant(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_get_encoded_transaction_type(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_get_transaction_id(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_get_transaction_id_raw(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_group_transactions(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_merge_multisignatures(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_new_multisig_signature(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_participants_from_multisig_signature(): Short

  fun uniffi_algokit_transact_ffi_checksum_func_public_key_from_address(): Short

  fun ffi_algokit_transact_ffi_uniffi_contract_version(): Int
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.
internal interface UniffiLib : Library {
  companion object {
    internal val INSTANCE: UniffiLib by lazy {
      val componentName = "algokit_transact_ffi"
      // For large crates we prevent `MethodTooLargeException` (see #2340)
      // N.B. the name of the extension is very misleading, since it is
      // rather `InterfaceTooLargeException`, caused by too many methods
      // in the interface for large crates.
      //
      // By splitting the otherwise huge interface into two parts
      // * UniffiLib (this)
      // * IntegrityCheckingUniffiLib
      // And all checksum methods are put into `IntegrityCheckingUniffiLib`
      // we allow for ~2x as many methods in the UniffiLib interface.
      //
      // Thus we first load the library with `loadIndirect` as `IntegrityCheckingUniffiLib`
      // so that we can (optionally!) call `uniffiCheckApiChecksums`...
      loadIndirect<IntegrityCheckingUniffiLib>(componentName)
        .also { lib: IntegrityCheckingUniffiLib ->
          uniffiCheckContractApiVersion(lib)
          uniffiCheckApiChecksums(lib)
        }
      // ... and then we load the library as `UniffiLib`
      // N.B. we cannot use `loadIndirect` once and then try to cast it to `UniffiLib`
      // => results in `java.lang.ClassCastException: com.sun.proxy.$Proxy cannot be cast to ...`
      // error. So we must call `loadIndirect` twice. For crates large enough
      // to trigger this issue, the performance impact is negligible, running on
      // a macOS M1 machine the `loadIndirect` call takes ~50ms.
      val lib = loadIndirect<UniffiLib>(componentName)
      // No need to check the contract version and checksums, since
      // we already did that with `IntegrityCheckingUniffiLib` above.
      // Loading of library with integrity check done.
      lib
    }
  }

  // FFI functions
  fun uniffi_algokit_transact_ffi_fn_func_address_from_multisig_signature(
    `multisigSignature`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_address_from_public_key(
    `publicKey`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_apply_multisig_subsignature(
    `multisigSignature`: RustBuffer.ByValue,
    `participant`: RustBuffer.ByValue,
    `subsignature`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_assign_fee(
    `transaction`: RustBuffer.ByValue,
    `feeParams`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_calculate_fee(
    `transaction`: RustBuffer.ByValue,
    `feeParams`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): Long

  fun uniffi_algokit_transact_ffi_fn_func_decode_signed_transaction(
    `encodedSignedTransaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_decode_signed_transactions(
    `encodedSignedTransactions`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_decode_transaction(
    `encodedTx`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_decode_transactions(
    `encodedTxs`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_encode_signed_transaction(
    `signedTransaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_encode_signed_transactions(
    `signedTransactions`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_encode_transaction(
    `transaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_encode_transaction_raw(
    `transaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_encode_transactions(
    `transactions`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_estimate_transaction_size(
    `transaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): Long

  fun uniffi_algokit_transact_ffi_fn_func_get_algorand_constant(
    `constant`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): Long

  fun uniffi_algokit_transact_ffi_fn_func_get_encoded_transaction_type(
    `encodedTransaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_get_transaction_id(
    `transaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_get_transaction_id_raw(
    `transaction`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_group_transactions(
    `transactions`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_merge_multisignatures(
    `multisigSignatureA`: RustBuffer.ByValue,
    `multisigSignatureB`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_new_multisig_signature(
    `version`: Byte,
    `threshold`: Byte,
    `participants`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_participants_from_multisig_signature(
    `multisigSignature`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun uniffi_algokit_transact_ffi_fn_func_public_key_from_address(
    `address`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun ffi_algokit_transact_ffi_rustbuffer_alloc(
    `size`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun ffi_algokit_transact_ffi_rustbuffer_from_bytes(
    `bytes`: ForeignBytes.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun ffi_algokit_transact_ffi_rustbuffer_free(
    `buf`: RustBuffer.ByValue,
    uniffi_out_err: UniffiRustCallStatus,
  ): Unit

  fun ffi_algokit_transact_ffi_rustbuffer_reserve(
    `buf`: RustBuffer.ByValue,
    `additional`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun ffi_algokit_transact_ffi_rust_future_poll_u8(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_u8(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_u8(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_u8(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Byte

  fun ffi_algokit_transact_ffi_rust_future_poll_i8(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_i8(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_i8(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_i8(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Byte

  fun ffi_algokit_transact_ffi_rust_future_poll_u16(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_u16(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_u16(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_u16(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Short

  fun ffi_algokit_transact_ffi_rust_future_poll_i16(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_i16(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_i16(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_i16(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Short

  fun ffi_algokit_transact_ffi_rust_future_poll_u32(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_u32(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_u32(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_u32(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Int

  fun ffi_algokit_transact_ffi_rust_future_poll_i32(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_i32(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_i32(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_i32(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Int

  fun ffi_algokit_transact_ffi_rust_future_poll_u64(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_u64(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_u64(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_u64(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Long

  fun ffi_algokit_transact_ffi_rust_future_poll_i64(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_i64(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_i64(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_i64(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Long

  fun ffi_algokit_transact_ffi_rust_future_poll_f32(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_f32(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_f32(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_f32(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Float

  fun ffi_algokit_transact_ffi_rust_future_poll_f64(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_f64(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_f64(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_f64(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Double

  fun ffi_algokit_transact_ffi_rust_future_poll_pointer(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_pointer(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_pointer(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_pointer(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Pointer

  fun ffi_algokit_transact_ffi_rust_future_poll_rust_buffer(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_rust_buffer(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_rust_buffer(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_rust_buffer(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): RustBuffer.ByValue

  fun ffi_algokit_transact_ffi_rust_future_poll_void(
    `handle`: Long,
    `callback`: UniffiRustFutureContinuationCallback,
    `callbackData`: Long,
  ): Unit

  fun ffi_algokit_transact_ffi_rust_future_cancel_void(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_free_void(`handle`: Long): Unit

  fun ffi_algokit_transact_ffi_rust_future_complete_void(
    `handle`: Long,
    uniffi_out_err: UniffiRustCallStatus,
  ): Unit
}

private fun uniffiCheckContractApiVersion(lib: IntegrityCheckingUniffiLib) {
  // Get the bindings contract version from our ComponentInterface
  val bindings_contract_version = 29
  // Get the scaffolding contract version by calling the into the dylib
  val scaffolding_contract_version = lib.ffi_algokit_transact_ffi_uniffi_contract_version()
  if (bindings_contract_version != scaffolding_contract_version) {
    throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
  }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: IntegrityCheckingUniffiLib) {
  if (lib.uniffi_algokit_transact_ffi_checksum_func_address_from_multisig_signature() != 51026.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_address_from_public_key() != 10716.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_apply_multisig_subsignature() != 42634.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_assign_fee() != 35003.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_calculate_fee() != 7537.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transaction() != 43569.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transactions() != 62888.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_decode_transaction() != 56405.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_decode_transactions() != 26956.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transaction() != 47064.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transactions() != 1956.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction() != 11275.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction_raw() != 384.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_encode_transactions() != 59611.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_estimate_transaction_size() != 60858.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_get_algorand_constant() != 49400.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_get_encoded_transaction_type() != 42551.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id() != 10957.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id_raw() != 48975.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_group_transactions() != 18193.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_merge_multisignatures() != 58688.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_new_multisig_signature() != 29314.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_participants_from_multisig_signature() != 25095.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
  if (lib.uniffi_algokit_transact_ffi_checksum_func_public_key_from_address() != 58152.toShort()) {
    throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
}

/**
 * @suppress
 */
public fun uniffiEnsureInitialized() {
  UniffiLib.INSTANCE
}

// Async support

// Public interface members begin here.

// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
  fun destroy()

  companion object {
    fun destroy(vararg args: Any?) {
      for (arg in args) {
        when (arg) {
          is Disposable -> arg.destroy()
          is ArrayList<*> -> {
            for (idx in arg.indices) {
              val element = arg[idx]
              if (element is Disposable) {
                element.destroy()
              }
            }
          }
          is Map<*, *> -> {
            for (element in arg.values) {
              if (element is Disposable) {
                element.destroy()
              }
            }
          }
          is Iterable<*> -> {
            for (element in arg) {
              if (element is Disposable) {
                element.destroy()
              }
            }
          }
        }
      }
    }
  }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
  try {
    block(this)
  } finally {
    try {
      // N.B. our implementation is on the nullable type `Disposable?`.
      this?.destroy()
    } catch (e: Throwable) {
      // swallow
    }
  }

/**
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer

/**
 * @suppress
 */
public object FfiConverterUByte : FfiConverter<UByte, Byte> {
  override fun lift(value: Byte): UByte = value.toUByte()

  override fun read(buf: ByteBuffer): UByte = lift(buf.get())

  override fun lower(value: UByte): Byte = value.toByte()

  override fun allocationSize(value: UByte) = 1UL

  override fun write(
    value: UByte,
    buf: ByteBuffer,
  ) {
    buf.put(value.toByte())
  }
}

/**
 * @suppress
 */
public object FfiConverterUInt : FfiConverter<UInt, Int> {
  override fun lift(value: Int): UInt = value.toUInt()

  override fun read(buf: ByteBuffer): UInt = lift(buf.getInt())

  override fun lower(value: UInt): Int = value.toInt()

  override fun allocationSize(value: UInt) = 4UL

  override fun write(
    value: UInt,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.toInt())
  }
}

/**
 * @suppress
 */
public object FfiConverterULong : FfiConverter<ULong, Long> {
  override fun lift(value: Long): ULong = value.toULong()

  override fun read(buf: ByteBuffer): ULong = lift(buf.getLong())

  override fun lower(value: ULong): Long = value.toLong()

  override fun allocationSize(value: ULong) = 8UL

  override fun write(
    value: ULong,
    buf: ByteBuffer,
  ) {
    buf.putLong(value.toLong())
  }
}

/**
 * @suppress
 */
public object FfiConverterBoolean : FfiConverter<Boolean, Byte> {
  override fun lift(value: Byte): Boolean = value.toInt() != 0

  override fun read(buf: ByteBuffer): Boolean = lift(buf.get())

  override fun lower(value: Boolean): Byte = if (value) 1.toByte() else 0.toByte()

  override fun allocationSize(value: Boolean) = 1UL

  override fun write(
    value: Boolean,
    buf: ByteBuffer,
  ) {
    buf.put(lower(value))
  }
}

/**
 * @suppress
 */
public object FfiConverterString : FfiConverter<String, RustBuffer.ByValue> {
  // Note: we don't inherit from FfiConverterRustBuffer, because we use a
  // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
  // store our length and avoid writing it out to the buffer.
  override fun lift(value: RustBuffer.ByValue): String {
    try {
      val byteArr = ByteArray(value.len.toInt())
      value.asByteBuffer()!!.get(byteArr)
      return byteArr.toString(Charsets.UTF_8)
    } finally {
      RustBuffer.free(value)
    }
  }

  override fun read(buf: ByteBuffer): String {
    val len = buf.getInt()
    val byteArr = ByteArray(len)
    buf.get(byteArr)
    return byteArr.toString(Charsets.UTF_8)
  }

  fun toUtf8(value: String): ByteBuffer {
    // Make sure we don't have invalid UTF-16, check for lone surrogates.
    return Charsets.UTF_8.newEncoder().run {
      onMalformedInput(CodingErrorAction.REPORT)
      encode(CharBuffer.wrap(value))
    }
  }

  override fun lower(value: String): RustBuffer.ByValue {
    val byteBuf = toUtf8(value)
    // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
    // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
    val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
    rbuf.asByteBuffer()!!.put(byteBuf)
    return rbuf
  }

  // We aren't sure exactly how many bytes our string will be once it's UTF-8
  // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
  // enough.
  override fun allocationSize(value: String): ULong {
    val sizeForLength = 4UL
    val sizeForString = value.length.toULong() * 3UL
    return sizeForLength + sizeForString
  }

  override fun write(
    value: String,
    buf: ByteBuffer,
  ) {
    val byteBuf = toUtf8(value)
    buf.putInt(byteBuf.limit())
    buf.put(byteBuf)
  }
}

/**
 * @suppress
 */
public object FfiConverterByteArray : FfiConverterRustBuffer<ByteArray> {
  override fun read(buf: ByteBuffer): ByteArray {
    val len = buf.getInt()
    val byteArr = ByteArray(len)
    buf.get(byteArr)
    return byteArr
  }

  override fun allocationSize(value: ByteArray): ULong = 4UL + value.size.toULong()

  override fun write(
    value: ByteArray,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    buf.put(value)
  }
}

/**
 * Represents an app call transaction that interacts with Algorand Smart Contracts.
 *
 * App call transactions are used to create, update, delete, opt-in to,
 * close out of, or clear state from Algorand applications (smart contracts).
 */
data class AppCallTransactionFields(
  /**
   * ID of the app being called.
   *
   * Set this to 0 to indicate an app creation call.
   */
  var `appId`: kotlin.ULong,
  /**
   * Defines what additional actions occur with the transaction.
   */
  var `onComplete`: OnApplicationComplete,
  /**
   * Logic executed for every app call transaction, except when
   * on-completion is set to "clear".
   *
   * Approval programs may reject the transaction.
   * Only required for app creation and update transactions.
   */
  var `approvalProgram`: kotlin.ByteArray? = null,
  /**
   * Logic executed for app call transactions with on-completion set to "clear".
   *
   * Clear state programs cannot reject the transaction.
   * Only required for app creation and update transactions.
   */
  var `clearStateProgram`: kotlin.ByteArray? = null,
  /**
   * Holds the maximum number of global state values.
   *
   * Only required for app creation transactions.
   * This cannot be changed after creation.
   */
  var `globalStateSchema`: StateSchema? = null,
  /**
   * Holds the maximum number of local state values.
   *
   * Only required for app creation transactions.
   * This cannot be changed after creation.
   */
  var `localStateSchema`: StateSchema? = null,
  /**
   * Number of additional pages allocated to the app's approval
   * and clear state programs.
   *
   * Each extra program page is 2048 bytes. The sum of approval program
   * and clear state program may not exceed 2048*(1+extra_program_pages) bytes.
   * Currently, the maximum value is 3.
   * This cannot be changed after creation.
   */
  var `extraProgramPages`: kotlin.UInt? = null,
  /**
   * Transaction specific arguments available in the app's
   * approval program and clear state program.
   */
  var `args`: List<kotlin.ByteArray>? = null,
  /**
   * List of accounts in addition to the sender that may be accessed
   * from the app's approval program and clear state program.
   */
  var `accountReferences`: List<kotlin.String>? = null,
  /**
   * List of apps in addition to the current app that may be called
   * from the app's approval program and clear state program.
   */
  var `appReferences`: List<kotlin.ULong>? = null,
  /**
   * Lists the assets whose parameters may be accessed by this app's
   * approval program and clear state program.
   *
   * The access is read-only.
   */
  var `assetReferences`: List<kotlin.ULong>? = null,
  /**
   * The boxes that should be made available for the runtime of the program.
   */
  var `boxReferences`: List<BoxReference>? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAppCallTransactionFields : FfiConverterRustBuffer<AppCallTransactionFields> {
  override fun read(buf: ByteBuffer): AppCallTransactionFields =
    AppCallTransactionFields(
      FfiConverterULong.read(buf),
      FfiConverterTypeOnApplicationComplete.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalTypeStateSchema.read(buf),
      FfiConverterOptionalTypeStateSchema.read(buf),
      FfiConverterOptionalUInt.read(buf),
      FfiConverterOptionalSequenceByteArray.read(buf),
      FfiConverterOptionalSequenceString.read(buf),
      FfiConverterOptionalSequenceULong.read(buf),
      FfiConverterOptionalSequenceULong.read(buf),
      FfiConverterOptionalSequenceTypeBoxReference.read(buf),
    )

  override fun allocationSize(value: AppCallTransactionFields) =
    (
      FfiConverterULong.allocationSize(value.`appId`) +
        FfiConverterTypeOnApplicationComplete.allocationSize(value.`onComplete`) +
        FfiConverterOptionalByteArray.allocationSize(value.`approvalProgram`) +
        FfiConverterOptionalByteArray.allocationSize(value.`clearStateProgram`) +
        FfiConverterOptionalTypeStateSchema.allocationSize(value.`globalStateSchema`) +
        FfiConverterOptionalTypeStateSchema.allocationSize(value.`localStateSchema`) +
        FfiConverterOptionalUInt.allocationSize(value.`extraProgramPages`) +
        FfiConverterOptionalSequenceByteArray.allocationSize(value.`args`) +
        FfiConverterOptionalSequenceString.allocationSize(value.`accountReferences`) +
        FfiConverterOptionalSequenceULong.allocationSize(value.`appReferences`) +
        FfiConverterOptionalSequenceULong.allocationSize(value.`assetReferences`) +
        FfiConverterOptionalSequenceTypeBoxReference.allocationSize(value.`boxReferences`)
    )

  override fun write(
    value: AppCallTransactionFields,
    buf: ByteBuffer,
  ) {
    FfiConverterULong.write(value.`appId`, buf)
    FfiConverterTypeOnApplicationComplete.write(value.`onComplete`, buf)
    FfiConverterOptionalByteArray.write(value.`approvalProgram`, buf)
    FfiConverterOptionalByteArray.write(value.`clearStateProgram`, buf)
    FfiConverterOptionalTypeStateSchema.write(value.`globalStateSchema`, buf)
    FfiConverterOptionalTypeStateSchema.write(value.`localStateSchema`, buf)
    FfiConverterOptionalUInt.write(value.`extraProgramPages`, buf)
    FfiConverterOptionalSequenceByteArray.write(value.`args`, buf)
    FfiConverterOptionalSequenceString.write(value.`accountReferences`, buf)
    FfiConverterOptionalSequenceULong.write(value.`appReferences`, buf)
    FfiConverterOptionalSequenceULong.write(value.`assetReferences`, buf)
    FfiConverterOptionalSequenceTypeBoxReference.write(value.`boxReferences`, buf)
  }
}

/**
 * Parameters to define an asset config transaction.
 *
 * For asset creation, the asset ID field must be 0.
 * For asset reconfiguration, the asset ID field must be set. Only fields manager, reserve, freeze, and clawback can be set.
 * For asset destroy, the asset ID field must be set, all other fields must not be set.
 *
 * **Note:** The manager, reserve, freeze, and clawback addresses
 * are immutably empty if they are not set. If manager is not set then
 * all fields are immutable from that point forward.
 */
data class AssetConfigTransactionFields(
  /**
   * ID of the asset to operate on.
   *
   * For asset creation, this must be 0.
   * For asset reconfiguration this is the ID of the existing asset to be reconfigured,
   * For asset destroy this is the ID of the existing asset to be destroyed.
   */
  var `assetId`: kotlin.ULong,
  /**
   * The total amount of the smallest divisible (decimal) unit to create.
   *
   * Required when creating a new asset.
   * For example, if creating a asset with 2 decimals and wanting a total supply of 100 units, this value should be 10000.
   *
   * This field can only be specified upon asset creation.
   */
  var `total`: kotlin.ULong? = null,
  /**
   * The amount of decimal places the asset should have.
   *
   * If unspecified then the asset will be in whole units (i.e. `0`).
   * * If 0, the asset is not divisible;
   * * If 1, the base unit of the asset is in tenths;
   * * If 2, the base unit of the asset is in hundredths;
   * * If 3, the base unit of the asset is in thousandths;
   *
   * and so on up to 19 decimal places.
   *
   * This field can only be specified upon asset creation.
   */
  var `decimals`: kotlin.UInt? = null,
  /**
   * Whether the asset is frozen by default for all accounts.
   * Defaults to `false`.
   *
   * If `true` then for anyone apart from the creator to hold the
   * asset it needs to be unfrozen per account using an asset freeze
   * transaction from the `freeze` account, which must be set on creation.
   *
   * This field can only be specified upon asset creation.
   */
  var `defaultFrozen`: kotlin.Boolean? = null,
  /**
   * The optional name of the asset.
   *
   * Max size is 32 bytes.
   *
   * This field can only be specified upon asset creation.
   */
  var `assetName`: kotlin.String? = null,
  /**
   * The optional name of the unit of this asset (e.g. ticker name).
   *
   * Max size is 8 bytes.
   *
   * This field can only be specified upon asset creation.
   */
  var `unitName`: kotlin.String? = null,
  /**
   * Specifies an optional URL where more information about the asset can be retrieved (e.g. metadata).
   *
   * Max size is 96 bytes.
   *
   * This field can only be specified upon asset creation.
   */
  var `url`: kotlin.String? = null,
  /**
   * 32-byte hash of some metadata that is relevant to your asset and/or asset holders.
   *
   * The format of this metadata is up to the application.
   *
   * This field can only be specified upon asset creation.
   */
  var `metadataHash`: kotlin.ByteArray? = null,
  /**
   * The address of the optional account that can manage the configuration of the asset and destroy it.
   *
   * The fields it can change are `manager`, `reserve`, `clawback`, and `freeze`.
   *
   * If not set or set to the Zero address the asset becomes permanently immutable.
   */
  var `manager`: kotlin.String? = null,
  /**
   * The address of the optional account that holds the reserve (uncirculated supply) units of the asset.
   *
   * This address has no specific authority in the protocol itself and is informational only.
   *
   * Some standards like [ARC-19](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0019.md)
   * rely on this field to hold meaningful data.
   *
   * It can be used in the case where you want to signal to holders of your asset that the uncirculated units
   * of the asset reside in an account that is different from the default creator account.
   *
   * If not set or set to the Zero address is permanently empty.
   */
  var `reserve`: kotlin.String? = null,
  /**
   * The address of the optional account that can be used to freeze or unfreeze holdings of this asset for any account.
   *
   * If empty, freezing is not permitted.
   *
   * If not set or set to the Zero address is permanently empty.
   */
  var `freeze`: kotlin.String? = null,
  /**
   * The address of the optional account that can clawback holdings of this asset from any account.
   *
   * **This field should be used with caution** as the clawback account has the ability to **unconditionally take assets from any account**.
   *
   * If empty, clawback is not permitted.
   *
   * If not set or set to the Zero address is permanently empty.
   */
  var `clawback`: kotlin.String? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetConfigTransactionFields : FfiConverterRustBuffer<AssetConfigTransactionFields> {
  override fun read(buf: ByteBuffer): AssetConfigTransactionFields =
    AssetConfigTransactionFields(
      FfiConverterULong.read(buf),
      FfiConverterOptionalULong.read(buf),
      FfiConverterOptionalUInt.read(buf),
      FfiConverterOptionalBoolean.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalString.read(buf),
    )

  override fun allocationSize(value: AssetConfigTransactionFields) =
    (
      FfiConverterULong.allocationSize(value.`assetId`) +
        FfiConverterOptionalULong.allocationSize(value.`total`) +
        FfiConverterOptionalUInt.allocationSize(value.`decimals`) +
        FfiConverterOptionalBoolean.allocationSize(value.`defaultFrozen`) +
        FfiConverterOptionalString.allocationSize(value.`assetName`) +
        FfiConverterOptionalString.allocationSize(value.`unitName`) +
        FfiConverterOptionalString.allocationSize(value.`url`) +
        FfiConverterOptionalByteArray.allocationSize(value.`metadataHash`) +
        FfiConverterOptionalString.allocationSize(value.`manager`) +
        FfiConverterOptionalString.allocationSize(value.`reserve`) +
        FfiConverterOptionalString.allocationSize(value.`freeze`) +
        FfiConverterOptionalString.allocationSize(value.`clawback`)
    )

  override fun write(
    value: AssetConfigTransactionFields,
    buf: ByteBuffer,
  ) {
    FfiConverterULong.write(value.`assetId`, buf)
    FfiConverterOptionalULong.write(value.`total`, buf)
    FfiConverterOptionalUInt.write(value.`decimals`, buf)
    FfiConverterOptionalBoolean.write(value.`defaultFrozen`, buf)
    FfiConverterOptionalString.write(value.`assetName`, buf)
    FfiConverterOptionalString.write(value.`unitName`, buf)
    FfiConverterOptionalString.write(value.`url`, buf)
    FfiConverterOptionalByteArray.write(value.`metadataHash`, buf)
    FfiConverterOptionalString.write(value.`manager`, buf)
    FfiConverterOptionalString.write(value.`reserve`, buf)
    FfiConverterOptionalString.write(value.`freeze`, buf)
    FfiConverterOptionalString.write(value.`clawback`, buf)
  }
}

/**
 * Represents an asset freeze transaction that freezes or unfreezes asset holdings.
 *
 * Asset freeze transactions are used by the asset freeze account to control
 * whether a specific account can transfer a particular asset.
 */
data class AssetFreezeTransactionFields(
  /**
   * The ID of the asset being frozen/unfrozen.
   */
  var `assetId`: kotlin.ULong,
  /**
   * The target account whose asset holdings will be affected.
   */
  var `freezeTarget`: kotlin.String,
  /**
   * The new freeze status.
   *
   * `true` to freeze the asset holdings (prevent transfers),
   * `false` to unfreeze the asset holdings (allow transfers).
   */
  var `frozen`: kotlin.Boolean,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetFreezeTransactionFields : FfiConverterRustBuffer<AssetFreezeTransactionFields> {
  override fun read(buf: ByteBuffer): AssetFreezeTransactionFields =
    AssetFreezeTransactionFields(
      FfiConverterULong.read(buf),
      FfiConverterString.read(buf),
      FfiConverterBoolean.read(buf),
    )

  override fun allocationSize(value: AssetFreezeTransactionFields) =
    (
      FfiConverterULong.allocationSize(value.`assetId`) +
        FfiConverterString.allocationSize(value.`freezeTarget`) +
        FfiConverterBoolean.allocationSize(value.`frozen`)
    )

  override fun write(
    value: AssetFreezeTransactionFields,
    buf: ByteBuffer,
  ) {
    FfiConverterULong.write(value.`assetId`, buf)
    FfiConverterString.write(value.`freezeTarget`, buf)
    FfiConverterBoolean.write(value.`frozen`, buf)
  }
}

data class AssetTransferTransactionFields(
  var `assetId`: kotlin.ULong,
  var `amount`: kotlin.ULong,
  var `receiver`: kotlin.String,
  var `assetSender`: kotlin.String? = null,
  var `closeRemainderTo`: kotlin.String? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAssetTransferTransactionFields : FfiConverterRustBuffer<AssetTransferTransactionFields> {
  override fun read(buf: ByteBuffer): AssetTransferTransactionFields =
    AssetTransferTransactionFields(
      FfiConverterULong.read(buf),
      FfiConverterULong.read(buf),
      FfiConverterString.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalString.read(buf),
    )

  override fun allocationSize(value: AssetTransferTransactionFields) =
    (
      FfiConverterULong.allocationSize(value.`assetId`) +
        FfiConverterULong.allocationSize(value.`amount`) +
        FfiConverterString.allocationSize(value.`receiver`) +
        FfiConverterOptionalString.allocationSize(value.`assetSender`) +
        FfiConverterOptionalString.allocationSize(value.`closeRemainderTo`)
    )

  override fun write(
    value: AssetTransferTransactionFields,
    buf: ByteBuffer,
  ) {
    FfiConverterULong.write(value.`assetId`, buf)
    FfiConverterULong.write(value.`amount`, buf)
    FfiConverterString.write(value.`receiver`, buf)
    FfiConverterOptionalString.write(value.`assetSender`, buf)
    FfiConverterOptionalString.write(value.`closeRemainderTo`, buf)
  }
}

/**
 * Box reference for app call transactions.
 *
 * References a specific box that should be made available for the runtime
 * of the program.
 */
data class BoxReference(
  /**
   * App ID that owns the box.
   * A value of 0 indicates the current app.
   */
  var `appId`: kotlin.ULong,
  /**
   * Name of the box.
   */
  var `name`: kotlin.ByteArray,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeBoxReference : FfiConverterRustBuffer<BoxReference> {
  override fun read(buf: ByteBuffer): BoxReference =
    BoxReference(
      FfiConverterULong.read(buf),
      FfiConverterByteArray.read(buf),
    )

  override fun allocationSize(value: BoxReference) =
    (
      FfiConverterULong.allocationSize(value.`appId`) +
        FfiConverterByteArray.allocationSize(value.`name`)
    )

  override fun write(
    value: BoxReference,
    buf: ByteBuffer,
  ) {
    FfiConverterULong.write(value.`appId`, buf)
    FfiConverterByteArray.write(value.`name`, buf)
  }
}

data class FeeParams(
  var `feePerByte`: kotlin.ULong,
  var `minFee`: kotlin.ULong,
  var `extraFee`: kotlin.ULong? = null,
  var `maxFee`: kotlin.ULong? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFeeParams : FfiConverterRustBuffer<FeeParams> {
  override fun read(buf: ByteBuffer): FeeParams =
    FeeParams(
      FfiConverterULong.read(buf),
      FfiConverterULong.read(buf),
      FfiConverterOptionalULong.read(buf),
      FfiConverterOptionalULong.read(buf),
    )

  override fun allocationSize(value: FeeParams) =
    (
      FfiConverterULong.allocationSize(value.`feePerByte`) +
        FfiConverterULong.allocationSize(value.`minFee`) +
        FfiConverterOptionalULong.allocationSize(value.`extraFee`) +
        FfiConverterOptionalULong.allocationSize(value.`maxFee`)
    )

  override fun write(
    value: FeeParams,
    buf: ByteBuffer,
  ) {
    FfiConverterULong.write(value.`feePerByte`, buf)
    FfiConverterULong.write(value.`minFee`, buf)
    FfiConverterOptionalULong.write(value.`extraFee`, buf)
    FfiConverterOptionalULong.write(value.`maxFee`, buf)
  }
}

data class KeyPairAccount(
  var `pubKey`: kotlin.ByteArray,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeKeyPairAccount : FfiConverterRustBuffer<KeyPairAccount> {
  override fun read(buf: ByteBuffer): KeyPairAccount =
    KeyPairAccount(
      FfiConverterByteArray.read(buf),
    )

  override fun allocationSize(value: KeyPairAccount) =
    (
      FfiConverterByteArray.allocationSize(value.`pubKey`)
    )

  override fun write(
    value: KeyPairAccount,
    buf: ByteBuffer,
  ) {
    FfiConverterByteArray.write(value.`pubKey`, buf)
  }
}

data class KeyRegistrationTransactionFields(
  /**
   * Root participation public key (32 bytes)
   */
  var `voteKey`: kotlin.ByteArray? = null,
  /**
   * VRF public key (32 bytes)
   */
  var `selectionKey`: kotlin.ByteArray? = null,
  /**
   * State proof key (64 bytes)
   */
  var `stateProofKey`: kotlin.ByteArray? = null,
  /**
   * First round for which the participation key is valid
   */
  var `voteFirst`: kotlin.ULong? = null,
  /**
   * Last round for which the participation key is valid
   */
  var `voteLast`: kotlin.ULong? = null,
  /**
   * Key dilution for the 2-level participation key
   */
  var `voteKeyDilution`: kotlin.ULong? = null,
  /**
   * Mark account as non-reward earning
   */
  var `nonParticipation`: kotlin.Boolean? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeKeyRegistrationTransactionFields : FfiConverterRustBuffer<KeyRegistrationTransactionFields> {
  override fun read(buf: ByteBuffer): KeyRegistrationTransactionFields =
    KeyRegistrationTransactionFields(
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalULong.read(buf),
      FfiConverterOptionalULong.read(buf),
      FfiConverterOptionalULong.read(buf),
      FfiConverterOptionalBoolean.read(buf),
    )

  override fun allocationSize(value: KeyRegistrationTransactionFields) =
    (
      FfiConverterOptionalByteArray.allocationSize(value.`voteKey`) +
        FfiConverterOptionalByteArray.allocationSize(value.`selectionKey`) +
        FfiConverterOptionalByteArray.allocationSize(value.`stateProofKey`) +
        FfiConverterOptionalULong.allocationSize(value.`voteFirst`) +
        FfiConverterOptionalULong.allocationSize(value.`voteLast`) +
        FfiConverterOptionalULong.allocationSize(value.`voteKeyDilution`) +
        FfiConverterOptionalBoolean.allocationSize(value.`nonParticipation`)
    )

  override fun write(
    value: KeyRegistrationTransactionFields,
    buf: ByteBuffer,
  ) {
    FfiConverterOptionalByteArray.write(value.`voteKey`, buf)
    FfiConverterOptionalByteArray.write(value.`selectionKey`, buf)
    FfiConverterOptionalByteArray.write(value.`stateProofKey`, buf)
    FfiConverterOptionalULong.write(value.`voteFirst`, buf)
    FfiConverterOptionalULong.write(value.`voteLast`, buf)
    FfiConverterOptionalULong.write(value.`voteKeyDilution`, buf)
    FfiConverterOptionalBoolean.write(value.`nonParticipation`, buf)
  }
}

/**
 * Representation of an Algorand multisignature signature.
 */
data class MultisigSignature(
  /**
   * Multisig version.
   */
  var `version`: kotlin.UByte,
  /**
   * Minimum number of signatures required.
   */
  var `threshold`: kotlin.UByte,
  /**
   * List of subsignatures for each participant.
   */
  var `subsignatures`: List<MultisigSubsignature>,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMultisigSignature : FfiConverterRustBuffer<MultisigSignature> {
  override fun read(buf: ByteBuffer): MultisigSignature =
    MultisigSignature(
      FfiConverterUByte.read(buf),
      FfiConverterUByte.read(buf),
      FfiConverterSequenceTypeMultisigSubsignature.read(buf),
    )

  override fun allocationSize(value: MultisigSignature) =
    (
      FfiConverterUByte.allocationSize(value.`version`) +
        FfiConverterUByte.allocationSize(value.`threshold`) +
        FfiConverterSequenceTypeMultisigSubsignature.allocationSize(value.`subsignatures`)
    )

  override fun write(
    value: MultisigSignature,
    buf: ByteBuffer,
  ) {
    FfiConverterUByte.write(value.`version`, buf)
    FfiConverterUByte.write(value.`threshold`, buf)
    FfiConverterSequenceTypeMultisigSubsignature.write(value.`subsignatures`, buf)
  }
}

/**
 * Representation of a single subsignature in a multisignature transaction.
 *
 * Each subsignature contains the participant's address and an optional signature.
 */
data class MultisigSubsignature(
  /**
   * Address of the participant.
   */
  var `address`: kotlin.String,
  /**
   * Optional signature bytes for the participant.
   */
  var `signature`: kotlin.ByteArray? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMultisigSubsignature : FfiConverterRustBuffer<MultisigSubsignature> {
  override fun read(buf: ByteBuffer): MultisigSubsignature =
    MultisigSubsignature(
      FfiConverterString.read(buf),
      FfiConverterOptionalByteArray.read(buf),
    )

  override fun allocationSize(value: MultisigSubsignature) =
    (
      FfiConverterString.allocationSize(value.`address`) +
        FfiConverterOptionalByteArray.allocationSize(value.`signature`)
    )

  override fun write(
    value: MultisigSubsignature,
    buf: ByteBuffer,
  ) {
    FfiConverterString.write(value.`address`, buf)
    FfiConverterOptionalByteArray.write(value.`signature`, buf)
  }
}

data class PaymentTransactionFields(
  var `receiver`: kotlin.String,
  var `amount`: kotlin.ULong,
  var `closeRemainderTo`: kotlin.String? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePaymentTransactionFields : FfiConverterRustBuffer<PaymentTransactionFields> {
  override fun read(buf: ByteBuffer): PaymentTransactionFields =
    PaymentTransactionFields(
      FfiConverterString.read(buf),
      FfiConverterULong.read(buf),
      FfiConverterOptionalString.read(buf),
    )

  override fun allocationSize(value: PaymentTransactionFields) =
    (
      FfiConverterString.allocationSize(value.`receiver`) +
        FfiConverterULong.allocationSize(value.`amount`) +
        FfiConverterOptionalString.allocationSize(value.`closeRemainderTo`)
    )

  override fun write(
    value: PaymentTransactionFields,
    buf: ByteBuffer,
  ) {
    FfiConverterString.write(value.`receiver`, buf)
    FfiConverterULong.write(value.`amount`, buf)
    FfiConverterOptionalString.write(value.`closeRemainderTo`, buf)
  }
}

data class SignedTransaction(
  /**
   * The transaction that has been signed.
   */
  var `transaction`: Transaction,
  /**
   * Optional Ed25519 signature authorizing the transaction.
   */
  var `signature`: kotlin.ByteArray? = null,
  /**
   * Optional auth address applicable if the transaction sender is a rekeyed account.
   */
  var `authAddress`: kotlin.String? = null,
  /**
   * Optional multisig signature if the transaction is a multisig transaction.
   */
  var `multisignature`: MultisigSignature? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSignedTransaction : FfiConverterRustBuffer<SignedTransaction> {
  override fun read(buf: ByteBuffer): SignedTransaction =
    SignedTransaction(
      FfiConverterTypeTransaction.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalTypeMultisigSignature.read(buf),
    )

  override fun allocationSize(value: SignedTransaction) =
    (
      FfiConverterTypeTransaction.allocationSize(value.`transaction`) +
        FfiConverterOptionalByteArray.allocationSize(value.`signature`) +
        FfiConverterOptionalString.allocationSize(value.`authAddress`) +
        FfiConverterOptionalTypeMultisigSignature.allocationSize(value.`multisignature`)
    )

  override fun write(
    value: SignedTransaction,
    buf: ByteBuffer,
  ) {
    FfiConverterTypeTransaction.write(value.`transaction`, buf)
    FfiConverterOptionalByteArray.write(value.`signature`, buf)
    FfiConverterOptionalString.write(value.`authAddress`, buf)
    FfiConverterOptionalTypeMultisigSignature.write(value.`multisignature`, buf)
  }
}

/**
 * Schema for app state storage.
 *
 * Defines the maximum number of values that may be stored in app
 * key/value storage for both global and local state.
 */
data class StateSchema(
  /**
   * Maximum number of integer values that may be stored.
   */
  var `numUints`: kotlin.UInt,
  /**
   * Maximum number of byte slice values that may be stored.
   */
  var `numByteSlices`: kotlin.UInt,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeStateSchema : FfiConverterRustBuffer<StateSchema> {
  override fun read(buf: ByteBuffer): StateSchema =
    StateSchema(
      FfiConverterUInt.read(buf),
      FfiConverterUInt.read(buf),
    )

  override fun allocationSize(value: StateSchema) =
    (
      FfiConverterUInt.allocationSize(value.`numUints`) +
        FfiConverterUInt.allocationSize(value.`numByteSlices`)
    )

  override fun write(
    value: StateSchema,
    buf: ByteBuffer,
  ) {
    FfiConverterUInt.write(value.`numUints`, buf)
    FfiConverterUInt.write(value.`numByteSlices`, buf)
  }
}

data class Transaction(
  /**
   * The type of transaction
   */
  var `transactionType`: TransactionType,
  /**
   * The sender of the transaction
   */
  var `sender`: kotlin.String,
  /**
   * Optional transaction fee in microALGO.
   *
   * If not set, the fee will be interpreted as 0 by the network.
   */
  var `fee`: kotlin.ULong? = null,
  var `firstValid`: kotlin.ULong,
  var `lastValid`: kotlin.ULong,
  var `genesisHash`: kotlin.ByteArray?,
  var `genesisId`: kotlin.String?,
  var `note`: kotlin.ByteArray? = null,
  var `rekeyTo`: kotlin.String? = null,
  var `lease`: kotlin.ByteArray? = null,
  var `group`: kotlin.ByteArray? = null,
  var `payment`: PaymentTransactionFields? = null,
  var `assetTransfer`: AssetTransferTransactionFields? = null,
  var `assetConfig`: AssetConfigTransactionFields? = null,
  var `appCall`: AppCallTransactionFields? = null,
  var `keyRegistration`: KeyRegistrationTransactionFields? = null,
  var `assetFreeze`: AssetFreezeTransactionFields? = null,
) {
  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransaction : FfiConverterRustBuffer<Transaction> {
  override fun read(buf: ByteBuffer): Transaction =
    Transaction(
      FfiConverterTypeTransactionType.read(buf),
      FfiConverterString.read(buf),
      FfiConverterOptionalULong.read(buf),
      FfiConverterULong.read(buf),
      FfiConverterULong.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalString.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalByteArray.read(buf),
      FfiConverterOptionalTypePaymentTransactionFields.read(buf),
      FfiConverterOptionalTypeAssetTransferTransactionFields.read(buf),
      FfiConverterOptionalTypeAssetConfigTransactionFields.read(buf),
      FfiConverterOptionalTypeAppCallTransactionFields.read(buf),
      FfiConverterOptionalTypeKeyRegistrationTransactionFields.read(buf),
      FfiConverterOptionalTypeAssetFreezeTransactionFields.read(buf),
    )

  override fun allocationSize(value: Transaction) =
    (
      FfiConverterTypeTransactionType.allocationSize(value.`transactionType`) +
        FfiConverterString.allocationSize(value.`sender`) +
        FfiConverterOptionalULong.allocationSize(value.`fee`) +
        FfiConverterULong.allocationSize(value.`firstValid`) +
        FfiConverterULong.allocationSize(value.`lastValid`) +
        FfiConverterOptionalByteArray.allocationSize(value.`genesisHash`) +
        FfiConverterOptionalString.allocationSize(value.`genesisId`) +
        FfiConverterOptionalByteArray.allocationSize(value.`note`) +
        FfiConverterOptionalString.allocationSize(value.`rekeyTo`) +
        FfiConverterOptionalByteArray.allocationSize(value.`lease`) +
        FfiConverterOptionalByteArray.allocationSize(value.`group`) +
        FfiConverterOptionalTypePaymentTransactionFields.allocationSize(value.`payment`) +
        FfiConverterOptionalTypeAssetTransferTransactionFields.allocationSize(value.`assetTransfer`) +
        FfiConverterOptionalTypeAssetConfigTransactionFields.allocationSize(value.`assetConfig`) +
        FfiConverterOptionalTypeAppCallTransactionFields.allocationSize(value.`appCall`) +
        FfiConverterOptionalTypeKeyRegistrationTransactionFields.allocationSize(value.`keyRegistration`) +
        FfiConverterOptionalTypeAssetFreezeTransactionFields.allocationSize(value.`assetFreeze`)
    )

  override fun write(
    value: Transaction,
    buf: ByteBuffer,
  ) {
    FfiConverterTypeTransactionType.write(value.`transactionType`, buf)
    FfiConverterString.write(value.`sender`, buf)
    FfiConverterOptionalULong.write(value.`fee`, buf)
    FfiConverterULong.write(value.`firstValid`, buf)
    FfiConverterULong.write(value.`lastValid`, buf)
    FfiConverterOptionalByteArray.write(value.`genesisHash`, buf)
    FfiConverterOptionalString.write(value.`genesisId`, buf)
    FfiConverterOptionalByteArray.write(value.`note`, buf)
    FfiConverterOptionalString.write(value.`rekeyTo`, buf)
    FfiConverterOptionalByteArray.write(value.`lease`, buf)
    FfiConverterOptionalByteArray.write(value.`group`, buf)
    FfiConverterOptionalTypePaymentTransactionFields.write(value.`payment`, buf)
    FfiConverterOptionalTypeAssetTransferTransactionFields.write(value.`assetTransfer`, buf)
    FfiConverterOptionalTypeAssetConfigTransactionFields.write(value.`assetConfig`, buf)
    FfiConverterOptionalTypeAppCallTransactionFields.write(value.`appCall`, buf)
    FfiConverterOptionalTypeKeyRegistrationTransactionFields.write(value.`keyRegistration`, buf)
    FfiConverterOptionalTypeAssetFreezeTransactionFields.write(value.`assetFreeze`, buf)
  }
}

sealed class AlgoKitTransactException : kotlin.Exception() {
  class EncodingException(
    val `errorMsg`: kotlin.String,
  ) : AlgoKitTransactException() {
    override val message
      get() = "errorMsg=${ `errorMsg` }"
  }

  class DecodingException(
    val `errorMsg`: kotlin.String,
  ) : AlgoKitTransactException() {
    override val message
      get() = "errorMsg=${ `errorMsg` }"
  }

  class InputException(
    val `errorMsg`: kotlin.String,
  ) : AlgoKitTransactException() {
    override val message
      get() = "errorMsg=${ `errorMsg` }"
  }

  class MsgPackException(
    val `errorMsg`: kotlin.String,
  ) : AlgoKitTransactException() {
    override val message
      get() = "errorMsg=${ `errorMsg` }"
  }

  companion object ErrorHandler : UniffiRustCallStatusErrorHandler<AlgoKitTransactException> {
    override fun lift(error_buf: RustBuffer.ByValue): AlgoKitTransactException = FfiConverterTypeAlgoKitTransactError.lift(error_buf)
  }
}

/**
 * @suppress
 */
public object FfiConverterTypeAlgoKitTransactError : FfiConverterRustBuffer<AlgoKitTransactException> {
  override fun read(buf: ByteBuffer): AlgoKitTransactException =
    when (buf.getInt()) {
      1 ->
        AlgoKitTransactException.EncodingException(
          FfiConverterString.read(buf),
        )
      2 ->
        AlgoKitTransactException.DecodingException(
          FfiConverterString.read(buf),
        )
      3 ->
        AlgoKitTransactException.InputException(
          FfiConverterString.read(buf),
        )
      4 ->
        AlgoKitTransactException.MsgPackException(
          FfiConverterString.read(buf),
        )
      else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
    }

  override fun allocationSize(value: AlgoKitTransactException): ULong =
    when (value) {
      is AlgoKitTransactException.EncodingException -> (
        // Add the size for the Int that specifies the variant plus the size needed for all fields
        4UL +
          FfiConverterString.allocationSize(value.`errorMsg`)
      )
      is AlgoKitTransactException.DecodingException -> (
        // Add the size for the Int that specifies the variant plus the size needed for all fields
        4UL +
          FfiConverterString.allocationSize(value.`errorMsg`)
      )
      is AlgoKitTransactException.InputException -> (
        // Add the size for the Int that specifies the variant plus the size needed for all fields
        4UL +
          FfiConverterString.allocationSize(value.`errorMsg`)
      )
      is AlgoKitTransactException.MsgPackException -> (
        // Add the size for the Int that specifies the variant plus the size needed for all fields
        4UL +
          FfiConverterString.allocationSize(value.`errorMsg`)
      )
    }

  override fun write(
    value: AlgoKitTransactException,
    buf: ByteBuffer,
  ) {
    when (value) {
      is AlgoKitTransactException.EncodingException -> {
        buf.putInt(1)
        FfiConverterString.write(value.`errorMsg`, buf)
        Unit
      }
      is AlgoKitTransactException.DecodingException -> {
        buf.putInt(2)
        FfiConverterString.write(value.`errorMsg`, buf)
        Unit
      }
      is AlgoKitTransactException.InputException -> {
        buf.putInt(3)
        FfiConverterString.write(value.`errorMsg`, buf)
        Unit
      }
      is AlgoKitTransactException.MsgPackException -> {
        buf.putInt(4)
        FfiConverterString.write(value.`errorMsg`, buf)
        Unit
      }
    }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
  }
}

/**
 * Enum containing all constants used in this crate.
 */

enum class AlgorandConstant {
  /**
   * Length of hash digests (32)
   */
  HASH_LENGTH,

  /**
   * Length of the checksum used in Algorand addresses (4)
   */
  CHECKSUM_LENGTH,

  /**
   * Length of a base32-encoded Algorand address (58)
   */
  ADDRESS_LENGTH,

  /**
   * Length of an Algorand public key in bytes (32)
   */
  PUBLIC_KEY_LENGTH,

  /**
   * Length of an Algorand secret key in bytes (32)
   */
  SECRET_KEY_LENGTH,

  /**
   * Length of an Algorand signature in bytes (64)
   */
  SIGNATURE_LENGTH,

  /**
   * Increment in the encoded byte size when a signature is attached to a transaction (75)
   */
  SIGNATURE_ENCODING_INCR_LENGTH,

  /**
   * The maximum number of transactions in a group (16)
   */
  MAX_TX_GROUP_SIZE,

  ;

  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeAlgorandConstant : FfiConverterRustBuffer<AlgorandConstant> {
  override fun read(buf: ByteBuffer) =
    try {
      AlgorandConstant.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
      throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

  override fun allocationSize(value: AlgorandConstant) = 4UL

  override fun write(
    value: AlgorandConstant,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.ordinal + 1)
  }
}

/**
 * On-completion actions for app transactions.
 *
 * These values define what additional actions occur with the transaction.
 */

enum class OnApplicationComplete {
  /**
   * NoOp indicates that an app transaction will simply call its
   * approval program without any additional action.
   */
  NO_OP,

  /**
   * OptIn indicates that an app transaction will allocate some
   * local state for the app in the sender's account.
   */
  OPT_IN,

  /**
   * CloseOut indicates that an app transaction will deallocate
   * some local state for the app from the user's account.
   */
  CLOSE_OUT,

  /**
   * ClearState is similar to CloseOut, but may never fail. This
   * allows users to reclaim their minimum balance from an app
   * they no longer wish to opt in to.
   */
  CLEAR_STATE,

  /**
   * UpdateApplication indicates that an app transaction will
   * update the approval program and clear state program for the app.
   */
  UPDATE_APPLICATION,

  /**
   * DeleteApplication indicates that an app transaction will
   * delete the app parameters for the app from the creator's
   * balance record.
   */
  DELETE_APPLICATION,

  ;

  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeOnApplicationComplete : FfiConverterRustBuffer<OnApplicationComplete> {
  override fun read(buf: ByteBuffer) =
    try {
      OnApplicationComplete.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
      throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

  override fun allocationSize(value: OnApplicationComplete) = 4UL

  override fun write(
    value: OnApplicationComplete,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.ordinal + 1)
  }
}

enum class TransactionType {
  PAYMENT,
  ASSET_TRANSFER,
  ASSET_FREEZE,
  ASSET_CONFIG,
  KEY_REGISTRATION,
  APP_CALL,
  ;

  companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTransactionType : FfiConverterRustBuffer<TransactionType> {
  override fun read(buf: ByteBuffer) =
    try {
      TransactionType.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
      throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

  override fun allocationSize(value: TransactionType) = 4UL

  override fun write(
    value: TransactionType,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.ordinal + 1)
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalUInt : FfiConverterRustBuffer<kotlin.UInt?> {
  override fun read(buf: ByteBuffer): kotlin.UInt? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterUInt.read(buf)
  }

  override fun allocationSize(value: kotlin.UInt?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterUInt.allocationSize(value)
    }
  }

  override fun write(
    value: kotlin.UInt?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterUInt.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalULong : FfiConverterRustBuffer<kotlin.ULong?> {
  override fun read(buf: ByteBuffer): kotlin.ULong? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterULong.read(buf)
  }

  override fun allocationSize(value: kotlin.ULong?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterULong.allocationSize(value)
    }
  }

  override fun write(
    value: kotlin.ULong?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterULong.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalBoolean : FfiConverterRustBuffer<kotlin.Boolean?> {
  override fun read(buf: ByteBuffer): kotlin.Boolean? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterBoolean.read(buf)
  }

  override fun allocationSize(value: kotlin.Boolean?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterBoolean.allocationSize(value)
    }
  }

  override fun write(
    value: kotlin.Boolean?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterBoolean.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalString : FfiConverterRustBuffer<kotlin.String?> {
  override fun read(buf: ByteBuffer): kotlin.String? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterString.read(buf)
  }

  override fun allocationSize(value: kotlin.String?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterString.allocationSize(value)
    }
  }

  override fun write(
    value: kotlin.String?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterString.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalByteArray : FfiConverterRustBuffer<kotlin.ByteArray?> {
  override fun read(buf: ByteBuffer): kotlin.ByteArray? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterByteArray.read(buf)
  }

  override fun allocationSize(value: kotlin.ByteArray?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterByteArray.allocationSize(value)
    }
  }

  override fun write(
    value: kotlin.ByteArray?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterByteArray.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeAppCallTransactionFields : FfiConverterRustBuffer<AppCallTransactionFields?> {
  override fun read(buf: ByteBuffer): AppCallTransactionFields? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeAppCallTransactionFields.read(buf)
  }

  override fun allocationSize(value: AppCallTransactionFields?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeAppCallTransactionFields.allocationSize(value)
    }
  }

  override fun write(
    value: AppCallTransactionFields?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeAppCallTransactionFields.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeAssetConfigTransactionFields : FfiConverterRustBuffer<AssetConfigTransactionFields?> {
  override fun read(buf: ByteBuffer): AssetConfigTransactionFields? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeAssetConfigTransactionFields.read(buf)
  }

  override fun allocationSize(value: AssetConfigTransactionFields?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeAssetConfigTransactionFields.allocationSize(value)
    }
  }

  override fun write(
    value: AssetConfigTransactionFields?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeAssetConfigTransactionFields.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeAssetFreezeTransactionFields : FfiConverterRustBuffer<AssetFreezeTransactionFields?> {
  override fun read(buf: ByteBuffer): AssetFreezeTransactionFields? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeAssetFreezeTransactionFields.read(buf)
  }

  override fun allocationSize(value: AssetFreezeTransactionFields?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeAssetFreezeTransactionFields.allocationSize(value)
    }
  }

  override fun write(
    value: AssetFreezeTransactionFields?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeAssetFreezeTransactionFields.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeAssetTransferTransactionFields : FfiConverterRustBuffer<AssetTransferTransactionFields?> {
  override fun read(buf: ByteBuffer): AssetTransferTransactionFields? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeAssetTransferTransactionFields.read(buf)
  }

  override fun allocationSize(value: AssetTransferTransactionFields?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeAssetTransferTransactionFields.allocationSize(value)
    }
  }

  override fun write(
    value: AssetTransferTransactionFields?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeAssetTransferTransactionFields.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeKeyRegistrationTransactionFields : FfiConverterRustBuffer<KeyRegistrationTransactionFields?> {
  override fun read(buf: ByteBuffer): KeyRegistrationTransactionFields? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeKeyRegistrationTransactionFields.read(buf)
  }

  override fun allocationSize(value: KeyRegistrationTransactionFields?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeKeyRegistrationTransactionFields.allocationSize(value)
    }
  }

  override fun write(
    value: KeyRegistrationTransactionFields?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeKeyRegistrationTransactionFields.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeMultisigSignature : FfiConverterRustBuffer<MultisigSignature?> {
  override fun read(buf: ByteBuffer): MultisigSignature? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeMultisigSignature.read(buf)
  }

  override fun allocationSize(value: MultisigSignature?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeMultisigSignature.allocationSize(value)
    }
  }

  override fun write(
    value: MultisigSignature?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeMultisigSignature.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypePaymentTransactionFields : FfiConverterRustBuffer<PaymentTransactionFields?> {
  override fun read(buf: ByteBuffer): PaymentTransactionFields? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypePaymentTransactionFields.read(buf)
  }

  override fun allocationSize(value: PaymentTransactionFields?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypePaymentTransactionFields.allocationSize(value)
    }
  }

  override fun write(
    value: PaymentTransactionFields?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypePaymentTransactionFields.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeStateSchema : FfiConverterRustBuffer<StateSchema?> {
  override fun read(buf: ByteBuffer): StateSchema? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterTypeStateSchema.read(buf)
  }

  override fun allocationSize(value: StateSchema?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterTypeStateSchema.allocationSize(value)
    }
  }

  override fun write(
    value: StateSchema?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterTypeStateSchema.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalSequenceULong : FfiConverterRustBuffer<List<kotlin.ULong>?> {
  override fun read(buf: ByteBuffer): List<kotlin.ULong>? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterSequenceULong.read(buf)
  }

  override fun allocationSize(value: List<kotlin.ULong>?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterSequenceULong.allocationSize(value)
    }
  }

  override fun write(
    value: List<kotlin.ULong>?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterSequenceULong.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalSequenceString : FfiConverterRustBuffer<List<kotlin.String>?> {
  override fun read(buf: ByteBuffer): List<kotlin.String>? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterSequenceString.read(buf)
  }

  override fun allocationSize(value: List<kotlin.String>?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterSequenceString.allocationSize(value)
    }
  }

  override fun write(
    value: List<kotlin.String>?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterSequenceString.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalSequenceByteArray : FfiConverterRustBuffer<List<kotlin.ByteArray>?> {
  override fun read(buf: ByteBuffer): List<kotlin.ByteArray>? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterSequenceByteArray.read(buf)
  }

  override fun allocationSize(value: List<kotlin.ByteArray>?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterSequenceByteArray.allocationSize(value)
    }
  }

  override fun write(
    value: List<kotlin.ByteArray>?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterSequenceByteArray.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterOptionalSequenceTypeBoxReference : FfiConverterRustBuffer<List<BoxReference>?> {
  override fun read(buf: ByteBuffer): List<BoxReference>? {
    if (buf.get().toInt() == 0) {
      return null
    }
    return FfiConverterSequenceTypeBoxReference.read(buf)
  }

  override fun allocationSize(value: List<BoxReference>?): ULong {
    if (value == null) {
      return 1UL
    } else {
      return 1UL + FfiConverterSequenceTypeBoxReference.allocationSize(value)
    }
  }

  override fun write(
    value: List<BoxReference>?,
    buf: ByteBuffer,
  ) {
    if (value == null) {
      buf.put(0)
    } else {
      buf.put(1)
      FfiConverterSequenceTypeBoxReference.write(value, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceULong : FfiConverterRustBuffer<List<kotlin.ULong>> {
  override fun read(buf: ByteBuffer): List<kotlin.ULong> {
    val len = buf.getInt()
    return List<kotlin.ULong>(len) {
      FfiConverterULong.read(buf)
    }
  }

  override fun allocationSize(value: List<kotlin.ULong>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterULong.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<kotlin.ULong>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterULong.write(it, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceString : FfiConverterRustBuffer<List<kotlin.String>> {
  override fun read(buf: ByteBuffer): List<kotlin.String> {
    val len = buf.getInt()
    return List<kotlin.String>(len) {
      FfiConverterString.read(buf)
    }
  }

  override fun allocationSize(value: List<kotlin.String>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<kotlin.String>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterString.write(it, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceByteArray : FfiConverterRustBuffer<List<kotlin.ByteArray>> {
  override fun read(buf: ByteBuffer): List<kotlin.ByteArray> {
    val len = buf.getInt()
    return List<kotlin.ByteArray>(len) {
      FfiConverterByteArray.read(buf)
    }
  }

  override fun allocationSize(value: List<kotlin.ByteArray>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterByteArray.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<kotlin.ByteArray>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterByteArray.write(it, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypeBoxReference : FfiConverterRustBuffer<List<BoxReference>> {
  override fun read(buf: ByteBuffer): List<BoxReference> {
    val len = buf.getInt()
    return List<BoxReference>(len) {
      FfiConverterTypeBoxReference.read(buf)
    }
  }

  override fun allocationSize(value: List<BoxReference>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterTypeBoxReference.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<BoxReference>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterTypeBoxReference.write(it, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypeMultisigSubsignature : FfiConverterRustBuffer<List<MultisigSubsignature>> {
  override fun read(buf: ByteBuffer): List<MultisigSubsignature> {
    val len = buf.getInt()
    return List<MultisigSubsignature>(len) {
      FfiConverterTypeMultisigSubsignature.read(buf)
    }
  }

  override fun allocationSize(value: List<MultisigSubsignature>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterTypeMultisigSubsignature.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<MultisigSubsignature>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterTypeMultisigSubsignature.write(it, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypeSignedTransaction : FfiConverterRustBuffer<List<SignedTransaction>> {
  override fun read(buf: ByteBuffer): List<SignedTransaction> {
    val len = buf.getInt()
    return List<SignedTransaction>(len) {
      FfiConverterTypeSignedTransaction.read(buf)
    }
  }

  override fun allocationSize(value: List<SignedTransaction>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterTypeSignedTransaction.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<SignedTransaction>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterTypeSignedTransaction.write(it, buf)
    }
  }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypeTransaction : FfiConverterRustBuffer<List<Transaction>> {
  override fun read(buf: ByteBuffer): List<Transaction> {
    val len = buf.getInt()
    return List<Transaction>(len) {
      FfiConverterTypeTransaction.read(buf)
    }
  }

  override fun allocationSize(value: List<Transaction>): ULong {
    val sizeForLength = 4UL
    val sizeForItems = value.map { FfiConverterTypeTransaction.allocationSize(it) }.sum()
    return sizeForLength + sizeForItems
  }

  override fun write(
    value: List<Transaction>,
    buf: ByteBuffer,
  ) {
    buf.putInt(value.size)
    value.iterator().forEach {
      FfiConverterTypeTransaction.write(it, buf)
    }
  }
}

/**
 * Returns the address of the multisignature account.
 *
 * # Errors
 * /// Returns [`AlgoKitTransactError`] if the multisignature signature is invalid or the address cannot be derived.
 */
@Throws(AlgoKitTransactException::class)
fun `addressFromMultisigSignature`(`multisigSignature`: MultisigSignature): kotlin.String =
  FfiConverterString.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_address_from_multisig_signature(
        FfiConverterTypeMultisigSignature.lower(`multisigSignature`),
        _status,
      )
    },
  )

@Throws(AlgoKitTransactException::class)
fun `addressFromPublicKey`(`publicKey`: kotlin.ByteArray): String =
  FfiConverterString.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_address_from_public_key(
        FfiConverterByteArray.lower(`publicKey`),
        _status,
      )
    },
  )

/**
 * Applies a subsignature for a participant to a multisignature signature, replacing any existing signature.
 *
 * # Errors
 *
 * Returns [`AlgoKitTransactError`] if the participant address is invalid or not found, or if the signature bytes are invalid.
 */
@Throws(AlgoKitTransactException::class)
fun `applyMultisigSubsignature`(
  `multisigSignature`: MultisigSignature,
  `participant`: kotlin.String,
  `subsignature`: kotlin.ByteArray,
): MultisigSignature =
  FfiConverterTypeMultisigSignature.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_apply_multisig_subsignature(
        FfiConverterTypeMultisigSignature.lower(`multisigSignature`),
        FfiConverterString.lower(`participant`),
        FfiConverterByteArray.lower(`subsignature`),
        _status,
      )
    },
  )

@Throws(AlgoKitTransactException::class)
fun `assignFee`(
  `transaction`: Transaction,
  `feeParams`: FeeParams,
): Transaction =
  FfiConverterTypeTransaction.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_assign_fee(
        FfiConverterTypeTransaction.lower(`transaction`),
        FfiConverterTypeFeeParams.lower(`feeParams`),
        _status,
      )
    },
  )

@Throws(AlgoKitTransactException::class)
fun `calculateFee`(
  `transaction`: Transaction,
  `feeParams`: FeeParams,
): kotlin.ULong =
  FfiConverterULong.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_calculate_fee(
        FfiConverterTypeTransaction.lower(`transaction`),
        FfiConverterTypeFeeParams.lower(`feeParams`),
        _status,
      )
    },
  )

/**
 * Decodes a signed transaction.
 *
 * # Parameters
 * * `encoded_signed_transaction` - The MsgPack encoded signed transaction bytes
 *
 * # Returns
 * The decoded SignedTransaction or an error if decoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `decodeSignedTransaction`(`encodedSignedTransaction`: kotlin.ByteArray): SignedTransaction =
  FfiConverterTypeSignedTransaction.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_decode_signed_transaction(
        FfiConverterByteArray.lower(`encodedSignedTransaction`),
        _status,
      )
    },
  )

/**
 * Decodes a collection of MsgPack bytes into a signed transaction collection.
 *
 * # Parameters
 * * `encoded_signed_transactions` - A collection of MsgPack encoded bytes, each representing a signed transaction.
 *
 * # Returns
 * A collection of decoded signed transactions or an error if decoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `decodeSignedTransactions`(`encodedSignedTransactions`: List<kotlin.ByteArray>): List<SignedTransaction> =
  FfiConverterSequenceTypeSignedTransaction.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_decode_signed_transactions(
        FfiConverterSequenceByteArray.lower(`encodedSignedTransactions`),
        _status,
      )
    },
  )

/**
 * Decodes MsgPack bytes into a transaction.
 *
 * # Parameters
 * * `encoded_tx` - MsgPack encoded bytes representing a transaction.
 *
 * # Returns
 * A decoded transaction or an error if decoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `decodeTransaction`(`encodedTx`: kotlin.ByteArray): Transaction =
  FfiConverterTypeTransaction.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_decode_transaction(
        FfiConverterByteArray.lower(`encodedTx`),
        _status,
      )
    },
  )

/**
 * Decodes a collection of MsgPack bytes into a transaction collection.
 *
 * # Parameters
 * * `encoded_txs` - A collection of MsgPack encoded bytes, each representing a transaction.
 *
 * # Returns
 * A collection of decoded transactions or an error if decoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `decodeTransactions`(`encodedTxs`: List<kotlin.ByteArray>): List<Transaction> =
  FfiConverterSequenceTypeTransaction.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_decode_transactions(
        FfiConverterSequenceByteArray.lower(`encodedTxs`),
        _status,
      )
    },
  )

/**
 * Encode a signed transaction to MsgPack for sending on the network.
 *
 * This method performs canonical encoding. No domain separation prefix is applicable.
 *
 * # Parameters
 * * `signed_transaction` - The signed transaction to encode
 *
 * # Returns
 * The MsgPack encoded bytes or an error if encoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `encodeSignedTransaction`(`signedTransaction`: SignedTransaction): kotlin.ByteArray =
  FfiConverterByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_encode_signed_transaction(
        FfiConverterTypeSignedTransaction.lower(`signedTransaction`),
        _status,
      )
    },
  )

/**
 * Encode signed transactions to MsgPack for sending on the network.
 *
 * This method performs canonical encoding. No domain separation prefix is applicable.
 *
 * # Parameters
 * * `signed_transactions` - A collection of signed transactions to encode
 *
 * # Returns
 * A collection of MsgPack encoded bytes or an error if encoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `encodeSignedTransactions`(`signedTransactions`: List<SignedTransaction>): List<kotlin.ByteArray> =
  FfiConverterSequenceByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_encode_signed_transactions(
        FfiConverterSequenceTypeSignedTransaction.lower(`signedTransactions`),
        _status,
      )
    },
  )

/**
 * Encode the transaction with the domain separation (e.g. "TX") prefix
 */
@Throws(AlgoKitTransactException::class)
fun `encodeTransaction`(`transaction`: Transaction): kotlin.ByteArray =
  FfiConverterByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_encode_transaction(
        FfiConverterTypeTransaction.lower(`transaction`),
        _status,
      )
    },
  )

/**
 * Encode the transaction without the domain separation (e.g. "TX") prefix
 * This is useful for encoding the transaction for signing with tools that automatically add "TX" prefix to the transaction bytes.
 */
@Throws(AlgoKitTransactException::class)
fun `encodeTransactionRaw`(`transaction`: Transaction): kotlin.ByteArray =
  FfiConverterByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_encode_transaction_raw(
        FfiConverterTypeTransaction.lower(`transaction`),
        _status,
      )
    },
  )

/**
 * Encode transactions to MsgPack with the domain separation (e.g. "TX") prefix.
 *
 * # Parameters
 * * `transactions` - A collection of transactions to encode
 *
 * # Returns
 * A collection of MsgPack encoded bytes or an error if encoding fails.
 */
@Throws(AlgoKitTransactException::class)
fun `encodeTransactions`(`transactions`: List<Transaction>): List<kotlin.ByteArray> =
  FfiConverterSequenceByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_encode_transactions(
        FfiConverterSequenceTypeTransaction.lower(`transactions`),
        _status,
      )
    },
  )

/**
 * Return the size of the transaction in bytes as if it was already signed and encoded.
 * This is useful for estimating the fee for the transaction.
 */
@Throws(AlgoKitTransactException::class)
fun `estimateTransactionSize`(`transaction`: Transaction): kotlin.ULong =
  FfiConverterULong.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_estimate_transaction_size(
        FfiConverterTypeTransaction.lower(`transaction`),
        _status,
      )
    },
  )

fun `getAlgorandConstant`(`constant`: AlgorandConstant): kotlin.ULong =
  FfiConverterULong.lift(
    uniffiRustCall { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_get_algorand_constant(
        FfiConverterTypeAlgorandConstant.lower(`constant`),
        _status,
      )
    },
  )

/**
 * Get the transaction type from the encoded transaction.
 * This is particularly useful when decoding a transaction that has an unknown type
 */
@Throws(AlgoKitTransactException::class)
fun `getEncodedTransactionType`(`encodedTransaction`: kotlin.ByteArray): TransactionType =
  FfiConverterTypeTransactionType.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_get_encoded_transaction_type(
        FfiConverterByteArray.lower(`encodedTransaction`),
        _status,
      )
    },
  )

/**
 * Get the base32 transaction ID string for a transaction.
 */
@Throws(AlgoKitTransactException::class)
fun `getTransactionId`(`transaction`: Transaction): kotlin.String =
  FfiConverterString.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_get_transaction_id(
        FfiConverterTypeTransaction.lower(`transaction`),
        _status,
      )
    },
  )

/**
 * Get the raw 32-byte transaction ID for a transaction.
 */
@Throws(AlgoKitTransactException::class)
fun `getTransactionIdRaw`(`transaction`: Transaction): kotlin.ByteArray =
  FfiConverterByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_get_transaction_id_raw(
        FfiConverterTypeTransaction.lower(`transaction`),
        _status,
      )
    },
  )

/**
 * Groups a collection of transactions by calculating and assigning the group to each transaction.
 */
@Throws(AlgoKitTransactException::class)
fun `groupTransactions`(`transactions`: List<Transaction>): List<Transaction> =
  FfiConverterSequenceTypeTransaction.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_group_transactions(
        FfiConverterSequenceTypeTransaction.lower(`transactions`),
        _status,
      )
    },
  )

/**
 * Merges two multisignature signatures, replacing signatures in the first with those from the second where present.
 *
 * # Errors
 *
 * Returns [`AlgoKitTransactError`] if the multisignature parameters or participants do not match.
 */
@Throws(AlgoKitTransactException::class)
fun `mergeMultisignatures`(
  `multisigSignatureA`: MultisigSignature,
  `multisigSignatureB`: MultisigSignature,
): MultisigSignature =
  FfiConverterTypeMultisigSignature.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_merge_multisignatures(
        FfiConverterTypeMultisigSignature.lower(`multisigSignatureA`),
        FfiConverterTypeMultisigSignature.lower(`multisigSignatureB`),
        _status,
      )
    },
  )

/**
 * Creates an empty multisignature signature from a list of participant addresses.
 *
 * # Errors
 *
 * Returns [`AlgoKitTransactError`] if any address is invalid or the multisignature parameters are invalid.
 */
@Throws(AlgoKitTransactException::class)
fun `newMultisigSignature`(
  `version`: kotlin.UByte,
  `threshold`: kotlin.UByte,
  `participants`: List<kotlin.String>,
): MultisigSignature =
  FfiConverterTypeMultisigSignature.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_new_multisig_signature(
        FfiConverterUByte.lower(`version`),
        FfiConverterUByte.lower(`threshold`),
        FfiConverterSequenceString.lower(`participants`),
        _status,
      )
    },
  )

/**
 * Returns the list of participant addresses from a multisignature signature.
 *
 * # Errors
 * Returns [`AlgoKitTransactError`] if the multisignature is invalid.
 */
@Throws(AlgoKitTransactException::class)
fun `participantsFromMultisigSignature`(`multisigSignature`: MultisigSignature): List<kotlin.String> =
  FfiConverterSequenceString.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_participants_from_multisig_signature(
        FfiConverterTypeMultisigSignature.lower(`multisigSignature`),
        _status,
      )
    },
  )

@Throws(AlgoKitTransactException::class)
fun `publicKeyFromAddress`(`address`: kotlin.String): kotlin.ByteArray =
  FfiConverterByteArray.lift(
    uniffiRustCallWithError(AlgoKitTransactException) { _status ->
      UniffiLib.INSTANCE.uniffi_algokit_transact_ffi_fn_func_public_key_from_address(
        FfiConverterString.lower(`address`),
        _status,
      )
    },
  )
