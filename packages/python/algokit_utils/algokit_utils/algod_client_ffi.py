

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform
from .algokit_http_client import HttpClient
from .algokit_http_client import HttpError
from .algokit_http_client import _UniffiConverterTypeHttpClient
from .algokit_http_client import _UniffiConverterTypeHttpError
from .algokit_transact_ffi import SignedTransaction
from .algokit_transact_ffi import _UniffiConverterTypeSignedTransaction
from .algokit_http_client import _UniffiRustBuffer as _UniffiRustBufferHttpClient
from .algokit_http_client import _UniffiRustBuffer as _UniffiRustBufferHttpError
from .algokit_transact_ffi import _UniffiRustBuffer as _UniffiRustBufferSignedTransaction

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_algod_client_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_algod_client_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_algod_client_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("algokit_utils_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_algod_client_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_abort_catchup() != 56060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_account_application_information() != 29999:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_account_asset_information() != 24166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_account_assets_information() != 6555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_account_information() != 54762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_add_participation_key() != 2657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_append_keys() != 48948:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_delete_participation_key_by_id() != 62766:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_experimental_check() != 47498:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_generate_participation_keys() != 30110:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_box_by_name() != 29997:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_boxes() != 28673:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_by_id() != 35236:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_asset_by_id() != 36064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block() != 61611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_hash() != 23974:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_logs() != 21016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_time_stamp_offset() != 1839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_txids() != 19980:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_config() != 2:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_debug_settings_prof() != 44636:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_genesis() != 33262:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ledger_state_delta() != 41535:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ledger_state_delta_for_transaction_group() != 43525:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_light_block_header_proof() != 32109:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_participation_key_by_id() != 48636:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_participation_keys() != 50810:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_pending_transactions() != 27089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_pending_transactions_by_address() != 53966:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ready() != 35284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_state_proof() != 24973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_status() != 37010:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_supply() != 55012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_sync_round() != 48802:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_transaction_group_ledger_state_deltas_for_round() != 42695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_transaction_proof() != 2103:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_get_version() != 7973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_health_check() != 34211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_metrics() != 58727:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_pending_transaction_information() != 45705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_put_debug_settings_prof() != 38244:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_raw_transaction() != 44873:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_raw_transaction_async() != 22542:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_set_block_time_stamp_offset() != 53790:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_set_sync_round() != 65075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_shutdown_node() != 63713:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_simulate_transaction() != 5767:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_start_catchup() != 36866:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_swagger_json() != 56396:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_compile() != 27269:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_disassemble() != 50305:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_dryrun() != 34333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_transaction_params() != 21810:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_unset_sync_round() != 61657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclient_wait_for_block() != 9675:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_health_check() != 31004:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ready() != 32153:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_metrics() != 54504:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_genesis() != 53872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_swagger_json() != 33786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_version() != 48136:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_debug_settings_prof() != 8719:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_put_debug_settings_prof() != 11478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_config() != 36751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_information() != 36494:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_asset_information() != 35829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_assets_information() != 7523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_application_information() != 32643:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_pending_transactions_by_address() != 56228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block() != 28675:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_txids() != 18606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_hash() != 42932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_transaction_proof() != 55680:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_logs() != 64461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_supply() != 56575:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_participation_keys() != 33821:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_add_participation_key() != 1010:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_generate_participation_keys() != 11293:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_participation_key_by_id() != 57044:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_append_keys() != 22678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_delete_participation_key_by_id() != 739:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_shutdown_node() != 65060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_status() != 12650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_wait_for_block() != 9950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_raw_transaction() != 11416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_raw_transaction_async() != 58915:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_simulate_transaction() != 34397:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_transaction_params() != 5378:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_pending_transactions() != 11707:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_pending_transaction_information() != 57930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ledger_state_delta() != 54683:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_transaction_group_ledger_state_deltas_for_round() != 15191:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ledger_state_delta_for_transaction_group() != 1328:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_state_proof() != 11069:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_light_block_header_proof() != 50214:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_by_id() != 30187:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_boxes() != 45910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_box_by_name() != 152:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_asset_by_id() != 54171:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_sync_round() != 7287:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_unset_sync_round() != 39382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_set_sync_round() != 19078:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_compile() != 12414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_disassemble() != 44847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_start_catchup() != 48197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_abort_catchup() != 1545:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_dryrun() != 23321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_experimental_check() != 65217:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_time_stamp_offset() != 46373:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_set_block_time_stamp_offset() != 3361:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algod_client_ffi_checksum_constructor_algodclient_new() != 43657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD7 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD9 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD10 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD11 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD12 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD13 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD14 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD15 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD17 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD18 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD19 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD20 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD21 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD22 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD23 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD24 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD25 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD26 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD27 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD28 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD29 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD30 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD31 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD33 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD34 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD35 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD36 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD37 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD38 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD39 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD40 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD41 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD42 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD43 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD44 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD45 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD46 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD47 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD48 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD49 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD50 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD51 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD52 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD53 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD54 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
class _UniffiVTableCallbackInterfaceAlgodClientTrait(ctypes.Structure):
    _fields_ = [
        ("health_check", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD0),
        ("get_ready", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD1),
        ("metrics", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD2),
        ("get_genesis", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD3),
        ("swagger_json", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD4),
        ("get_version", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD5),
        ("get_debug_settings_prof", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD6),
        ("put_debug_settings_prof", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD7),
        ("get_config", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD8),
        ("account_information", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD9),
        ("account_asset_information", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD10),
        ("account_assets_information", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD11),
        ("account_application_information", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD12),
        ("get_pending_transactions_by_address", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD13),
        ("get_block", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD14),
        ("get_block_txids", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD15),
        ("get_block_hash", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD16),
        ("get_transaction_proof", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD17),
        ("get_block_logs", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD18),
        ("get_supply", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD19),
        ("get_participation_keys", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD20),
        ("add_participation_key", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD21),
        ("generate_participation_keys", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD22),
        ("get_participation_key_by_id", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD23),
        ("append_keys", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD24),
        ("delete_participation_key_by_id", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD25),
        ("shutdown_node", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD26),
        ("get_status", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD27),
        ("wait_for_block", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD28),
        ("raw_transaction", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD29),
        ("raw_transaction_async", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD30),
        ("simulate_transaction", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD31),
        ("transaction_params", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD32),
        ("get_pending_transactions", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD33),
        ("pending_transaction_information", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD34),
        ("get_ledger_state_delta", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD35),
        ("get_transaction_group_ledger_state_deltas_for_round", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD36),
        ("get_ledger_state_delta_for_transaction_group", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD37),
        ("get_state_proof", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD38),
        ("get_light_block_header_proof", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD39),
        ("get_application_by_id", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD40),
        ("get_application_boxes", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD41),
        ("get_application_box_by_name", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD42),
        ("get_asset_by_id", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD43),
        ("get_sync_round", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD44),
        ("unset_sync_round", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD45),
        ("set_sync_round", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD46),
        ("teal_compile", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD47),
        ("teal_disassemble", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD48),
        ("start_catchup", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD49),
        ("abort_catchup", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD50),
        ("teal_dryrun", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD51),
        ("experimental_check", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD52),
        ("get_block_time_stamp_offset", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD53),
        ("set_block_time_stamp_offset", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD54),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_algod_client_ffi_fn_clone_algodclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algod_client_ffi_fn_clone_algodclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_algod_client_ffi_fn_free_algodclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algod_client_ffi_fn_free_algodclient.restype = None
_UniffiLib.uniffi_algod_client_ffi_fn_constructor_algodclient_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algod_client_ffi_fn_constructor_algodclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_abort_catchup.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_abort_catchup.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_application_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_application_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_asset_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_asset_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_assets_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_assets_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_add_participation_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_add_participation_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_append_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_append_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_delete_participation_key_by_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_delete_participation_key_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_experimental_check.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_experimental_check.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_generate_participation_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_generate_participation_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_box_by_name.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_box_by_name.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_boxes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_boxes.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_asset_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_asset_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_logs.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_logs.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_time_stamp_offset.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_time_stamp_offset.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_txids.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_txids.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_config.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_config.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_debug_settings_prof.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_debug_settings_prof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_genesis.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_genesis.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ledger_state_delta.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ledger_state_delta.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ledger_state_delta_for_transaction_group.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ledger_state_delta_for_transaction_group.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_light_block_header_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_light_block_header_proof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_participation_key_by_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_participation_key_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_participation_keys.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_participation_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_pending_transactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_pending_transactions.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_pending_transactions_by_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_pending_transactions_by_address.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ready.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ready.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_state_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_state_proof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_status.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_supply.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_supply.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_sync_round.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_sync_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_transaction_group_ledger_state_deltas_for_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_transaction_group_ledger_state_deltas_for_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_transaction_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_transaction_proof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_version.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_health_check.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_health_check.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_metrics.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_metrics.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_pending_transaction_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_pending_transaction_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_put_debug_settings_prof.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_put_debug_settings_prof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_raw_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_raw_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_raw_transaction_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_raw_transaction_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_set_block_time_stamp_offset.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_set_block_time_stamp_offset.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_set_sync_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_set_sync_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_shutdown_node.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_shutdown_node.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_simulate_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_simulate_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_start_catchup.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_start_catchup.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_swagger_json.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_swagger_json.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_compile.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_compile.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_disassemble.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_disassemble.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_dryrun.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_dryrun.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_transaction_params.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_transaction_params.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_unset_sync_round.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_unset_sync_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_wait_for_block.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_wait_for_block.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_clone_algodclienttrait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algod_client_ffi_fn_clone_algodclienttrait.restype = ctypes.c_void_p
_UniffiLib.uniffi_algod_client_ffi_fn_free_algodclienttrait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algod_client_ffi_fn_free_algodclienttrait.restype = None
_UniffiLib.uniffi_algod_client_ffi_fn_init_callback_vtable_algodclienttrait.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceAlgodClientTrait),
)
_UniffiLib.uniffi_algod_client_ffi_fn_init_callback_vtable_algodclienttrait.restype = None
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_health_check.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_health_check.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ready.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ready.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_metrics.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_metrics.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_genesis.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_genesis.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_swagger_json.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_swagger_json.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_version.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_debug_settings_prof.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_debug_settings_prof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_put_debug_settings_prof.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_put_debug_settings_prof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_config.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_config.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_asset_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_asset_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_assets_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_assets_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_application_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_application_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_pending_transactions_by_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_pending_transactions_by_address.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_txids.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_txids.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_transaction_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_transaction_proof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_logs.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_logs.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_supply.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_supply.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_participation_keys.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_participation_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_add_participation_key.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_add_participation_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_generate_participation_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_generate_participation_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_participation_key_by_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_participation_key_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_append_keys.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_append_keys.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_delete_participation_key_by_id.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_delete_participation_key_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_shutdown_node.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_shutdown_node.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_status.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_wait_for_block.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_wait_for_block.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_raw_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_raw_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_raw_transaction_async.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_raw_transaction_async.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_simulate_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_simulate_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_transaction_params.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_transaction_params.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_pending_transactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_pending_transactions.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_pending_transaction_information.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_pending_transaction_information.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ledger_state_delta.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ledger_state_delta.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_transaction_group_ledger_state_deltas_for_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_transaction_group_ledger_state_deltas_for_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ledger_state_delta_for_transaction_group.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ledger_state_delta_for_transaction_group.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_state_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_state_proof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_light_block_header_proof.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_light_block_header_proof.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_boxes.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_boxes.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_box_by_name.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_box_by_name.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_asset_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_asset_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_sync_round.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_sync_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_unset_sync_round.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_unset_sync_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_set_sync_round.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_set_sync_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_compile.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_compile.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_disassemble.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_disassemble.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_start_catchup.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_start_catchup.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_abort_catchup.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_abort_catchup.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_dryrun.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_dryrun.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_experimental_check.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_experimental_check.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_time_stamp_offset.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_time_stamp_offset.restype = ctypes.c_uint64
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_set_block_time_stamp_offset.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_set_block_time_stamp_offset.restype = ctypes.c_uint64
_UniffiLib.ffi_algod_client_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_algod_client_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_algod_client_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_algod_client_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algod_client_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algod_client_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_abort_catchup.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_abort_catchup.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_application_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_application_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_asset_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_asset_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_assets_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_assets_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_account_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_add_participation_key.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_add_participation_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_append_keys.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_append_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_delete_participation_key_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_delete_participation_key_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_experimental_check.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_experimental_check.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_generate_participation_keys.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_generate_participation_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_box_by_name.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_box_by_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_boxes.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_boxes.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_application_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_asset_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_asset_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_hash.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_logs.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_logs.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_time_stamp_offset.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_time_stamp_offset.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_txids.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_block_txids.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_config.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_debug_settings_prof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_debug_settings_prof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_genesis.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_genesis.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ledger_state_delta.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ledger_state_delta.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ledger_state_delta_for_transaction_group.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ledger_state_delta_for_transaction_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_light_block_header_proof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_light_block_header_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_participation_key_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_participation_key_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_participation_keys.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_participation_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_pending_transactions.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_pending_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_pending_transactions_by_address.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_pending_transactions_by_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ready.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_ready.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_state_proof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_state_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_status.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_supply.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_supply.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_sync_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_sync_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_transaction_group_ledger_state_deltas_for_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_transaction_group_ledger_state_deltas_for_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_transaction_proof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_transaction_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_version.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_get_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_health_check.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_health_check.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_metrics.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_metrics.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_pending_transaction_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_pending_transaction_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_put_debug_settings_prof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_put_debug_settings_prof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_raw_transaction.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_raw_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_raw_transaction_async.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_raw_transaction_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_set_block_time_stamp_offset.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_set_block_time_stamp_offset.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_set_sync_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_set_sync_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_shutdown_node.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_shutdown_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_simulate_transaction.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_simulate_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_start_catchup.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_start_catchup.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_swagger_json.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_swagger_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_compile.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_compile.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_disassemble.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_disassemble.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_dryrun.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_teal_dryrun.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_transaction_params.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_transaction_params.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_unset_sync_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_unset_sync_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_wait_for_block.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclient_wait_for_block.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_health_check.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_health_check.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ready.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ready.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_metrics.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_metrics.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_genesis.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_genesis.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_swagger_json.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_swagger_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_version.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_debug_settings_prof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_debug_settings_prof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_put_debug_settings_prof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_put_debug_settings_prof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_config.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_asset_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_asset_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_assets_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_assets_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_application_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_account_application_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_pending_transactions_by_address.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_pending_transactions_by_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_txids.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_txids.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_hash.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_hash.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_transaction_proof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_transaction_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_logs.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_logs.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_supply.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_supply.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_participation_keys.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_participation_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_add_participation_key.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_add_participation_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_generate_participation_keys.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_generate_participation_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_participation_key_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_participation_key_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_append_keys.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_append_keys.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_delete_participation_key_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_delete_participation_key_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_shutdown_node.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_shutdown_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_status.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_wait_for_block.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_wait_for_block.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_raw_transaction.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_raw_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_raw_transaction_async.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_raw_transaction_async.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_simulate_transaction.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_simulate_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_transaction_params.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_transaction_params.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_pending_transactions.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_pending_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_pending_transaction_information.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_pending_transaction_information.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ledger_state_delta.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ledger_state_delta.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_transaction_group_ledger_state_deltas_for_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_transaction_group_ledger_state_deltas_for_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ledger_state_delta_for_transaction_group.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_ledger_state_delta_for_transaction_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_state_proof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_state_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_light_block_header_proof.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_light_block_header_proof.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_boxes.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_boxes.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_box_by_name.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_application_box_by_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_asset_by_id.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_asset_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_sync_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_sync_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_unset_sync_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_unset_sync_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_set_sync_round.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_set_sync_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_compile.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_compile.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_disassemble.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_disassemble.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_start_catchup.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_start_catchup.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_abort_catchup.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_abort_catchup.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_dryrun.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_teal_dryrun.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_experimental_check.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_experimental_check.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_time_stamp_offset.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_get_block_time_stamp_offset.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_set_block_time_stamp_offset.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_method_algodclienttrait_set_block_time_stamp_offset.restype = ctypes.c_uint16
_UniffiLib.uniffi_algod_client_ffi_checksum_constructor_algodclient_new.argtypes = (
)
_UniffiLib.uniffi_algod_client_ffi_checksum_constructor_algodclient_new.restype = ctypes.c_uint16
_UniffiLib.ffi_algod_client_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_algod_client_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)






class AbortCatchup:
    """
    An catchpoint abort response.
    """

    catchup_message: "str"
    """
    Catchup abort response string
    """

    def __init__(self, *, catchup_message: "str"):
        self.catchup_message = catchup_message

    def __str__(self):
        return "AbortCatchup(catchup_message={})".format(self.catchup_message)

    def __eq__(self, other):
        if self.catchup_message != other.catchup_message:
            return False
        return True

class _UniffiConverterTypeAbortCatchup(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AbortCatchup(
            catchup_message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.catchup_message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.catchup_message, buf)


class Account:
    """
    Account information at a given round.

    Definition:
    data/basics/userBalance.go : AccountData
    """

    address: "str"
    """
    the account public key
    """

    amount: "int"
    """
    [algo] total number of MicroAlgos in the account
    """

    min_balance: "int"
    """
    MicroAlgo balance required by the account.

    The requirement grows based on asset and application usage.
    """

    amount_without_pending_rewards: "int"
    """
    specifies the amount of MicroAlgos in the account, without the pending rewards.
    """

    apps_local_state: "typing.Optional[typing.List[ApplicationLocalState]]"
    """
    [appl] applications local data stored in this account.

    Note the raw object uses `map[int] -> AppLocalState` for this type.
    """

    total_apps_opted_in: "int"
    """
    The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.
    """

    apps_total_schema: "typing.Optional[ApplicationStateSchema]"
    apps_total_extra_pages: "typing.Optional[int]"
    """
    [teap] the sum of all extra application program pages for this account.
    """

    assets: "typing.Optional[typing.List[AssetHolding]]"
    """
    [asset] assets held by this account.

    Note the raw object uses `map[int] -> AssetHolding` for this type.
    """

    total_assets_opted_in: "int"
    """
    The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.
    """

    created_apps: "typing.Optional[typing.List[Application]]"
    """
    [appp] parameters of applications created by this account including app global data.

    Note: the raw account uses `map[int] -> AppParams` for this type.
    """

    total_created_apps: "int"
    """
    The count of all apps (AppParams objects) created by this account.
    """

    created_assets: "typing.Optional[typing.List[Asset]]"
    """
    [apar] parameters of assets created by this account.

    Note: the raw account uses `map[int] -> Asset` for this type.
    """

    total_created_assets: "int"
    """
    The count of all assets (AssetParams objects) created by this account.
    """

    total_boxes: "typing.Optional[int]"
    """
    [tbx] The number of existing boxes created by this account's app.
    """

    total_box_bytes: "typing.Optional[int]"
    """
    [tbxb] The total number of bytes used by this account's app's box keys and values.
    """

    participation: "typing.Optional[AccountParticipation]"
    incentive_eligible: "typing.Optional[bool]"
    """
    Whether or not the account can receive block incentives if its balance is in range at proposal time.
    """

    pending_rewards: "int"
    """
    amount of MicroAlgos of pending rewards in this account.
    """

    reward_base: "typing.Optional[int]"
    """
    [ebase] used as part of the rewards computation. Only applicable to accounts which are participating.
    """

    rewards: "int"
    """
    [ern] total rewards of MicroAlgos the account has received, including pending rewards.
    """

    round: "int"
    """
    The round for which this information is relevant.
    """

    status: "str"
    """
    [onl] delegation status of the account's MicroAlgos
    * Offline - indicates that the associated account is delegated.
    *  Online  - indicates that the associated account used as part of the delegation pool.
    *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.
    """

    sig_type: "typing.Optional[str]"
    """
    Indicates what type of signature is used by this account, must be one of:
    * sig
    * msig
    * lsig
    """

    auth_addr: "typing.Optional[str]"
    """
    [spend] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.
    """

    last_proposed: "typing.Optional[int]"
    """
    The round in which this account last proposed the block.
    """

    last_heartbeat: "typing.Optional[int]"
    """
    The round in which this account last went online, or explicitly renewed their online status.
    """

    def __init__(self, *, address: "str", amount: "int", min_balance: "int", amount_without_pending_rewards: "int", apps_local_state: "typing.Optional[typing.List[ApplicationLocalState]]", total_apps_opted_in: "int", apps_total_schema: "typing.Optional[ApplicationStateSchema]", apps_total_extra_pages: "typing.Optional[int]", assets: "typing.Optional[typing.List[AssetHolding]]", total_assets_opted_in: "int", created_apps: "typing.Optional[typing.List[Application]]", total_created_apps: "int", created_assets: "typing.Optional[typing.List[Asset]]", total_created_assets: "int", total_boxes: "typing.Optional[int]", total_box_bytes: "typing.Optional[int]", participation: "typing.Optional[AccountParticipation]", incentive_eligible: "typing.Optional[bool]", pending_rewards: "int", reward_base: "typing.Optional[int]", rewards: "int", round: "int", status: "str", sig_type: "typing.Optional[str]", auth_addr: "typing.Optional[str]", last_proposed: "typing.Optional[int]", last_heartbeat: "typing.Optional[int]"):
        self.address = address
        self.amount = amount
        self.min_balance = min_balance
        self.amount_without_pending_rewards = amount_without_pending_rewards
        self.apps_local_state = apps_local_state
        self.total_apps_opted_in = total_apps_opted_in
        self.apps_total_schema = apps_total_schema
        self.apps_total_extra_pages = apps_total_extra_pages
        self.assets = assets
        self.total_assets_opted_in = total_assets_opted_in
        self.created_apps = created_apps
        self.total_created_apps = total_created_apps
        self.created_assets = created_assets
        self.total_created_assets = total_created_assets
        self.total_boxes = total_boxes
        self.total_box_bytes = total_box_bytes
        self.participation = participation
        self.incentive_eligible = incentive_eligible
        self.pending_rewards = pending_rewards
        self.reward_base = reward_base
        self.rewards = rewards
        self.round = round
        self.status = status
        self.sig_type = sig_type
        self.auth_addr = auth_addr
        self.last_proposed = last_proposed
        self.last_heartbeat = last_heartbeat

    def __str__(self):
        return "Account(address={}, amount={}, min_balance={}, amount_without_pending_rewards={}, apps_local_state={}, total_apps_opted_in={}, apps_total_schema={}, apps_total_extra_pages={}, assets={}, total_assets_opted_in={}, created_apps={}, total_created_apps={}, created_assets={}, total_created_assets={}, total_boxes={}, total_box_bytes={}, participation={}, incentive_eligible={}, pending_rewards={}, reward_base={}, rewards={}, round={}, status={}, sig_type={}, auth_addr={}, last_proposed={}, last_heartbeat={})".format(self.address, self.amount, self.min_balance, self.amount_without_pending_rewards, self.apps_local_state, self.total_apps_opted_in, self.apps_total_schema, self.apps_total_extra_pages, self.assets, self.total_assets_opted_in, self.created_apps, self.total_created_apps, self.created_assets, self.total_created_assets, self.total_boxes, self.total_box_bytes, self.participation, self.incentive_eligible, self.pending_rewards, self.reward_base, self.rewards, self.round, self.status, self.sig_type, self.auth_addr, self.last_proposed, self.last_heartbeat)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.amount != other.amount:
            return False
        if self.min_balance != other.min_balance:
            return False
        if self.amount_without_pending_rewards != other.amount_without_pending_rewards:
            return False
        if self.apps_local_state != other.apps_local_state:
            return False
        if self.total_apps_opted_in != other.total_apps_opted_in:
            return False
        if self.apps_total_schema != other.apps_total_schema:
            return False
        if self.apps_total_extra_pages != other.apps_total_extra_pages:
            return False
        if self.assets != other.assets:
            return False
        if self.total_assets_opted_in != other.total_assets_opted_in:
            return False
        if self.created_apps != other.created_apps:
            return False
        if self.total_created_apps != other.total_created_apps:
            return False
        if self.created_assets != other.created_assets:
            return False
        if self.total_created_assets != other.total_created_assets:
            return False
        if self.total_boxes != other.total_boxes:
            return False
        if self.total_box_bytes != other.total_box_bytes:
            return False
        if self.participation != other.participation:
            return False
        if self.incentive_eligible != other.incentive_eligible:
            return False
        if self.pending_rewards != other.pending_rewards:
            return False
        if self.reward_base != other.reward_base:
            return False
        if self.rewards != other.rewards:
            return False
        if self.round != other.round:
            return False
        if self.status != other.status:
            return False
        if self.sig_type != other.sig_type:
            return False
        if self.auth_addr != other.auth_addr:
            return False
        if self.last_proposed != other.last_proposed:
            return False
        if self.last_heartbeat != other.last_heartbeat:
            return False
        return True

class _UniffiConverterTypeAccount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Account(
            address=_UniffiConverterString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            min_balance=_UniffiConverterUInt64.read(buf),
            amount_without_pending_rewards=_UniffiConverterUInt64.read(buf),
            apps_local_state=_UniffiConverterOptionalSequenceTypeApplicationLocalState.read(buf),
            total_apps_opted_in=_UniffiConverterUInt64.read(buf),
            apps_total_schema=_UniffiConverterOptionalTypeApplicationStateSchema.read(buf),
            apps_total_extra_pages=_UniffiConverterOptionalUInt64.read(buf),
            assets=_UniffiConverterOptionalSequenceTypeAssetHolding.read(buf),
            total_assets_opted_in=_UniffiConverterUInt64.read(buf),
            created_apps=_UniffiConverterOptionalSequenceTypeApplication.read(buf),
            total_created_apps=_UniffiConverterUInt64.read(buf),
            created_assets=_UniffiConverterOptionalSequenceTypeAsset.read(buf),
            total_created_assets=_UniffiConverterUInt64.read(buf),
            total_boxes=_UniffiConverterOptionalUInt64.read(buf),
            total_box_bytes=_UniffiConverterOptionalUInt64.read(buf),
            participation=_UniffiConverterOptionalTypeAccountParticipation.read(buf),
            incentive_eligible=_UniffiConverterOptionalBool.read(buf),
            pending_rewards=_UniffiConverterUInt64.read(buf),
            reward_base=_UniffiConverterOptionalUInt64.read(buf),
            rewards=_UniffiConverterUInt64.read(buf),
            round=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterString.read(buf),
            sig_type=_UniffiConverterOptionalString.read(buf),
            auth_addr=_UniffiConverterOptionalString.read(buf),
            last_proposed=_UniffiConverterOptionalUInt64.read(buf),
            last_heartbeat=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterUInt64.check_lower(value.min_balance)
        _UniffiConverterUInt64.check_lower(value.amount_without_pending_rewards)
        _UniffiConverterOptionalSequenceTypeApplicationLocalState.check_lower(value.apps_local_state)
        _UniffiConverterUInt64.check_lower(value.total_apps_opted_in)
        _UniffiConverterOptionalTypeApplicationStateSchema.check_lower(value.apps_total_schema)
        _UniffiConverterOptionalUInt64.check_lower(value.apps_total_extra_pages)
        _UniffiConverterOptionalSequenceTypeAssetHolding.check_lower(value.assets)
        _UniffiConverterUInt64.check_lower(value.total_assets_opted_in)
        _UniffiConverterOptionalSequenceTypeApplication.check_lower(value.created_apps)
        _UniffiConverterUInt64.check_lower(value.total_created_apps)
        _UniffiConverterOptionalSequenceTypeAsset.check_lower(value.created_assets)
        _UniffiConverterUInt64.check_lower(value.total_created_assets)
        _UniffiConverterOptionalUInt64.check_lower(value.total_boxes)
        _UniffiConverterOptionalUInt64.check_lower(value.total_box_bytes)
        _UniffiConverterOptionalTypeAccountParticipation.check_lower(value.participation)
        _UniffiConverterOptionalBool.check_lower(value.incentive_eligible)
        _UniffiConverterUInt64.check_lower(value.pending_rewards)
        _UniffiConverterOptionalUInt64.check_lower(value.reward_base)
        _UniffiConverterUInt64.check_lower(value.rewards)
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterString.check_lower(value.status)
        _UniffiConverterOptionalString.check_lower(value.sig_type)
        _UniffiConverterOptionalString.check_lower(value.auth_addr)
        _UniffiConverterOptionalUInt64.check_lower(value.last_proposed)
        _UniffiConverterOptionalUInt64.check_lower(value.last_heartbeat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterUInt64.write(value.min_balance, buf)
        _UniffiConverterUInt64.write(value.amount_without_pending_rewards, buf)
        _UniffiConverterOptionalSequenceTypeApplicationLocalState.write(value.apps_local_state, buf)
        _UniffiConverterUInt64.write(value.total_apps_opted_in, buf)
        _UniffiConverterOptionalTypeApplicationStateSchema.write(value.apps_total_schema, buf)
        _UniffiConverterOptionalUInt64.write(value.apps_total_extra_pages, buf)
        _UniffiConverterOptionalSequenceTypeAssetHolding.write(value.assets, buf)
        _UniffiConverterUInt64.write(value.total_assets_opted_in, buf)
        _UniffiConverterOptionalSequenceTypeApplication.write(value.created_apps, buf)
        _UniffiConverterUInt64.write(value.total_created_apps, buf)
        _UniffiConverterOptionalSequenceTypeAsset.write(value.created_assets, buf)
        _UniffiConverterUInt64.write(value.total_created_assets, buf)
        _UniffiConverterOptionalUInt64.write(value.total_boxes, buf)
        _UniffiConverterOptionalUInt64.write(value.total_box_bytes, buf)
        _UniffiConverterOptionalTypeAccountParticipation.write(value.participation, buf)
        _UniffiConverterOptionalBool.write(value.incentive_eligible, buf)
        _UniffiConverterUInt64.write(value.pending_rewards, buf)
        _UniffiConverterOptionalUInt64.write(value.reward_base, buf)
        _UniffiConverterUInt64.write(value.rewards, buf)
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterString.write(value.status, buf)
        _UniffiConverterOptionalString.write(value.sig_type, buf)
        _UniffiConverterOptionalString.write(value.auth_addr, buf)
        _UniffiConverterOptionalUInt64.write(value.last_proposed, buf)
        _UniffiConverterOptionalUInt64.write(value.last_heartbeat, buf)


class AccountApplicationInformation:
    """
    AccountApplicationResponse describes the account's application local state and global state (AppLocalState and AppParams, if either exists) for a specific application ID. Global state will only be returned if the provided address is the application's creator.
    """

    round: "int"
    """
    The round for which this information is relevant.
    """

    app_local_state: "typing.Optional[ApplicationLocalState]"
    created_app: "typing.Optional[ApplicationParams]"
    def __init__(self, *, round: "int", app_local_state: "typing.Optional[ApplicationLocalState]", created_app: "typing.Optional[ApplicationParams]"):
        self.round = round
        self.app_local_state = app_local_state
        self.created_app = created_app

    def __str__(self):
        return "AccountApplicationInformation(round={}, app_local_state={}, created_app={})".format(self.round, self.app_local_state, self.created_app)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        if self.app_local_state != other.app_local_state:
            return False
        if self.created_app != other.created_app:
            return False
        return True

class _UniffiConverterTypeAccountApplicationInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountApplicationInformation(
            round=_UniffiConverterUInt64.read(buf),
            app_local_state=_UniffiConverterOptionalTypeApplicationLocalState.read(buf),
            created_app=_UniffiConverterOptionalTypeApplicationParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterOptionalTypeApplicationLocalState.check_lower(value.app_local_state)
        _UniffiConverterOptionalTypeApplicationParams.check_lower(value.created_app)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterOptionalTypeApplicationLocalState.write(value.app_local_state, buf)
        _UniffiConverterOptionalTypeApplicationParams.write(value.created_app, buf)


class AccountAssetHolding:
    """
    AccountAssetHolding describes the account's asset holding and asset parameters (if either exist) for a specific asset ID.
    """

    asset_holding: "AssetHolding"
    asset_params: "typing.Optional[AssetParams]"
    def __init__(self, *, asset_holding: "AssetHolding", asset_params: "typing.Optional[AssetParams]"):
        self.asset_holding = asset_holding
        self.asset_params = asset_params

    def __str__(self):
        return "AccountAssetHolding(asset_holding={}, asset_params={})".format(self.asset_holding, self.asset_params)

    def __eq__(self, other):
        if self.asset_holding != other.asset_holding:
            return False
        if self.asset_params != other.asset_params:
            return False
        return True

class _UniffiConverterTypeAccountAssetHolding(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountAssetHolding(
            asset_holding=_UniffiConverterTypeAssetHolding.read(buf),
            asset_params=_UniffiConverterOptionalTypeAssetParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAssetHolding.check_lower(value.asset_holding)
        _UniffiConverterOptionalTypeAssetParams.check_lower(value.asset_params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAssetHolding.write(value.asset_holding, buf)
        _UniffiConverterOptionalTypeAssetParams.write(value.asset_params, buf)


class AccountAssetInformation:
    """
    AccountAssetResponse describes the account's asset holding and asset parameters (if either exist) for a specific asset ID. Asset parameters will only be returned if the provided address is the asset's creator.
    """

    round: "int"
    """
    The round for which this information is relevant.
    """

    asset_holding: "typing.Optional[AssetHolding]"
    created_asset: "typing.Optional[AssetParams]"
    def __init__(self, *, round: "int", asset_holding: "typing.Optional[AssetHolding]", created_asset: "typing.Optional[AssetParams]"):
        self.round = round
        self.asset_holding = asset_holding
        self.created_asset = created_asset

    def __str__(self):
        return "AccountAssetInformation(round={}, asset_holding={}, created_asset={})".format(self.round, self.asset_holding, self.created_asset)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        if self.asset_holding != other.asset_holding:
            return False
        if self.created_asset != other.created_asset:
            return False
        return True

class _UniffiConverterTypeAccountAssetInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountAssetInformation(
            round=_UniffiConverterUInt64.read(buf),
            asset_holding=_UniffiConverterOptionalTypeAssetHolding.read(buf),
            created_asset=_UniffiConverterOptionalTypeAssetParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterOptionalTypeAssetHolding.check_lower(value.asset_holding)
        _UniffiConverterOptionalTypeAssetParams.check_lower(value.created_asset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterOptionalTypeAssetHolding.write(value.asset_holding, buf)
        _UniffiConverterOptionalTypeAssetParams.write(value.created_asset, buf)


class AccountAssetsInformation:
    """
    AccountAssetsInformationResponse contains a list of assets held by an account.
    """

    round: "int"
    """
    The round for which this information is relevant.
    """

    next_token: "typing.Optional[str]"
    """
    Used for pagination, when making another request provide this token with the next parameter.
    """

    asset_holdings: "typing.Optional[typing.List[AccountAssetHolding]]"
    def __init__(self, *, round: "int", next_token: "typing.Optional[str]", asset_holdings: "typing.Optional[typing.List[AccountAssetHolding]]"):
        self.round = round
        self.next_token = next_token
        self.asset_holdings = asset_holdings

    def __str__(self):
        return "AccountAssetsInformation(round={}, next_token={}, asset_holdings={})".format(self.round, self.next_token, self.asset_holdings)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        if self.next_token != other.next_token:
            return False
        if self.asset_holdings != other.asset_holdings:
            return False
        return True

class _UniffiConverterTypeAccountAssetsInformation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountAssetsInformation(
            round=_UniffiConverterUInt64.read(buf),
            next_token=_UniffiConverterOptionalString.read(buf),
            asset_holdings=_UniffiConverterOptionalSequenceTypeAccountAssetHolding.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterOptionalString.check_lower(value.next_token)
        _UniffiConverterOptionalSequenceTypeAccountAssetHolding.check_lower(value.asset_holdings)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterOptionalString.write(value.next_token, buf)
        _UniffiConverterOptionalSequenceTypeAccountAssetHolding.write(value.asset_holdings, buf)


class AccountParticipation:
    """
    AccountParticipation describes the parameters used by this account in consensus protocol.
    """

    selection_participation_key: "bytes"
    """
    [sel] Selection public key (if any) currently registered for this round.
    """

    vote_first_valid: "int"
    """
    [voteFst] First round for which this participation is valid.
    """

    vote_key_dilution: "int"
    """
    [voteKD] Number of subkeys in each batch of participation keys.
    """

    vote_last_valid: "int"
    """
    [voteLst] Last round for which this participation is valid.
    """

    vote_participation_key: "bytes"
    """
    [vote] root participation public key (if any) currently registered for this round.
    """

    state_proof_key: "typing.Optional[bytes]"
    """
    [stprf] Root of the state proof key (if any)
    """

    def __init__(self, *, selection_participation_key: "bytes", vote_first_valid: "int", vote_key_dilution: "int", vote_last_valid: "int", vote_participation_key: "bytes", state_proof_key: "typing.Optional[bytes]"):
        self.selection_participation_key = selection_participation_key
        self.vote_first_valid = vote_first_valid
        self.vote_key_dilution = vote_key_dilution
        self.vote_last_valid = vote_last_valid
        self.vote_participation_key = vote_participation_key
        self.state_proof_key = state_proof_key

    def __str__(self):
        return "AccountParticipation(selection_participation_key={}, vote_first_valid={}, vote_key_dilution={}, vote_last_valid={}, vote_participation_key={}, state_proof_key={})".format(self.selection_participation_key, self.vote_first_valid, self.vote_key_dilution, self.vote_last_valid, self.vote_participation_key, self.state_proof_key)

    def __eq__(self, other):
        if self.selection_participation_key != other.selection_participation_key:
            return False
        if self.vote_first_valid != other.vote_first_valid:
            return False
        if self.vote_key_dilution != other.vote_key_dilution:
            return False
        if self.vote_last_valid != other.vote_last_valid:
            return False
        if self.vote_participation_key != other.vote_participation_key:
            return False
        if self.state_proof_key != other.state_proof_key:
            return False
        return True

class _UniffiConverterTypeAccountParticipation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountParticipation(
            selection_participation_key=_UniffiConverterBytes.read(buf),
            vote_first_valid=_UniffiConverterUInt64.read(buf),
            vote_key_dilution=_UniffiConverterUInt64.read(buf),
            vote_last_valid=_UniffiConverterUInt64.read(buf),
            vote_participation_key=_UniffiConverterBytes.read(buf),
            state_proof_key=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.selection_participation_key)
        _UniffiConverterUInt64.check_lower(value.vote_first_valid)
        _UniffiConverterUInt64.check_lower(value.vote_key_dilution)
        _UniffiConverterUInt64.check_lower(value.vote_last_valid)
        _UniffiConverterBytes.check_lower(value.vote_participation_key)
        _UniffiConverterOptionalBytes.check_lower(value.state_proof_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.selection_participation_key, buf)
        _UniffiConverterUInt64.write(value.vote_first_valid, buf)
        _UniffiConverterUInt64.write(value.vote_key_dilution, buf)
        _UniffiConverterUInt64.write(value.vote_last_valid, buf)
        _UniffiConverterBytes.write(value.vote_participation_key, buf)
        _UniffiConverterOptionalBytes.write(value.state_proof_key, buf)


class AccountStateDelta:
    """
    Application state delta.
    """

    address: "str"
    delta: "StateDelta"
    def __init__(self, *, address: "str", delta: "StateDelta"):
        self.address = address
        self.delta = delta

    def __str__(self):
        return "AccountStateDelta(address={}, delta={})".format(self.address, self.delta)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.delta != other.delta:
            return False
        return True

class _UniffiConverterTypeAccountStateDelta(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountStateDelta(
            address=_UniffiConverterString.read(buf),
            delta=_UniffiConverterTypeStateDelta.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterTypeStateDelta.check_lower(value.delta)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterTypeStateDelta.write(value.delta, buf)


class AddParticipationKey:
    """
    Participation ID of the submission
    """

    part_id: "str"
    """
    encoding of the participation ID.
    """

    def __init__(self, *, part_id: "str"):
        self.part_id = part_id

    def __str__(self):
        return "AddParticipationKey(part_id={})".format(self.part_id)

    def __eq__(self, other):
        if self.part_id != other.part_id:
            return False
        return True

class _UniffiConverterTypeAddParticipationKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddParticipationKey(
            part_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.part_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.part_id, buf)


class AppCallLogs:
    """
    The logged messages from an app call along with the app ID and outer transaction ID. Logs appear in the same order that they were emitted.
    """

    logs: "typing.List[bytes]"
    """
    An array of logs
    """

    app_id: "int"
    """
    The application from which the logs were generated
    """

    tx_id: "str"
    """
    The transaction ID of the outer app call that lead to these logs
    """

    def __init__(self, *, logs: "typing.List[bytes]", app_id: "int", tx_id: "str"):
        self.logs = logs
        self.app_id = app_id
        self.tx_id = tx_id

    def __str__(self):
        return "AppCallLogs(logs={}, app_id={}, tx_id={})".format(self.logs, self.app_id, self.tx_id)

    def __eq__(self, other):
        if self.logs != other.logs:
            return False
        if self.app_id != other.app_id:
            return False
        if self.tx_id != other.tx_id:
            return False
        return True

class _UniffiConverterTypeAppCallLogs(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppCallLogs(
            logs=_UniffiConverterSequenceBytes.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            tx_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceBytes.check_lower(value.logs)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterString.check_lower(value.tx_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceBytes.write(value.logs, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterString.write(value.tx_id, buf)


class Application:
    """
    Application index and its parameters
    """

    id: "int"
    """
    [appidx] application index.
    """

    params: "ApplicationParams"
    def __init__(self, *, id: "int", params: "ApplicationParams"):
        self.id = id
        self.params = params

    def __str__(self):
        return "Application(id={}, params={})".format(self.id, self.params)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.params != other.params:
            return False
        return True

class _UniffiConverterTypeApplication(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Application(
            id=_UniffiConverterUInt64.read(buf),
            params=_UniffiConverterTypeApplicationParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterTypeApplicationParams.check_lower(value.params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeApplicationParams.write(value.params, buf)


class ApplicationInitialStates:
    """
    An application's initial global/local/box states that were accessed during simulation.
    """

    id: "int"
    """
    Application index.
    """

    app_locals: "typing.Optional[typing.List[ApplicationKvStorage]]"
    """
    An application's initial local states tied to different accounts.
    """

    app_globals: "typing.Optional[ApplicationKvStorage]"
    app_boxes: "typing.Optional[ApplicationKvStorage]"
    def __init__(self, *, id: "int", app_locals: "typing.Optional[typing.List[ApplicationKvStorage]]", app_globals: "typing.Optional[ApplicationKvStorage]", app_boxes: "typing.Optional[ApplicationKvStorage]"):
        self.id = id
        self.app_locals = app_locals
        self.app_globals = app_globals
        self.app_boxes = app_boxes

    def __str__(self):
        return "ApplicationInitialStates(id={}, app_locals={}, app_globals={}, app_boxes={})".format(self.id, self.app_locals, self.app_globals, self.app_boxes)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.app_locals != other.app_locals:
            return False
        if self.app_globals != other.app_globals:
            return False
        if self.app_boxes != other.app_boxes:
            return False
        return True

class _UniffiConverterTypeApplicationInitialStates(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationInitialStates(
            id=_UniffiConverterUInt64.read(buf),
            app_locals=_UniffiConverterOptionalSequenceTypeApplicationKvStorage.read(buf),
            app_globals=_UniffiConverterOptionalTypeApplicationKvStorage.read(buf),
            app_boxes=_UniffiConverterOptionalTypeApplicationKvStorage.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterOptionalSequenceTypeApplicationKvStorage.check_lower(value.app_locals)
        _UniffiConverterOptionalTypeApplicationKvStorage.check_lower(value.app_globals)
        _UniffiConverterOptionalTypeApplicationKvStorage.check_lower(value.app_boxes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterOptionalSequenceTypeApplicationKvStorage.write(value.app_locals, buf)
        _UniffiConverterOptionalTypeApplicationKvStorage.write(value.app_globals, buf)
        _UniffiConverterOptionalTypeApplicationKvStorage.write(value.app_boxes, buf)


class ApplicationKvStorage:
    """
    An application's global/local/box state.
    """

    kvs: "typing.List[AvmKeyValue]"
    """
    Key-Value pairs representing application states.
    """

    account: "typing.Optional[str]"
    """
    The address of the account associated with the local state.
    """

    def __init__(self, *, kvs: "typing.List[AvmKeyValue]", account: "typing.Optional[str]"):
        self.kvs = kvs
        self.account = account

    def __str__(self):
        return "ApplicationKvStorage(kvs={}, account={})".format(self.kvs, self.account)

    def __eq__(self, other):
        if self.kvs != other.kvs:
            return False
        if self.account != other.account:
            return False
        return True

class _UniffiConverterTypeApplicationKvStorage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationKvStorage(
            kvs=_UniffiConverterSequenceTypeAvmKeyValue.read(buf),
            account=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeAvmKeyValue.check_lower(value.kvs)
        _UniffiConverterOptionalString.check_lower(value.account)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeAvmKeyValue.write(value.kvs, buf)
        _UniffiConverterOptionalString.write(value.account, buf)


class ApplicationLocalReference:
    """
    References an account's local state for an application.
    """

    account: "str"
    """
    Address of the account with the local state.
    """

    app: "int"
    """
    Application ID of the local state application.
    """

    def __init__(self, *, account: "str", app: "int"):
        self.account = account
        self.app = app

    def __str__(self):
        return "ApplicationLocalReference(account={}, app={})".format(self.account, self.app)

    def __eq__(self, other):
        if self.account != other.account:
            return False
        if self.app != other.app:
            return False
        return True

class _UniffiConverterTypeApplicationLocalReference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationLocalReference(
            account=_UniffiConverterString.read(buf),
            app=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.account)
        _UniffiConverterUInt64.check_lower(value.app)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.account, buf)
        _UniffiConverterUInt64.write(value.app, buf)


class ApplicationLocalState:
    """
    Stores local state associated with an application.
    """

    id: "int"
    """
    The application which this local state is for.
    """

    schema: "ApplicationStateSchema"
    key_value: "typing.Optional[TealKeyValueStore]"
    def __init__(self, *, id: "int", schema: "ApplicationStateSchema", key_value: "typing.Optional[TealKeyValueStore]"):
        self.id = id
        self.schema = schema
        self.key_value = key_value

    def __str__(self):
        return "ApplicationLocalState(id={}, schema={}, key_value={})".format(self.id, self.schema, self.key_value)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.schema != other.schema:
            return False
        if self.key_value != other.key_value:
            return False
        return True

class _UniffiConverterTypeApplicationLocalState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationLocalState(
            id=_UniffiConverterUInt64.read(buf),
            schema=_UniffiConverterTypeApplicationStateSchema.read(buf),
            key_value=_UniffiConverterOptionalTypeTealKeyValueStore.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.id)
        _UniffiConverterTypeApplicationStateSchema.check_lower(value.schema)
        _UniffiConverterOptionalTypeTealKeyValueStore.check_lower(value.key_value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.id, buf)
        _UniffiConverterTypeApplicationStateSchema.write(value.schema, buf)
        _UniffiConverterOptionalTypeTealKeyValueStore.write(value.key_value, buf)


class ApplicationParams:
    """
    Stores the global information associated with an application.
    """

    creator: "str"
    """
    The address that created this application. This is the address where the parameters and global state for this application can be found.
    """

    approval_program: "bytes"
    """
    [approv] approval program.
    """

    clear_state_program: "bytes"
    """
    [clearp] approval program.
    """

    extra_program_pages: "typing.Optional[int]"
    """
    [epp] the amount of extra program pages available to this app.
    """

    local_state_schema: "typing.Optional[ApplicationStateSchema]"
    global_state_schema: "typing.Optional[ApplicationStateSchema]"
    global_state: "typing.Optional[TealKeyValueStore]"
    version: "typing.Optional[int]"
    """
    [v] the number of updates to the application programs
    """

    def __init__(self, *, creator: "str", approval_program: "bytes", clear_state_program: "bytes", extra_program_pages: "typing.Optional[int]", local_state_schema: "typing.Optional[ApplicationStateSchema]", global_state_schema: "typing.Optional[ApplicationStateSchema]", global_state: "typing.Optional[TealKeyValueStore]", version: "typing.Optional[int]"):
        self.creator = creator
        self.approval_program = approval_program
        self.clear_state_program = clear_state_program
        self.extra_program_pages = extra_program_pages
        self.local_state_schema = local_state_schema
        self.global_state_schema = global_state_schema
        self.global_state = global_state
        self.version = version

    def __str__(self):
        return "ApplicationParams(creator={}, approval_program={}, clear_state_program={}, extra_program_pages={}, local_state_schema={}, global_state_schema={}, global_state={}, version={})".format(self.creator, self.approval_program, self.clear_state_program, self.extra_program_pages, self.local_state_schema, self.global_state_schema, self.global_state, self.version)

    def __eq__(self, other):
        if self.creator != other.creator:
            return False
        if self.approval_program != other.approval_program:
            return False
        if self.clear_state_program != other.clear_state_program:
            return False
        if self.extra_program_pages != other.extra_program_pages:
            return False
        if self.local_state_schema != other.local_state_schema:
            return False
        if self.global_state_schema != other.global_state_schema:
            return False
        if self.global_state != other.global_state:
            return False
        if self.version != other.version:
            return False
        return True

class _UniffiConverterTypeApplicationParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationParams(
            creator=_UniffiConverterString.read(buf),
            approval_program=_UniffiConverterBytes.read(buf),
            clear_state_program=_UniffiConverterBytes.read(buf),
            extra_program_pages=_UniffiConverterOptionalUInt32.read(buf),
            local_state_schema=_UniffiConverterOptionalTypeApplicationStateSchema.read(buf),
            global_state_schema=_UniffiConverterOptionalTypeApplicationStateSchema.read(buf),
            global_state=_UniffiConverterOptionalTypeTealKeyValueStore.read(buf),
            version=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.creator)
        _UniffiConverterBytes.check_lower(value.approval_program)
        _UniffiConverterBytes.check_lower(value.clear_state_program)
        _UniffiConverterOptionalUInt32.check_lower(value.extra_program_pages)
        _UniffiConverterOptionalTypeApplicationStateSchema.check_lower(value.local_state_schema)
        _UniffiConverterOptionalTypeApplicationStateSchema.check_lower(value.global_state_schema)
        _UniffiConverterOptionalTypeTealKeyValueStore.check_lower(value.global_state)
        _UniffiConverterOptionalUInt64.check_lower(value.version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.creator, buf)
        _UniffiConverterBytes.write(value.approval_program, buf)
        _UniffiConverterBytes.write(value.clear_state_program, buf)
        _UniffiConverterOptionalUInt32.write(value.extra_program_pages, buf)
        _UniffiConverterOptionalTypeApplicationStateSchema.write(value.local_state_schema, buf)
        _UniffiConverterOptionalTypeApplicationStateSchema.write(value.global_state_schema, buf)
        _UniffiConverterOptionalTypeTealKeyValueStore.write(value.global_state, buf)
        _UniffiConverterOptionalUInt64.write(value.version, buf)


class ApplicationStateOperation:
    """
    An operation against an application's global/local/box state.
    """

    operation: "str"
    """
    Operation type. Value `w` is **write**, `d` is **delete**.
    """

    app_state_type: "str"
    """
    Type of application state. Value `g` is **global state**, `l` is **local state**, `b` is **boxes**.
    """

    key: "bytes"
    """
    The key (name) of the global/local/box state.
    """

    new_value: "typing.Optional[AvmValue]"
    account: "typing.Optional[str]"
    """
    For local state changes, the address of the account associated with the local state.
    """

    def __init__(self, *, operation: "str", app_state_type: "str", key: "bytes", new_value: "typing.Optional[AvmValue]", account: "typing.Optional[str]"):
        self.operation = operation
        self.app_state_type = app_state_type
        self.key = key
        self.new_value = new_value
        self.account = account

    def __str__(self):
        return "ApplicationStateOperation(operation={}, app_state_type={}, key={}, new_value={}, account={})".format(self.operation, self.app_state_type, self.key, self.new_value, self.account)

    def __eq__(self, other):
        if self.operation != other.operation:
            return False
        if self.app_state_type != other.app_state_type:
            return False
        if self.key != other.key:
            return False
        if self.new_value != other.new_value:
            return False
        if self.account != other.account:
            return False
        return True

class _UniffiConverterTypeApplicationStateOperation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationStateOperation(
            operation=_UniffiConverterString.read(buf),
            app_state_type=_UniffiConverterString.read(buf),
            key=_UniffiConverterBytes.read(buf),
            new_value=_UniffiConverterOptionalTypeAvmValue.read(buf),
            account=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.operation)
        _UniffiConverterString.check_lower(value.app_state_type)
        _UniffiConverterBytes.check_lower(value.key)
        _UniffiConverterOptionalTypeAvmValue.check_lower(value.new_value)
        _UniffiConverterOptionalString.check_lower(value.account)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.operation, buf)
        _UniffiConverterString.write(value.app_state_type, buf)
        _UniffiConverterBytes.write(value.key, buf)
        _UniffiConverterOptionalTypeAvmValue.write(value.new_value, buf)
        _UniffiConverterOptionalString.write(value.account, buf)


class ApplicationStateSchema:
    """
    Specifies maximums on the number of each type that may be stored.
    """

    num_uint: "int"
    """
    [nui] num of uints.
    """

    num_byte_slice: "int"
    """
    [nbs] num of byte slices.
    """

    def __init__(self, *, num_uint: "int", num_byte_slice: "int"):
        self.num_uint = num_uint
        self.num_byte_slice = num_byte_slice

    def __str__(self):
        return "ApplicationStateSchema(num_uint={}, num_byte_slice={})".format(self.num_uint, self.num_byte_slice)

    def __eq__(self, other):
        if self.num_uint != other.num_uint:
            return False
        if self.num_byte_slice != other.num_byte_slice:
            return False
        return True

class _UniffiConverterTypeApplicationStateSchema(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApplicationStateSchema(
            num_uint=_UniffiConverterUInt32.read(buf),
            num_byte_slice=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.num_uint)
        _UniffiConverterUInt32.check_lower(value.num_byte_slice)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.num_uint, buf)
        _UniffiConverterUInt32.write(value.num_byte_slice, buf)


class Asset:
    """
    Specifies both the unique identifier and the parameters for an asset
    """

    index: "int"
    """
    unique asset identifier
    """

    params: "AssetParams"
    def __init__(self, *, index: "int", params: "AssetParams"):
        self.index = index
        self.params = params

    def __str__(self):
        return "Asset(index={}, params={})".format(self.index, self.params)

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.params != other.params:
            return False
        return True

class _UniffiConverterTypeAsset(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Asset(
            index=_UniffiConverterUInt64.read(buf),
            params=_UniffiConverterTypeAssetParams.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.index)
        _UniffiConverterTypeAssetParams.check_lower(value.params)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.index, buf)
        _UniffiConverterTypeAssetParams.write(value.params, buf)


class AssetHolding:
    """
    Describes an asset held by an account.

    Definition:
    data/basics/userBalance.go : AssetHolding
    """

    amount: "int"
    """
    [a] number of units held.
    """

    asset_id: "int"
    """
    Asset ID of the holding.
    """

    is_frozen: "bool"
    """
    [f] whether or not the holding is frozen.
    """

    def __init__(self, *, amount: "int", asset_id: "int", is_frozen: "bool"):
        self.amount = amount
        self.asset_id = asset_id
        self.is_frozen = is_frozen

    def __str__(self):
        return "AssetHolding(amount={}, asset_id={}, is_frozen={})".format(self.amount, self.asset_id, self.is_frozen)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.is_frozen != other.is_frozen:
            return False
        return True

class _UniffiConverterTypeAssetHolding(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetHolding(
            amount=_UniffiConverterUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            is_frozen=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterBool.check_lower(value.is_frozen)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterBool.write(value.is_frozen, buf)


class AssetHoldingReference:
    """
    References an asset held by an account.
    """

    account: "str"
    """
    Address of the account holding the asset.
    """

    asset: "int"
    """
    Asset ID of the holding.
    """

    def __init__(self, *, account: "str", asset: "int"):
        self.account = account
        self.asset = asset

    def __str__(self):
        return "AssetHoldingReference(account={}, asset={})".format(self.account, self.asset)

    def __eq__(self, other):
        if self.account != other.account:
            return False
        if self.asset != other.asset:
            return False
        return True

class _UniffiConverterTypeAssetHoldingReference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetHoldingReference(
            account=_UniffiConverterString.read(buf),
            asset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.account)
        _UniffiConverterUInt64.check_lower(value.asset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.account, buf)
        _UniffiConverterUInt64.write(value.asset, buf)


class AssetParams:
    """
    AssetParams specifies the parameters for an asset.

    [apar] when part of an AssetConfig transaction.

    Definition:
    data/transactions/asset.go : AssetParams
    """

    clawback: "typing.Optional[str]"
    """
    [c] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.
    """

    creator: "str"
    """
    The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.
    """

    decimals: "int"
    """
    [dc] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).
    """

    default_frozen: "typing.Optional[bool]"
    """
    [df] Whether holdings of this asset are frozen by default.
    """

    freeze: "typing.Optional[str]"
    """
    [f] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.
    """

    manager: "typing.Optional[str]"
    """
    [m] Address of account used to manage the keys of this asset and to destroy it.
    """

    metadata_hash: "typing.Optional[bytes]"
    """
    [am] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.
    """

    name: "typing.Optional[str]"
    """
    [an] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.
    """

    name_b64: "typing.Optional[bytes]"
    """
    Base64 encoded name of this asset, as supplied by the creator.
    """

    reserve: "typing.Optional[str]"
    """
    [r] Address of account holding reserve (non-minted) units of this asset.
    """

    total: "int"
    """
    [t] The total number of units of this asset.
    """

    unit_name: "typing.Optional[str]"
    """
    [un] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.
    """

    unit_name_b64: "typing.Optional[bytes]"
    """
    Base64 encoded name of a unit of this asset, as supplied by the creator.
    """

    url: "typing.Optional[str]"
    """
    [au] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.
    """

    url_b64: "typing.Optional[bytes]"
    """
    Base64 encoded URL where more information about the asset can be retrieved.
    """

    def __init__(self, *, clawback: "typing.Optional[str]", creator: "str", decimals: "int", default_frozen: "typing.Optional[bool]", freeze: "typing.Optional[str]", manager: "typing.Optional[str]", metadata_hash: "typing.Optional[bytes]", name: "typing.Optional[str]", name_b64: "typing.Optional[bytes]", reserve: "typing.Optional[str]", total: "int", unit_name: "typing.Optional[str]", unit_name_b64: "typing.Optional[bytes]", url: "typing.Optional[str]", url_b64: "typing.Optional[bytes]"):
        self.clawback = clawback
        self.creator = creator
        self.decimals = decimals
        self.default_frozen = default_frozen
        self.freeze = freeze
        self.manager = manager
        self.metadata_hash = metadata_hash
        self.name = name
        self.name_b64 = name_b64
        self.reserve = reserve
        self.total = total
        self.unit_name = unit_name
        self.unit_name_b64 = unit_name_b64
        self.url = url
        self.url_b64 = url_b64

    def __str__(self):
        return "AssetParams(clawback={}, creator={}, decimals={}, default_frozen={}, freeze={}, manager={}, metadata_hash={}, name={}, name_b64={}, reserve={}, total={}, unit_name={}, unit_name_b64={}, url={}, url_b64={})".format(self.clawback, self.creator, self.decimals, self.default_frozen, self.freeze, self.manager, self.metadata_hash, self.name, self.name_b64, self.reserve, self.total, self.unit_name, self.unit_name_b64, self.url, self.url_b64)

    def __eq__(self, other):
        if self.clawback != other.clawback:
            return False
        if self.creator != other.creator:
            return False
        if self.decimals != other.decimals:
            return False
        if self.default_frozen != other.default_frozen:
            return False
        if self.freeze != other.freeze:
            return False
        if self.manager != other.manager:
            return False
        if self.metadata_hash != other.metadata_hash:
            return False
        if self.name != other.name:
            return False
        if self.name_b64 != other.name_b64:
            return False
        if self.reserve != other.reserve:
            return False
        if self.total != other.total:
            return False
        if self.unit_name != other.unit_name:
            return False
        if self.unit_name_b64 != other.unit_name_b64:
            return False
        if self.url != other.url:
            return False
        if self.url_b64 != other.url_b64:
            return False
        return True

class _UniffiConverterTypeAssetParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetParams(
            clawback=_UniffiConverterOptionalString.read(buf),
            creator=_UniffiConverterString.read(buf),
            decimals=_UniffiConverterUInt64.read(buf),
            default_frozen=_UniffiConverterOptionalBool.read(buf),
            freeze=_UniffiConverterOptionalString.read(buf),
            manager=_UniffiConverterOptionalString.read(buf),
            metadata_hash=_UniffiConverterOptionalBytes.read(buf),
            name=_UniffiConverterOptionalString.read(buf),
            name_b64=_UniffiConverterOptionalBytes.read(buf),
            reserve=_UniffiConverterOptionalString.read(buf),
            total=_UniffiConverterUInt64.read(buf),
            unit_name=_UniffiConverterOptionalString.read(buf),
            unit_name_b64=_UniffiConverterOptionalBytes.read(buf),
            url=_UniffiConverterOptionalString.read(buf),
            url_b64=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.clawback)
        _UniffiConverterString.check_lower(value.creator)
        _UniffiConverterUInt64.check_lower(value.decimals)
        _UniffiConverterOptionalBool.check_lower(value.default_frozen)
        _UniffiConverterOptionalString.check_lower(value.freeze)
        _UniffiConverterOptionalString.check_lower(value.manager)
        _UniffiConverterOptionalBytes.check_lower(value.metadata_hash)
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalBytes.check_lower(value.name_b64)
        _UniffiConverterOptionalString.check_lower(value.reserve)
        _UniffiConverterUInt64.check_lower(value.total)
        _UniffiConverterOptionalString.check_lower(value.unit_name)
        _UniffiConverterOptionalBytes.check_lower(value.unit_name_b64)
        _UniffiConverterOptionalString.check_lower(value.url)
        _UniffiConverterOptionalBytes.check_lower(value.url_b64)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.clawback, buf)
        _UniffiConverterString.write(value.creator, buf)
        _UniffiConverterUInt64.write(value.decimals, buf)
        _UniffiConverterOptionalBool.write(value.default_frozen, buf)
        _UniffiConverterOptionalString.write(value.freeze, buf)
        _UniffiConverterOptionalString.write(value.manager, buf)
        _UniffiConverterOptionalBytes.write(value.metadata_hash, buf)
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalBytes.write(value.name_b64, buf)
        _UniffiConverterOptionalString.write(value.reserve, buf)
        _UniffiConverterUInt64.write(value.total, buf)
        _UniffiConverterOptionalString.write(value.unit_name, buf)
        _UniffiConverterOptionalBytes.write(value.unit_name_b64, buf)
        _UniffiConverterOptionalString.write(value.url, buf)
        _UniffiConverterOptionalBytes.write(value.url_b64, buf)


class AvmKeyValue:
    """
    Represents an AVM key-value pair in an application store.
    """

    key: "bytes"
    value: "AvmValue"
    def __init__(self, *, key: "bytes", value: "AvmValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "AvmKeyValue(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeAvmKeyValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AvmKeyValue(
            key=_UniffiConverterBytes.read(buf),
            value=_UniffiConverterTypeAvmValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.key)
        _UniffiConverterTypeAvmValue.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.key, buf)
        _UniffiConverterTypeAvmValue.write(value.value, buf)


class AvmValue:
    """
    Represents an AVM value.
    """

    type: "int"
    """
    value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
    """

    bytes: "typing.Optional[str]"
    """
    bytes value.
    """

    uint: "typing.Optional[int]"
    """
    uint value.
    """

    def __init__(self, *, type: "int", bytes: "typing.Optional[str]", uint: "typing.Optional[int]"):
        self.type = type
        self.bytes = bytes
        self.uint = uint

    def __str__(self):
        return "AvmValue(type={}, bytes={}, uint={})".format(self.type, self.bytes, self.uint)

    def __eq__(self, other):
        if self.type != other.type:
            return False
        if self.bytes != other.bytes:
            return False
        if self.uint != other.uint:
            return False
        return True

class _UniffiConverterTypeAvmValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AvmValue(
            type=_UniffiConverterUInt64.read(buf),
            bytes=_UniffiConverterOptionalString.read(buf),
            uint=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.type)
        _UniffiConverterOptionalString.check_lower(value.bytes)
        _UniffiConverterOptionalUInt64.check_lower(value.uint)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.type, buf)
        _UniffiConverterOptionalString.write(value.bytes, buf)
        _UniffiConverterOptionalUInt64.write(value.uint, buf)


class Box:
    """
    Box name and its content.
    """

    round: "int"
    """
    The round for which this information is relevant
    """

    name: "bytes"
    """
    The box name, base64 encoded
    """

    value: "bytes"
    """
    The box value, base64 encoded.
    """

    def __init__(self, *, round: "int", name: "bytes", value: "bytes"):
        self.round = round
        self.name = name
        self.value = value

    def __str__(self):
        return "Box(round={}, name={}, value={})".format(self.round, self.name, self.value)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        if self.name != other.name:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeBox(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Box(
            round=_UniffiConverterUInt64.read(buf),
            name=_UniffiConverterBytes.read(buf),
            value=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterBytes.check_lower(value.name)
        _UniffiConverterBytes.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterBytes.write(value.name, buf)
        _UniffiConverterBytes.write(value.value, buf)


class BoxDescriptor:
    """
    Box descriptor describes a Box.
    """

    name: "bytes"
    """
    Base64 encoded box name
    """

    def __init__(self, *, name: "bytes"):
        self.name = name

    def __str__(self):
        return "BoxDescriptor(name={})".format(self.name)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeBoxDescriptor(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BoxDescriptor(
            name=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.name, buf)


class BoxReference:
    """
    References a box of an application.
    """

    app: "int"
    """
    Application ID which this box belongs to
    """

    name: "bytes"
    """
    Base64 encoded box name
    """

    def __init__(self, *, app: "int", name: "bytes"):
        self.app = app
        self.name = name

    def __str__(self):
        return "BoxReference(app={}, name={})".format(self.app, self.name)

    def __eq__(self, other):
        if self.app != other.app:
            return False
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeBoxReference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BoxReference(
            app=_UniffiConverterUInt64.read(buf),
            name=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.app)
        _UniffiConverterBytes.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.app, buf)
        _UniffiConverterBytes.write(value.name, buf)


class BuildVersion:
    branch: "str"
    build_number: "int"
    channel: "str"
    commit_hash: "str"
    major: "int"
    minor: "int"
    def __init__(self, *, branch: "str", build_number: "int", channel: "str", commit_hash: "str", major: "int", minor: "int"):
        self.branch = branch
        self.build_number = build_number
        self.channel = channel
        self.commit_hash = commit_hash
        self.major = major
        self.minor = minor

    def __str__(self):
        return "BuildVersion(branch={}, build_number={}, channel={}, commit_hash={}, major={}, minor={})".format(self.branch, self.build_number, self.channel, self.commit_hash, self.major, self.minor)

    def __eq__(self, other):
        if self.branch != other.branch:
            return False
        if self.build_number != other.build_number:
            return False
        if self.channel != other.channel:
            return False
        if self.commit_hash != other.commit_hash:
            return False
        if self.major != other.major:
            return False
        if self.minor != other.minor:
            return False
        return True

class _UniffiConverterTypeBuildVersion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BuildVersion(
            branch=_UniffiConverterString.read(buf),
            build_number=_UniffiConverterUInt64.read(buf),
            channel=_UniffiConverterString.read(buf),
            commit_hash=_UniffiConverterString.read(buf),
            major=_UniffiConverterUInt64.read(buf),
            minor=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.branch)
        _UniffiConverterUInt64.check_lower(value.build_number)
        _UniffiConverterString.check_lower(value.channel)
        _UniffiConverterString.check_lower(value.commit_hash)
        _UniffiConverterUInt64.check_lower(value.major)
        _UniffiConverterUInt64.check_lower(value.minor)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.branch, buf)
        _UniffiConverterUInt64.write(value.build_number, buf)
        _UniffiConverterString.write(value.channel, buf)
        _UniffiConverterString.write(value.commit_hash, buf)
        _UniffiConverterUInt64.write(value.major, buf)
        _UniffiConverterUInt64.write(value.minor, buf)


class DebugSettingsProf:
    """
    algod mutex and blocking profiling state.
    """

    block_rate: "typing.Optional[int]"
    """
    The rate of blocking events. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked. To turn off profiling entirely, pass rate 0.
    """

    mutex_rate: "typing.Optional[int]"
    """
    The rate of mutex events. On average 1/rate events are reported. To turn off profiling entirely, pass rate 0
    """

    def __init__(self, *, block_rate: "typing.Optional[int]", mutex_rate: "typing.Optional[int]"):
        self.block_rate = block_rate
        self.mutex_rate = mutex_rate

    def __str__(self):
        return "DebugSettingsProf(block_rate={}, mutex_rate={})".format(self.block_rate, self.mutex_rate)

    def __eq__(self, other):
        if self.block_rate != other.block_rate:
            return False
        if self.mutex_rate != other.mutex_rate:
            return False
        return True

class _UniffiConverterTypeDebugSettingsProf(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DebugSettingsProf(
            block_rate=_UniffiConverterOptionalUInt64.read(buf),
            mutex_rate=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.block_rate)
        _UniffiConverterOptionalUInt64.check_lower(value.mutex_rate)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.block_rate, buf)
        _UniffiConverterOptionalUInt64.write(value.mutex_rate, buf)


class DryrunRequest:
    """
    Request data type for dryrun endpoint. Given the Transactions and simulated ledger state upload, run TEAL scripts and return debugging information.
    """

    txns: "typing.List[SignedTransaction]"
    accounts: "typing.List[Account]"
    apps: "typing.List[Application]"
    protocol_version: "str"
    """
    ProtocolVersion specifies a specific version string to operate under, otherwise whatever the current protocol of the network this algod is running in.
    """

    round: "int"
    """
    Round is available to some TEAL scripts. Defaults to the current round on the network this algod is attached to.
    """

    latest_timestamp: "int"
    """
    LatestTimestamp is available to some TEAL scripts. Defaults to the latest confirmed timestamp this algod is attached to.
    """

    sources: "typing.List[DryrunSource]"
    def __init__(self, *, txns: "typing.List[SignedTransaction]", accounts: "typing.List[Account]", apps: "typing.List[Application]", protocol_version: "str", round: "int", latest_timestamp: "int", sources: "typing.List[DryrunSource]"):
        self.txns = txns
        self.accounts = accounts
        self.apps = apps
        self.protocol_version = protocol_version
        self.round = round
        self.latest_timestamp = latest_timestamp
        self.sources = sources

    def __str__(self):
        return "DryrunRequest(txns={}, accounts={}, apps={}, protocol_version={}, round={}, latest_timestamp={}, sources={})".format(self.txns, self.accounts, self.apps, self.protocol_version, self.round, self.latest_timestamp, self.sources)

    def __eq__(self, other):
        if self.txns != other.txns:
            return False
        if self.accounts != other.accounts:
            return False
        if self.apps != other.apps:
            return False
        if self.protocol_version != other.protocol_version:
            return False
        if self.round != other.round:
            return False
        if self.latest_timestamp != other.latest_timestamp:
            return False
        if self.sources != other.sources:
            return False
        return True

class _UniffiConverterTypeDryrunRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryrunRequest(
            txns=_UniffiConverterSequenceTypeSignedTransaction.read(buf),
            accounts=_UniffiConverterSequenceTypeAccount.read(buf),
            apps=_UniffiConverterSequenceTypeApplication.read(buf),
            protocol_version=_UniffiConverterString.read(buf),
            round=_UniffiConverterUInt64.read(buf),
            latest_timestamp=_UniffiConverterUInt64.read(buf),
            sources=_UniffiConverterSequenceTypeDryrunSource.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeSignedTransaction.check_lower(value.txns)
        _UniffiConverterSequenceTypeAccount.check_lower(value.accounts)
        _UniffiConverterSequenceTypeApplication.check_lower(value.apps)
        _UniffiConverterString.check_lower(value.protocol_version)
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterUInt64.check_lower(value.latest_timestamp)
        _UniffiConverterSequenceTypeDryrunSource.check_lower(value.sources)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeSignedTransaction.write(value.txns, buf)
        _UniffiConverterSequenceTypeAccount.write(value.accounts, buf)
        _UniffiConverterSequenceTypeApplication.write(value.apps, buf)
        _UniffiConverterString.write(value.protocol_version, buf)
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterUInt64.write(value.latest_timestamp, buf)
        _UniffiConverterSequenceTypeDryrunSource.write(value.sources, buf)


class DryrunSource:
    """
    DryrunSource is TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.
    """

    field_name: "str"
    """
    FieldName is what kind of sources this is. If lsig then it goes into the transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the Approval Program or Clear State Program of application[this.AppIndex].
    """

    source: "str"
    txn_index: "int"
    app_index: "int"
    def __init__(self, *, field_name: "str", source: "str", txn_index: "int", app_index: "int"):
        self.field_name = field_name
        self.source = source
        self.txn_index = txn_index
        self.app_index = app_index

    def __str__(self):
        return "DryrunSource(field_name={}, source={}, txn_index={}, app_index={})".format(self.field_name, self.source, self.txn_index, self.app_index)

    def __eq__(self, other):
        if self.field_name != other.field_name:
            return False
        if self.source != other.source:
            return False
        if self.txn_index != other.txn_index:
            return False
        if self.app_index != other.app_index:
            return False
        return True

class _UniffiConverterTypeDryrunSource(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryrunSource(
            field_name=_UniffiConverterString.read(buf),
            source=_UniffiConverterString.read(buf),
            txn_index=_UniffiConverterUInt64.read(buf),
            app_index=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.field_name)
        _UniffiConverterString.check_lower(value.source)
        _UniffiConverterUInt64.check_lower(value.txn_index)
        _UniffiConverterUInt64.check_lower(value.app_index)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.field_name, buf)
        _UniffiConverterString.write(value.source, buf)
        _UniffiConverterUInt64.write(value.txn_index, buf)
        _UniffiConverterUInt64.write(value.app_index, buf)


class DryrunState:
    """
    Stores the TEAL eval step data
    """

    line: "int"
    """
    Line number
    """

    pc: "int"
    """
    Program counter
    """

    stack: "typing.List[TealValue]"
    scratch: "typing.Optional[typing.List[TealValue]]"
    error: "typing.Optional[str]"
    """
    Evaluation error if any
    """

    def __init__(self, *, line: "int", pc: "int", stack: "typing.List[TealValue]", scratch: "typing.Optional[typing.List[TealValue]]", error: "typing.Optional[str]"):
        self.line = line
        self.pc = pc
        self.stack = stack
        self.scratch = scratch
        self.error = error

    def __str__(self):
        return "DryrunState(line={}, pc={}, stack={}, scratch={}, error={})".format(self.line, self.pc, self.stack, self.scratch, self.error)

    def __eq__(self, other):
        if self.line != other.line:
            return False
        if self.pc != other.pc:
            return False
        if self.stack != other.stack:
            return False
        if self.scratch != other.scratch:
            return False
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeDryrunState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryrunState(
            line=_UniffiConverterUInt64.read(buf),
            pc=_UniffiConverterUInt64.read(buf),
            stack=_UniffiConverterSequenceTypeTealValue.read(buf),
            scratch=_UniffiConverterOptionalSequenceTypeTealValue.read(buf),
            error=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.line)
        _UniffiConverterUInt64.check_lower(value.pc)
        _UniffiConverterSequenceTypeTealValue.check_lower(value.stack)
        _UniffiConverterOptionalSequenceTypeTealValue.check_lower(value.scratch)
        _UniffiConverterOptionalString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.line, buf)
        _UniffiConverterUInt64.write(value.pc, buf)
        _UniffiConverterSequenceTypeTealValue.write(value.stack, buf)
        _UniffiConverterOptionalSequenceTypeTealValue.write(value.scratch, buf)
        _UniffiConverterOptionalString.write(value.error, buf)


class DryrunTxnResult:
    """
    DryrunTxnResult contains any LogicSig or ApplicationCall program debug information and state updates from a dryrun.
    """

    disassembly: "typing.List[str]"
    """
    Disassembled program line by line.
    """

    logic_sig_disassembly: "typing.Optional[typing.List[str]]"
    """
    Disassembled lsig program line by line.
    """

    logic_sig_trace: "typing.Optional[typing.List[DryrunState]]"
    logic_sig_messages: "typing.Optional[typing.List[str]]"
    app_call_trace: "typing.Optional[typing.List[DryrunState]]"
    app_call_messages: "typing.Optional[typing.List[str]]"
    global_delta: "typing.Optional[StateDelta]"
    local_deltas: "typing.Optional[typing.List[AccountStateDelta]]"
    logs: "typing.Optional[typing.List[bytes]]"
    budget_added: "typing.Optional[int]"
    """
    Budget added during execution of app call transaction.
    """

    budget_consumed: "typing.Optional[int]"
    """
    Budget consumed during execution of app call transaction.
    """

    def __init__(self, *, disassembly: "typing.List[str]", logic_sig_disassembly: "typing.Optional[typing.List[str]]", logic_sig_trace: "typing.Optional[typing.List[DryrunState]]", logic_sig_messages: "typing.Optional[typing.List[str]]", app_call_trace: "typing.Optional[typing.List[DryrunState]]", app_call_messages: "typing.Optional[typing.List[str]]", global_delta: "typing.Optional[StateDelta]", local_deltas: "typing.Optional[typing.List[AccountStateDelta]]", logs: "typing.Optional[typing.List[bytes]]", budget_added: "typing.Optional[int]", budget_consumed: "typing.Optional[int]"):
        self.disassembly = disassembly
        self.logic_sig_disassembly = logic_sig_disassembly
        self.logic_sig_trace = logic_sig_trace
        self.logic_sig_messages = logic_sig_messages
        self.app_call_trace = app_call_trace
        self.app_call_messages = app_call_messages
        self.global_delta = global_delta
        self.local_deltas = local_deltas
        self.logs = logs
        self.budget_added = budget_added
        self.budget_consumed = budget_consumed

    def __str__(self):
        return "DryrunTxnResult(disassembly={}, logic_sig_disassembly={}, logic_sig_trace={}, logic_sig_messages={}, app_call_trace={}, app_call_messages={}, global_delta={}, local_deltas={}, logs={}, budget_added={}, budget_consumed={})".format(self.disassembly, self.logic_sig_disassembly, self.logic_sig_trace, self.logic_sig_messages, self.app_call_trace, self.app_call_messages, self.global_delta, self.local_deltas, self.logs, self.budget_added, self.budget_consumed)

    def __eq__(self, other):
        if self.disassembly != other.disassembly:
            return False
        if self.logic_sig_disassembly != other.logic_sig_disassembly:
            return False
        if self.logic_sig_trace != other.logic_sig_trace:
            return False
        if self.logic_sig_messages != other.logic_sig_messages:
            return False
        if self.app_call_trace != other.app_call_trace:
            return False
        if self.app_call_messages != other.app_call_messages:
            return False
        if self.global_delta != other.global_delta:
            return False
        if self.local_deltas != other.local_deltas:
            return False
        if self.logs != other.logs:
            return False
        if self.budget_added != other.budget_added:
            return False
        if self.budget_consumed != other.budget_consumed:
            return False
        return True

class _UniffiConverterTypeDryrunTxnResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryrunTxnResult(
            disassembly=_UniffiConverterSequenceString.read(buf),
            logic_sig_disassembly=_UniffiConverterOptionalSequenceString.read(buf),
            logic_sig_trace=_UniffiConverterOptionalSequenceTypeDryrunState.read(buf),
            logic_sig_messages=_UniffiConverterOptionalSequenceString.read(buf),
            app_call_trace=_UniffiConverterOptionalSequenceTypeDryrunState.read(buf),
            app_call_messages=_UniffiConverterOptionalSequenceString.read(buf),
            global_delta=_UniffiConverterOptionalTypeStateDelta.read(buf),
            local_deltas=_UniffiConverterOptionalSequenceTypeAccountStateDelta.read(buf),
            logs=_UniffiConverterOptionalSequenceBytes.read(buf),
            budget_added=_UniffiConverterOptionalUInt32.read(buf),
            budget_consumed=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.disassembly)
        _UniffiConverterOptionalSequenceString.check_lower(value.logic_sig_disassembly)
        _UniffiConverterOptionalSequenceTypeDryrunState.check_lower(value.logic_sig_trace)
        _UniffiConverterOptionalSequenceString.check_lower(value.logic_sig_messages)
        _UniffiConverterOptionalSequenceTypeDryrunState.check_lower(value.app_call_trace)
        _UniffiConverterOptionalSequenceString.check_lower(value.app_call_messages)
        _UniffiConverterOptionalTypeStateDelta.check_lower(value.global_delta)
        _UniffiConverterOptionalSequenceTypeAccountStateDelta.check_lower(value.local_deltas)
        _UniffiConverterOptionalSequenceBytes.check_lower(value.logs)
        _UniffiConverterOptionalUInt32.check_lower(value.budget_added)
        _UniffiConverterOptionalUInt32.check_lower(value.budget_consumed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.disassembly, buf)
        _UniffiConverterOptionalSequenceString.write(value.logic_sig_disassembly, buf)
        _UniffiConverterOptionalSequenceTypeDryrunState.write(value.logic_sig_trace, buf)
        _UniffiConverterOptionalSequenceString.write(value.logic_sig_messages, buf)
        _UniffiConverterOptionalSequenceTypeDryrunState.write(value.app_call_trace, buf)
        _UniffiConverterOptionalSequenceString.write(value.app_call_messages, buf)
        _UniffiConverterOptionalTypeStateDelta.write(value.global_delta, buf)
        _UniffiConverterOptionalSequenceTypeAccountStateDelta.write(value.local_deltas, buf)
        _UniffiConverterOptionalSequenceBytes.write(value.logs, buf)
        _UniffiConverterOptionalUInt32.write(value.budget_added, buf)
        _UniffiConverterOptionalUInt32.write(value.budget_consumed, buf)


class ErrorResponse:
    """
    An error response with optional data field.
    """

    data: "typing.Optional[UnknownJsonValue]"
    message: "str"
    def __init__(self, *, data: "typing.Optional[UnknownJsonValue]", message: "str"):
        self.data = data
        self.message = message

    def __str__(self):
        return "ErrorResponse(data={}, message={})".format(self.data, self.message)

    def __eq__(self, other):
        if self.data != other.data:
            return False
        if self.message != other.message:
            return False
        return True

class _UniffiConverterTypeErrorResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ErrorResponse(
            data=_UniffiConverterOptionalTypeUnknownJsonValue.read(buf),
            message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeUnknownJsonValue.check_lower(value.data)
        _UniffiConverterString.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeUnknownJsonValue.write(value.data, buf)
        _UniffiConverterString.write(value.message, buf)


class EvalDelta:
    """
    Represents a TEAL value delta.
    """

    action: "int"
    """
    [at] delta action.
    """

    bytes: "typing.Optional[str]"
    """
    [bs] bytes value.
    """

    uint: "typing.Optional[int]"
    """
    [ui] uint value.
    """

    def __init__(self, *, action: "int", bytes: "typing.Optional[str]", uint: "typing.Optional[int]"):
        self.action = action
        self.bytes = bytes
        self.uint = uint

    def __str__(self):
        return "EvalDelta(action={}, bytes={}, uint={})".format(self.action, self.bytes, self.uint)

    def __eq__(self, other):
        if self.action != other.action:
            return False
        if self.bytes != other.bytes:
            return False
        if self.uint != other.uint:
            return False
        return True

class _UniffiConverterTypeEvalDelta(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EvalDelta(
            action=_UniffiConverterUInt32.read(buf),
            bytes=_UniffiConverterOptionalString.read(buf),
            uint=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.action)
        _UniffiConverterOptionalString.check_lower(value.bytes)
        _UniffiConverterOptionalUInt64.check_lower(value.uint)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.action, buf)
        _UniffiConverterOptionalString.write(value.bytes, buf)
        _UniffiConverterOptionalUInt64.write(value.uint, buf)


class EvalDeltaKeyValue:
    """
    Key-value pairs for StateDelta.
    """

    key: "str"
    value: "EvalDelta"
    def __init__(self, *, key: "str", value: "EvalDelta"):
        self.key = key
        self.value = value

    def __str__(self):
        return "EvalDeltaKeyValue(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeEvalDeltaKeyValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EvalDeltaKeyValue(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterTypeEvalDelta.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterTypeEvalDelta.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterTypeEvalDelta.write(value.value, buf)


class Genesis:
    alloc: "typing.List[GenesisAllocation]"
    comment: "typing.Optional[str]"
    devmode: "typing.Optional[bool]"
    fees: "str"
    id: "str"
    network: "str"
    proto: "str"
    rwd: "str"
    timestamp: "int"
    def __init__(self, *, alloc: "typing.List[GenesisAllocation]", comment: "typing.Optional[str]", devmode: "typing.Optional[bool]", fees: "str", id: "str", network: "str", proto: "str", rwd: "str", timestamp: "int"):
        self.alloc = alloc
        self.comment = comment
        self.devmode = devmode
        self.fees = fees
        self.id = id
        self.network = network
        self.proto = proto
        self.rwd = rwd
        self.timestamp = timestamp

    def __str__(self):
        return "Genesis(alloc={}, comment={}, devmode={}, fees={}, id={}, network={}, proto={}, rwd={}, timestamp={})".format(self.alloc, self.comment, self.devmode, self.fees, self.id, self.network, self.proto, self.rwd, self.timestamp)

    def __eq__(self, other):
        if self.alloc != other.alloc:
            return False
        if self.comment != other.comment:
            return False
        if self.devmode != other.devmode:
            return False
        if self.fees != other.fees:
            return False
        if self.id != other.id:
            return False
        if self.network != other.network:
            return False
        if self.proto != other.proto:
            return False
        if self.rwd != other.rwd:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class _UniffiConverterTypeGenesis(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Genesis(
            alloc=_UniffiConverterSequenceTypeGenesisAllocation.read(buf),
            comment=_UniffiConverterOptionalString.read(buf),
            devmode=_UniffiConverterOptionalBool.read(buf),
            fees=_UniffiConverterString.read(buf),
            id=_UniffiConverterString.read(buf),
            network=_UniffiConverterString.read(buf),
            proto=_UniffiConverterString.read(buf),
            rwd=_UniffiConverterString.read(buf),
            timestamp=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeGenesisAllocation.check_lower(value.alloc)
        _UniffiConverterOptionalString.check_lower(value.comment)
        _UniffiConverterOptionalBool.check_lower(value.devmode)
        _UniffiConverterString.check_lower(value.fees)
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.network)
        _UniffiConverterString.check_lower(value.proto)
        _UniffiConverterString.check_lower(value.rwd)
        _UniffiConverterUInt64.check_lower(value.timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeGenesisAllocation.write(value.alloc, buf)
        _UniffiConverterOptionalString.write(value.comment, buf)
        _UniffiConverterOptionalBool.write(value.devmode, buf)
        _UniffiConverterString.write(value.fees, buf)
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.network, buf)
        _UniffiConverterString.write(value.proto, buf)
        _UniffiConverterString.write(value.rwd, buf)
        _UniffiConverterUInt64.write(value.timestamp, buf)


class GenesisAllocation:
    addr: "str"
    comment: "str"
    state: "UnknownJsonValue"
    def __init__(self, *, addr: "str", comment: "str", state: "UnknownJsonValue"):
        self.addr = addr
        self.comment = comment
        self.state = state

    def __str__(self):
        return "GenesisAllocation(addr={}, comment={}, state={})".format(self.addr, self.comment, self.state)

    def __eq__(self, other):
        if self.addr != other.addr:
            return False
        if self.comment != other.comment:
            return False
        if self.state != other.state:
            return False
        return True

class _UniffiConverterTypeGenesisAllocation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GenesisAllocation(
            addr=_UniffiConverterString.read(buf),
            comment=_UniffiConverterString.read(buf),
            state=_UniffiConverterTypeUnknownJsonValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.addr)
        _UniffiConverterString.check_lower(value.comment)
        _UniffiConverterTypeUnknownJsonValue.check_lower(value.state)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.addr, buf)
        _UniffiConverterString.write(value.comment, buf)
        _UniffiConverterTypeUnknownJsonValue.write(value.state, buf)


class GetApplicationBoxes:
    """
    Box names of an application
    """

    boxes: "typing.List[BoxDescriptor]"
    def __init__(self, *, boxes: "typing.List[BoxDescriptor]"):
        self.boxes = boxes

    def __str__(self):
        return "GetApplicationBoxes(boxes={})".format(self.boxes)

    def __eq__(self, other):
        if self.boxes != other.boxes:
            return False
        return True

class _UniffiConverterTypeGetApplicationBoxes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetApplicationBoxes(
            boxes=_UniffiConverterSequenceTypeBoxDescriptor.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeBoxDescriptor.check_lower(value.boxes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeBoxDescriptor.write(value.boxes, buf)


class GetBlock:
    """
    Encoded block object.
    """

    block: "UnknownJsonValue"
    """
    Block header data.
    """

    cert: "typing.Optional[UnknownJsonValue]"
    """
    Optional certificate object. This is only included when the format is set to message pack.
    """

    def __init__(self, *, block: "UnknownJsonValue", cert: "typing.Optional[UnknownJsonValue]"):
        self.block = block
        self.cert = cert

    def __str__(self):
        return "GetBlock(block={}, cert={})".format(self.block, self.cert)

    def __eq__(self, other):
        if self.block != other.block:
            return False
        if self.cert != other.cert:
            return False
        return True

class _UniffiConverterTypeGetBlock(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBlock(
            block=_UniffiConverterTypeUnknownJsonValue.read(buf),
            cert=_UniffiConverterOptionalTypeUnknownJsonValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeUnknownJsonValue.check_lower(value.block)
        _UniffiConverterOptionalTypeUnknownJsonValue.check_lower(value.cert)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeUnknownJsonValue.write(value.block, buf)
        _UniffiConverterOptionalTypeUnknownJsonValue.write(value.cert, buf)


class GetBlockHash:
    """
    Hash of a block header.
    """

    block_hash: "str"
    """
    Block header hash.
    """

    def __init__(self, *, block_hash: "str"):
        self.block_hash = block_hash

    def __str__(self):
        return "GetBlockHash(block_hash={})".format(self.block_hash)

    def __eq__(self, other):
        if self.block_hash != other.block_hash:
            return False
        return True

class _UniffiConverterTypeGetBlockHash(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBlockHash(
            block_hash=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.block_hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.block_hash, buf)


class GetBlockLogs:
    """
    All logs emitted in the given round. Each app call, whether top-level or inner, that contains logs results in a separate AppCallLogs object. Therefore there may be multiple AppCallLogs with the same application ID and outer transaction ID in the event of multiple inner app calls to the same app. App calls with no logs are not included in the response. AppCallLogs are returned in the same order that their corresponding app call appeared in the block (pre-order traversal of inner app calls)
    """

    logs: "typing.List[AppCallLogs]"
    def __init__(self, *, logs: "typing.List[AppCallLogs]"):
        self.logs = logs

    def __str__(self):
        return "GetBlockLogs(logs={})".format(self.logs)

    def __eq__(self, other):
        if self.logs != other.logs:
            return False
        return True

class _UniffiConverterTypeGetBlockLogs(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBlockLogs(
            logs=_UniffiConverterSequenceTypeAppCallLogs.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeAppCallLogs.check_lower(value.logs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeAppCallLogs.write(value.logs, buf)


class GetBlockTimeStampOffset:
    """
    Response containing the timestamp offset in seconds
    """

    offset: "int"
    """
    Timestamp offset in seconds.
    """

    def __init__(self, *, offset: "int"):
        self.offset = offset

    def __str__(self):
        return "GetBlockTimeStampOffset(offset={})".format(self.offset)

    def __eq__(self, other):
        if self.offset != other.offset:
            return False
        return True

class _UniffiConverterTypeGetBlockTimeStampOffset(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBlockTimeStampOffset(
            offset=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.offset)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.offset, buf)


class GetBlockTxids:
    """
    Top level transaction IDs in a block.
    """

    block_txids: "typing.List[str]"
    """
    Block transaction IDs.
    """

    def __init__(self, *, block_txids: "typing.List[str]"):
        self.block_txids = block_txids

    def __str__(self):
        return "GetBlockTxids(block_txids={})".format(self.block_txids)

    def __eq__(self, other):
        if self.block_txids != other.block_txids:
            return False
        return True

class _UniffiConverterTypeGetBlockTxids(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetBlockTxids(
            block_txids=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.block_txids)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.block_txids, buf)


class GetPendingTransactions:
    """
    PendingTransactions is an array of signed transactions exactly as they were submitted.
    """

    top_transactions: "typing.List[SignedTransaction]"
    """
    An array of signed transaction objects.
    """

    total_transactions: "int"
    """
    Total number of transactions in the pool.
    """

    def __init__(self, *, top_transactions: "typing.List[SignedTransaction]", total_transactions: "int"):
        self.top_transactions = top_transactions
        self.total_transactions = total_transactions

    def __str__(self):
        return "GetPendingTransactions(top_transactions={}, total_transactions={})".format(self.top_transactions, self.total_transactions)

    def __eq__(self, other):
        if self.top_transactions != other.top_transactions:
            return False
        if self.total_transactions != other.total_transactions:
            return False
        return True

class _UniffiConverterTypeGetPendingTransactions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetPendingTransactions(
            top_transactions=_UniffiConverterSequenceTypeSignedTransaction.read(buf),
            total_transactions=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeSignedTransaction.check_lower(value.top_transactions)
        _UniffiConverterUInt64.check_lower(value.total_transactions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeSignedTransaction.write(value.top_transactions, buf)
        _UniffiConverterUInt64.write(value.total_transactions, buf)


class GetPendingTransactionsByAddress:
    """
    PendingTransactions is an array of signed transactions exactly as they were submitted.
    """

    top_transactions: "typing.List[SignedTransaction]"
    """
    An array of signed transaction objects.
    """

    total_transactions: "int"
    """
    Total number of transactions in the pool.
    """

    def __init__(self, *, top_transactions: "typing.List[SignedTransaction]", total_transactions: "int"):
        self.top_transactions = top_transactions
        self.total_transactions = total_transactions

    def __str__(self):
        return "GetPendingTransactionsByAddress(top_transactions={}, total_transactions={})".format(self.top_transactions, self.total_transactions)

    def __eq__(self, other):
        if self.top_transactions != other.top_transactions:
            return False
        if self.total_transactions != other.total_transactions:
            return False
        return True

class _UniffiConverterTypeGetPendingTransactionsByAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetPendingTransactionsByAddress(
            top_transactions=_UniffiConverterSequenceTypeSignedTransaction.read(buf),
            total_transactions=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeSignedTransaction.check_lower(value.top_transactions)
        _UniffiConverterUInt64.check_lower(value.total_transactions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeSignedTransaction.write(value.top_transactions, buf)
        _UniffiConverterUInt64.write(value.total_transactions, buf)


class GetStatus:
    """
    NodeStatus contains the information about a node status
    """

    catchup_time: "int"
    """
    CatchupTime in nanoseconds
    """

    last_round: "int"
    """
    LastRound indicates the last round seen
    """

    last_version: "str"
    """
    LastVersion indicates the last consensus version supported
    """

    next_version: "str"
    """
    NextVersion of consensus protocol to use
    """

    next_version_round: "int"
    """
    NextVersionRound is the round at which the next consensus version will apply
    """

    next_version_supported: "bool"
    """
    NextVersionSupported indicates whether the next consensus version is supported by this node
    """

    stopped_at_unsupported_round: "bool"
    """
    StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
    """

    time_since_last_round: "int"
    """
    TimeSinceLastRound in nanoseconds
    """

    last_catchpoint: "typing.Optional[str]"
    """
    The last catchpoint seen by the node
    """

    catchpoint: "typing.Optional[str]"
    """
    The current catchpoint that is being caught up to
    """

    catchpoint_total_accounts: "typing.Optional[int]"
    """
    The total number of accounts included in the current catchpoint
    """

    catchpoint_processed_accounts: "typing.Optional[int]"
    """
    The number of accounts from the current catchpoint that have been processed so far as part of the catchup
    """

    catchpoint_verified_accounts: "typing.Optional[int]"
    """
    The number of accounts from the current catchpoint that have been verified so far as part of the catchup
    """

    catchpoint_total_kvs: "typing.Optional[int]"
    """
    The total number of key-values (KVs) included in the current catchpoint
    """

    catchpoint_processed_kvs: "typing.Optional[int]"
    """
    The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
    """

    catchpoint_verified_kvs: "typing.Optional[int]"
    """
    The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
    """

    catchpoint_total_blocks: "typing.Optional[int]"
    """
    The total number of blocks that are required to complete the current catchpoint catchup
    """

    catchpoint_acquired_blocks: "typing.Optional[int]"
    """
    The number of blocks that have already been obtained by the node as part of the catchup
    """

    upgrade_delay: "typing.Optional[int]"
    """
    Upgrade delay
    """

    upgrade_node_vote: "typing.Optional[bool]"
    """
    This node's upgrade vote
    """

    upgrade_votes_required: "typing.Optional[int]"
    """
    Yes votes required for consensus upgrade
    """

    upgrade_votes: "typing.Optional[int]"
    """
    Total votes cast for consensus upgrade
    """

    upgrade_yes_votes: "typing.Optional[int]"
    """
    Yes votes cast for consensus upgrade
    """

    upgrade_no_votes: "typing.Optional[int]"
    """
    No votes cast for consensus upgrade
    """

    upgrade_next_protocol_vote_before: "typing.Optional[int]"
    """
    Next protocol round
    """

    upgrade_vote_rounds: "typing.Optional[int]"
    """
    Total voting rounds for current upgrade
    """

    def __init__(self, *, catchup_time: "int", last_round: "int", last_version: "str", next_version: "str", next_version_round: "int", next_version_supported: "bool", stopped_at_unsupported_round: "bool", time_since_last_round: "int", last_catchpoint: "typing.Optional[str]", catchpoint: "typing.Optional[str]", catchpoint_total_accounts: "typing.Optional[int]", catchpoint_processed_accounts: "typing.Optional[int]", catchpoint_verified_accounts: "typing.Optional[int]", catchpoint_total_kvs: "typing.Optional[int]", catchpoint_processed_kvs: "typing.Optional[int]", catchpoint_verified_kvs: "typing.Optional[int]", catchpoint_total_blocks: "typing.Optional[int]", catchpoint_acquired_blocks: "typing.Optional[int]", upgrade_delay: "typing.Optional[int]", upgrade_node_vote: "typing.Optional[bool]", upgrade_votes_required: "typing.Optional[int]", upgrade_votes: "typing.Optional[int]", upgrade_yes_votes: "typing.Optional[int]", upgrade_no_votes: "typing.Optional[int]", upgrade_next_protocol_vote_before: "typing.Optional[int]", upgrade_vote_rounds: "typing.Optional[int]"):
        self.catchup_time = catchup_time
        self.last_round = last_round
        self.last_version = last_version
        self.next_version = next_version
        self.next_version_round = next_version_round
        self.next_version_supported = next_version_supported
        self.stopped_at_unsupported_round = stopped_at_unsupported_round
        self.time_since_last_round = time_since_last_round
        self.last_catchpoint = last_catchpoint
        self.catchpoint = catchpoint
        self.catchpoint_total_accounts = catchpoint_total_accounts
        self.catchpoint_processed_accounts = catchpoint_processed_accounts
        self.catchpoint_verified_accounts = catchpoint_verified_accounts
        self.catchpoint_total_kvs = catchpoint_total_kvs
        self.catchpoint_processed_kvs = catchpoint_processed_kvs
        self.catchpoint_verified_kvs = catchpoint_verified_kvs
        self.catchpoint_total_blocks = catchpoint_total_blocks
        self.catchpoint_acquired_blocks = catchpoint_acquired_blocks
        self.upgrade_delay = upgrade_delay
        self.upgrade_node_vote = upgrade_node_vote
        self.upgrade_votes_required = upgrade_votes_required
        self.upgrade_votes = upgrade_votes
        self.upgrade_yes_votes = upgrade_yes_votes
        self.upgrade_no_votes = upgrade_no_votes
        self.upgrade_next_protocol_vote_before = upgrade_next_protocol_vote_before
        self.upgrade_vote_rounds = upgrade_vote_rounds

    def __str__(self):
        return "GetStatus(catchup_time={}, last_round={}, last_version={}, next_version={}, next_version_round={}, next_version_supported={}, stopped_at_unsupported_round={}, time_since_last_round={}, last_catchpoint={}, catchpoint={}, catchpoint_total_accounts={}, catchpoint_processed_accounts={}, catchpoint_verified_accounts={}, catchpoint_total_kvs={}, catchpoint_processed_kvs={}, catchpoint_verified_kvs={}, catchpoint_total_blocks={}, catchpoint_acquired_blocks={}, upgrade_delay={}, upgrade_node_vote={}, upgrade_votes_required={}, upgrade_votes={}, upgrade_yes_votes={}, upgrade_no_votes={}, upgrade_next_protocol_vote_before={}, upgrade_vote_rounds={})".format(self.catchup_time, self.last_round, self.last_version, self.next_version, self.next_version_round, self.next_version_supported, self.stopped_at_unsupported_round, self.time_since_last_round, self.last_catchpoint, self.catchpoint, self.catchpoint_total_accounts, self.catchpoint_processed_accounts, self.catchpoint_verified_accounts, self.catchpoint_total_kvs, self.catchpoint_processed_kvs, self.catchpoint_verified_kvs, self.catchpoint_total_blocks, self.catchpoint_acquired_blocks, self.upgrade_delay, self.upgrade_node_vote, self.upgrade_votes_required, self.upgrade_votes, self.upgrade_yes_votes, self.upgrade_no_votes, self.upgrade_next_protocol_vote_before, self.upgrade_vote_rounds)

    def __eq__(self, other):
        if self.catchup_time != other.catchup_time:
            return False
        if self.last_round != other.last_round:
            return False
        if self.last_version != other.last_version:
            return False
        if self.next_version != other.next_version:
            return False
        if self.next_version_round != other.next_version_round:
            return False
        if self.next_version_supported != other.next_version_supported:
            return False
        if self.stopped_at_unsupported_round != other.stopped_at_unsupported_round:
            return False
        if self.time_since_last_round != other.time_since_last_round:
            return False
        if self.last_catchpoint != other.last_catchpoint:
            return False
        if self.catchpoint != other.catchpoint:
            return False
        if self.catchpoint_total_accounts != other.catchpoint_total_accounts:
            return False
        if self.catchpoint_processed_accounts != other.catchpoint_processed_accounts:
            return False
        if self.catchpoint_verified_accounts != other.catchpoint_verified_accounts:
            return False
        if self.catchpoint_total_kvs != other.catchpoint_total_kvs:
            return False
        if self.catchpoint_processed_kvs != other.catchpoint_processed_kvs:
            return False
        if self.catchpoint_verified_kvs != other.catchpoint_verified_kvs:
            return False
        if self.catchpoint_total_blocks != other.catchpoint_total_blocks:
            return False
        if self.catchpoint_acquired_blocks != other.catchpoint_acquired_blocks:
            return False
        if self.upgrade_delay != other.upgrade_delay:
            return False
        if self.upgrade_node_vote != other.upgrade_node_vote:
            return False
        if self.upgrade_votes_required != other.upgrade_votes_required:
            return False
        if self.upgrade_votes != other.upgrade_votes:
            return False
        if self.upgrade_yes_votes != other.upgrade_yes_votes:
            return False
        if self.upgrade_no_votes != other.upgrade_no_votes:
            return False
        if self.upgrade_next_protocol_vote_before != other.upgrade_next_protocol_vote_before:
            return False
        if self.upgrade_vote_rounds != other.upgrade_vote_rounds:
            return False
        return True

class _UniffiConverterTypeGetStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetStatus(
            catchup_time=_UniffiConverterUInt64.read(buf),
            last_round=_UniffiConverterUInt64.read(buf),
            last_version=_UniffiConverterString.read(buf),
            next_version=_UniffiConverterString.read(buf),
            next_version_round=_UniffiConverterUInt64.read(buf),
            next_version_supported=_UniffiConverterBool.read(buf),
            stopped_at_unsupported_round=_UniffiConverterBool.read(buf),
            time_since_last_round=_UniffiConverterUInt64.read(buf),
            last_catchpoint=_UniffiConverterOptionalString.read(buf),
            catchpoint=_UniffiConverterOptionalString.read(buf),
            catchpoint_total_accounts=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_processed_accounts=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_verified_accounts=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_total_kvs=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_processed_kvs=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_verified_kvs=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_total_blocks=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_acquired_blocks=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_delay=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_node_vote=_UniffiConverterOptionalBool.read(buf),
            upgrade_votes_required=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_votes=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_yes_votes=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_no_votes=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_next_protocol_vote_before=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_vote_rounds=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.catchup_time)
        _UniffiConverterUInt64.check_lower(value.last_round)
        _UniffiConverterString.check_lower(value.last_version)
        _UniffiConverterString.check_lower(value.next_version)
        _UniffiConverterUInt64.check_lower(value.next_version_round)
        _UniffiConverterBool.check_lower(value.next_version_supported)
        _UniffiConverterBool.check_lower(value.stopped_at_unsupported_round)
        _UniffiConverterUInt64.check_lower(value.time_since_last_round)
        _UniffiConverterOptionalString.check_lower(value.last_catchpoint)
        _UniffiConverterOptionalString.check_lower(value.catchpoint)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_total_accounts)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_processed_accounts)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_verified_accounts)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_total_kvs)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_processed_kvs)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_verified_kvs)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_total_blocks)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_acquired_blocks)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_delay)
        _UniffiConverterOptionalBool.check_lower(value.upgrade_node_vote)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_votes_required)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_votes)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_yes_votes)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_no_votes)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_next_protocol_vote_before)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_vote_rounds)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.catchup_time, buf)
        _UniffiConverterUInt64.write(value.last_round, buf)
        _UniffiConverterString.write(value.last_version, buf)
        _UniffiConverterString.write(value.next_version, buf)
        _UniffiConverterUInt64.write(value.next_version_round, buf)
        _UniffiConverterBool.write(value.next_version_supported, buf)
        _UniffiConverterBool.write(value.stopped_at_unsupported_round, buf)
        _UniffiConverterUInt64.write(value.time_since_last_round, buf)
        _UniffiConverterOptionalString.write(value.last_catchpoint, buf)
        _UniffiConverterOptionalString.write(value.catchpoint, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_total_accounts, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_processed_accounts, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_verified_accounts, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_total_kvs, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_processed_kvs, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_verified_kvs, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_total_blocks, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_acquired_blocks, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_delay, buf)
        _UniffiConverterOptionalBool.write(value.upgrade_node_vote, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_votes_required, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_votes, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_yes_votes, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_no_votes, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_next_protocol_vote_before, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_vote_rounds, buf)


class GetSupply:
    """
    Supply represents the current supply of MicroAlgos in the system
    """

    current_round: "int"
    """
    Round
    """

    online_money: "int"
    """
    OnlineMoney
    """

    total_money: "int"
    """
    TotalMoney
    """

    def __init__(self, *, current_round: "int", online_money: "int", total_money: "int"):
        self.current_round = current_round
        self.online_money = online_money
        self.total_money = total_money

    def __str__(self):
        return "GetSupply(current_round={}, online_money={}, total_money={})".format(self.current_round, self.online_money, self.total_money)

    def __eq__(self, other):
        if self.current_round != other.current_round:
            return False
        if self.online_money != other.online_money:
            return False
        if self.total_money != other.total_money:
            return False
        return True

class _UniffiConverterTypeGetSupply(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetSupply(
            current_round=_UniffiConverterUInt64.read(buf),
            online_money=_UniffiConverterUInt64.read(buf),
            total_money=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.current_round)
        _UniffiConverterUInt64.check_lower(value.online_money)
        _UniffiConverterUInt64.check_lower(value.total_money)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.current_round, buf)
        _UniffiConverterUInt64.write(value.online_money, buf)
        _UniffiConverterUInt64.write(value.total_money, buf)


class GetSyncRound:
    """
    Response containing the ledger's minimum sync round
    """

    round: "int"
    """
    The minimum sync round for the ledger.
    """

    def __init__(self, *, round: "int"):
        self.round = round

    def __str__(self):
        return "GetSyncRound(round={})".format(self.round)

    def __eq__(self, other):
        if self.round != other.round:
            return False
        return True

class _UniffiConverterTypeGetSyncRound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetSyncRound(
            round=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.round)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.round, buf)


class GetTransactionGroupLedgerStateDeltasForRound:
    """
    Response containing all ledger state deltas for transaction groups, with their associated Ids, in a single round.
    """

    deltas: "typing.List[LedgerStateDeltaForTransactionGroup]"
    def __init__(self, *, deltas: "typing.List[LedgerStateDeltaForTransactionGroup]"):
        self.deltas = deltas

    def __str__(self):
        return "GetTransactionGroupLedgerStateDeltasForRound(deltas={})".format(self.deltas)

    def __eq__(self, other):
        if self.deltas != other.deltas:
            return False
        return True

class _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRound(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetTransactionGroupLedgerStateDeltasForRound(
            deltas=_UniffiConverterSequenceTypeLedgerStateDeltaForTransactionGroup.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeLedgerStateDeltaForTransactionGroup.check_lower(value.deltas)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeLedgerStateDeltaForTransactionGroup.write(value.deltas, buf)


class LedgerStateDelta:
    """
    Ledger StateDelta object
    """


    def __str__(self):
        return "LedgerStateDelta()".format()

    def __eq__(self, other):
        return True

class _UniffiConverterTypeLedgerStateDelta(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LedgerStateDelta(
        )

    @staticmethod
    def check_lower(value):
        pass

    @staticmethod
    def write(value, buf):
        pass


class LedgerStateDeltaForTransactionGroup:
    """
    Contains a ledger delta for a single transaction group
    """

    delta: "LedgerStateDelta"
    ids: "typing.List[str]"
    def __init__(self, *, delta: "LedgerStateDelta", ids: "typing.List[str]"):
        self.delta = delta
        self.ids = ids

    def __str__(self):
        return "LedgerStateDeltaForTransactionGroup(delta={}, ids={})".format(self.delta, self.ids)

    def __eq__(self, other):
        if self.delta != other.delta:
            return False
        if self.ids != other.ids:
            return False
        return True

class _UniffiConverterTypeLedgerStateDeltaForTransactionGroup(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LedgerStateDeltaForTransactionGroup(
            delta=_UniffiConverterTypeLedgerStateDelta.read(buf),
            ids=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeLedgerStateDelta.check_lower(value.delta)
        _UniffiConverterSequenceString.check_lower(value.ids)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeLedgerStateDelta.write(value.delta, buf)
        _UniffiConverterSequenceString.write(value.ids, buf)


class LightBlockHeaderProof:
    """
    Proof of membership and position of a light block header.
    """

    index: "int"
    """
    The index of the light block header in the vector commitment tree
    """

    treedepth: "int"
    """
    Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root.
    """

    proof: "bytes"
    """
    The encoded proof.
    """

    def __init__(self, *, index: "int", treedepth: "int", proof: "bytes"):
        self.index = index
        self.treedepth = treedepth
        self.proof = proof

    def __str__(self):
        return "LightBlockHeaderProof(index={}, treedepth={}, proof={})".format(self.index, self.treedepth, self.proof)

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.treedepth != other.treedepth:
            return False
        if self.proof != other.proof:
            return False
        return True

class _UniffiConverterTypeLightBlockHeaderProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LightBlockHeaderProof(
            index=_UniffiConverterUInt64.read(buf),
            treedepth=_UniffiConverterUInt64.read(buf),
            proof=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.index)
        _UniffiConverterUInt64.check_lower(value.treedepth)
        _UniffiConverterBytes.check_lower(value.proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.index, buf)
        _UniffiConverterUInt64.write(value.treedepth, buf)
        _UniffiConverterBytes.write(value.proof, buf)


class ParticipationKey:
    """
    Represents a participation key used by the node.
    """

    id: "str"
    """
    The key's ParticipationID.
    """

    address: "str"
    """
    Address the key was generated for.
    """

    effective_first_valid: "typing.Optional[int]"
    """
    When registered, this is the first round it may be used.
    """

    effective_last_valid: "typing.Optional[int]"
    """
    When registered, this is the last round it may be used.
    """

    last_vote: "typing.Optional[int]"
    """
    Round when this key was last used to vote.
    """

    last_block_proposal: "typing.Optional[int]"
    """
    Round when this key was last used to propose a block.
    """

    last_state_proof: "typing.Optional[int]"
    """
    Round when this key was last used to generate a state proof.
    """

    key: "AccountParticipation"
    def __init__(self, *, id: "str", address: "str", effective_first_valid: "typing.Optional[int]", effective_last_valid: "typing.Optional[int]", last_vote: "typing.Optional[int]", last_block_proposal: "typing.Optional[int]", last_state_proof: "typing.Optional[int]", key: "AccountParticipation"):
        self.id = id
        self.address = address
        self.effective_first_valid = effective_first_valid
        self.effective_last_valid = effective_last_valid
        self.last_vote = last_vote
        self.last_block_proposal = last_block_proposal
        self.last_state_proof = last_state_proof
        self.key = key

    def __str__(self):
        return "ParticipationKey(id={}, address={}, effective_first_valid={}, effective_last_valid={}, last_vote={}, last_block_proposal={}, last_state_proof={}, key={})".format(self.id, self.address, self.effective_first_valid, self.effective_last_valid, self.last_vote, self.last_block_proposal, self.last_state_proof, self.key)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.address != other.address:
            return False
        if self.effective_first_valid != other.effective_first_valid:
            return False
        if self.effective_last_valid != other.effective_last_valid:
            return False
        if self.last_vote != other.last_vote:
            return False
        if self.last_block_proposal != other.last_block_proposal:
            return False
        if self.last_state_proof != other.last_state_proof:
            return False
        if self.key != other.key:
            return False
        return True

class _UniffiConverterTypeParticipationKey(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ParticipationKey(
            id=_UniffiConverterString.read(buf),
            address=_UniffiConverterString.read(buf),
            effective_first_valid=_UniffiConverterOptionalUInt64.read(buf),
            effective_last_valid=_UniffiConverterOptionalUInt64.read(buf),
            last_vote=_UniffiConverterOptionalUInt64.read(buf),
            last_block_proposal=_UniffiConverterOptionalUInt64.read(buf),
            last_state_proof=_UniffiConverterOptionalUInt64.read(buf),
            key=_UniffiConverterTypeAccountParticipation.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.id)
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterOptionalUInt64.check_lower(value.effective_first_valid)
        _UniffiConverterOptionalUInt64.check_lower(value.effective_last_valid)
        _UniffiConverterOptionalUInt64.check_lower(value.last_vote)
        _UniffiConverterOptionalUInt64.check_lower(value.last_block_proposal)
        _UniffiConverterOptionalUInt64.check_lower(value.last_state_proof)
        _UniffiConverterTypeAccountParticipation.check_lower(value.key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.id, buf)
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterOptionalUInt64.write(value.effective_first_valid, buf)
        _UniffiConverterOptionalUInt64.write(value.effective_last_valid, buf)
        _UniffiConverterOptionalUInt64.write(value.last_vote, buf)
        _UniffiConverterOptionalUInt64.write(value.last_block_proposal, buf)
        _UniffiConverterOptionalUInt64.write(value.last_state_proof, buf)
        _UniffiConverterTypeAccountParticipation.write(value.key, buf)


class PendingTransactionResponse:
    """
    Details about a pending transaction. If the transaction was recently confirmed, includes confirmation details like the round and reward details.
    """

    asset_id: "typing.Optional[int]"
    """
    The asset index if the transaction was found and it created an asset.
    """

    app_id: "typing.Optional[int]"
    """
    The application index if the transaction was found and it created an application.
    """

    close_rewards: "typing.Optional[int]"
    """
    Rewards in microalgos applied to the close remainder to account.
    """

    closing_amount: "typing.Optional[int]"
    """
    Closing amount for the transaction.
    """

    asset_closing_amount: "typing.Optional[int]"
    """
    The number of the asset's unit that were transferred to the close-to address.
    """

    confirmed_round: "typing.Optional[int]"
    """
    The round where this transaction was confirmed, if present.
    """

    pool_error: "str"
    """
    Indicates that the transaction was kicked out of this node's transaction pool (and specifies why that happened).  An empty string indicates the transaction wasn't kicked out of this node's txpool due to an error.
    """

    receiver_rewards: "typing.Optional[int]"
    """
    Rewards in microalgos applied to the receiver account.
    """

    sender_rewards: "typing.Optional[int]"
    """
    Rewards in microalgos applied to the sender account.
    """

    local_state_delta: "typing.Optional[typing.List[AccountStateDelta]]"
    """
    Local state key/value changes for the application being executed by this transaction.
    """

    global_state_delta: "typing.Optional[StateDelta]"
    logs: "typing.Optional[typing.List[bytes]]"
    """
    Logs for the application being executed by this transaction.
    """

    inner_txns: "typing.Optional[typing.List[PendingTransactionResponse]]"
    """
    Inner transactions produced by application execution.
    """

    txn: "SignedTransaction"
    """
    The raw signed transaction.
    """

    def __init__(self, *, asset_id: "typing.Optional[int]", app_id: "typing.Optional[int]", close_rewards: "typing.Optional[int]", closing_amount: "typing.Optional[int]", asset_closing_amount: "typing.Optional[int]", confirmed_round: "typing.Optional[int]", pool_error: "str", receiver_rewards: "typing.Optional[int]", sender_rewards: "typing.Optional[int]", local_state_delta: "typing.Optional[typing.List[AccountStateDelta]]", global_state_delta: "typing.Optional[StateDelta]", logs: "typing.Optional[typing.List[bytes]]", inner_txns: "typing.Optional[typing.List[PendingTransactionResponse]]", txn: "SignedTransaction"):
        self.asset_id = asset_id
        self.app_id = app_id
        self.close_rewards = close_rewards
        self.closing_amount = closing_amount
        self.asset_closing_amount = asset_closing_amount
        self.confirmed_round = confirmed_round
        self.pool_error = pool_error
        self.receiver_rewards = receiver_rewards
        self.sender_rewards = sender_rewards
        self.local_state_delta = local_state_delta
        self.global_state_delta = global_state_delta
        self.logs = logs
        self.inner_txns = inner_txns
        self.txn = txn

    def __str__(self):
        return "PendingTransactionResponse(asset_id={}, app_id={}, close_rewards={}, closing_amount={}, asset_closing_amount={}, confirmed_round={}, pool_error={}, receiver_rewards={}, sender_rewards={}, local_state_delta={}, global_state_delta={}, logs={}, inner_txns={}, txn={})".format(self.asset_id, self.app_id, self.close_rewards, self.closing_amount, self.asset_closing_amount, self.confirmed_round, self.pool_error, self.receiver_rewards, self.sender_rewards, self.local_state_delta, self.global_state_delta, self.logs, self.inner_txns, self.txn)

    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.app_id != other.app_id:
            return False
        if self.close_rewards != other.close_rewards:
            return False
        if self.closing_amount != other.closing_amount:
            return False
        if self.asset_closing_amount != other.asset_closing_amount:
            return False
        if self.confirmed_round != other.confirmed_round:
            return False
        if self.pool_error != other.pool_error:
            return False
        if self.receiver_rewards != other.receiver_rewards:
            return False
        if self.sender_rewards != other.sender_rewards:
            return False
        if self.local_state_delta != other.local_state_delta:
            return False
        if self.global_state_delta != other.global_state_delta:
            return False
        if self.logs != other.logs:
            return False
        if self.inner_txns != other.inner_txns:
            return False
        if self.txn != other.txn:
            return False
        return True

class _UniffiConverterTypePendingTransactionResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PendingTransactionResponse(
            asset_id=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterOptionalUInt64.read(buf),
            close_rewards=_UniffiConverterOptionalUInt64.read(buf),
            closing_amount=_UniffiConverterOptionalUInt64.read(buf),
            asset_closing_amount=_UniffiConverterOptionalUInt64.read(buf),
            confirmed_round=_UniffiConverterOptionalUInt64.read(buf),
            pool_error=_UniffiConverterString.read(buf),
            receiver_rewards=_UniffiConverterOptionalUInt64.read(buf),
            sender_rewards=_UniffiConverterOptionalUInt64.read(buf),
            local_state_delta=_UniffiConverterOptionalSequenceTypeAccountStateDelta.read(buf),
            global_state_delta=_UniffiConverterOptionalTypeStateDelta.read(buf),
            logs=_UniffiConverterOptionalSequenceBytes.read(buf),
            inner_txns=_UniffiConverterOptionalSequenceTypePendingTransactionResponse.read(buf),
            txn=_UniffiConverterTypeSignedTransaction.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.asset_id)
        _UniffiConverterOptionalUInt64.check_lower(value.app_id)
        _UniffiConverterOptionalUInt64.check_lower(value.close_rewards)
        _UniffiConverterOptionalUInt64.check_lower(value.closing_amount)
        _UniffiConverterOptionalUInt64.check_lower(value.asset_closing_amount)
        _UniffiConverterOptionalUInt64.check_lower(value.confirmed_round)
        _UniffiConverterString.check_lower(value.pool_error)
        _UniffiConverterOptionalUInt64.check_lower(value.receiver_rewards)
        _UniffiConverterOptionalUInt64.check_lower(value.sender_rewards)
        _UniffiConverterOptionalSequenceTypeAccountStateDelta.check_lower(value.local_state_delta)
        _UniffiConverterOptionalTypeStateDelta.check_lower(value.global_state_delta)
        _UniffiConverterOptionalSequenceBytes.check_lower(value.logs)
        _UniffiConverterOptionalSequenceTypePendingTransactionResponse.check_lower(value.inner_txns)
        _UniffiConverterTypeSignedTransaction.check_lower(value.txn)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.asset_id, buf)
        _UniffiConverterOptionalUInt64.write(value.app_id, buf)
        _UniffiConverterOptionalUInt64.write(value.close_rewards, buf)
        _UniffiConverterOptionalUInt64.write(value.closing_amount, buf)
        _UniffiConverterOptionalUInt64.write(value.asset_closing_amount, buf)
        _UniffiConverterOptionalUInt64.write(value.confirmed_round, buf)
        _UniffiConverterString.write(value.pool_error, buf)
        _UniffiConverterOptionalUInt64.write(value.receiver_rewards, buf)
        _UniffiConverterOptionalUInt64.write(value.sender_rewards, buf)
        _UniffiConverterOptionalSequenceTypeAccountStateDelta.write(value.local_state_delta, buf)
        _UniffiConverterOptionalTypeStateDelta.write(value.global_state_delta, buf)
        _UniffiConverterOptionalSequenceBytes.write(value.logs, buf)
        _UniffiConverterOptionalSequenceTypePendingTransactionResponse.write(value.inner_txns, buf)
        _UniffiConverterTypeSignedTransaction.write(value.txn, buf)


class RawTransaction:
    """
    Transaction ID of the submission.
    """

    tx_id: "str"
    """
    encoding of the transaction hash.
    """

    def __init__(self, *, tx_id: "str"):
        self.tx_id = tx_id

    def __str__(self):
        return "RawTransaction(tx_id={})".format(self.tx_id)

    def __eq__(self, other):
        if self.tx_id != other.tx_id:
            return False
        return True

class _UniffiConverterTypeRawTransaction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RawTransaction(
            tx_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.tx_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.tx_id, buf)


class ScratchChange:
    """
    A write operation into a scratch slot.
    """

    slot: "int"
    """
    The scratch slot written.
    """

    new_value: "AvmValue"
    def __init__(self, *, slot: "int", new_value: "AvmValue"):
        self.slot = slot
        self.new_value = new_value

    def __str__(self):
        return "ScratchChange(slot={}, new_value={})".format(self.slot, self.new_value)

    def __eq__(self, other):
        if self.slot != other.slot:
            return False
        if self.new_value != other.new_value:
            return False
        return True

class _UniffiConverterTypeScratchChange(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScratchChange(
            slot=_UniffiConverterUInt64.read(buf),
            new_value=_UniffiConverterTypeAvmValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.slot)
        _UniffiConverterTypeAvmValue.check_lower(value.new_value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.slot, buf)
        _UniffiConverterTypeAvmValue.write(value.new_value, buf)


class SimulateInitialStates:
    """
    Initial states of resources that were accessed during simulation.
    """

    app_initial_states: "typing.Optional[typing.List[ApplicationInitialStates]]"
    """
    The initial states of accessed application before simulation. The order of this array is arbitrary.
    """

    def __init__(self, *, app_initial_states: "typing.Optional[typing.List[ApplicationInitialStates]]"):
        self.app_initial_states = app_initial_states

    def __str__(self):
        return "SimulateInitialStates(app_initial_states={})".format(self.app_initial_states)

    def __eq__(self, other):
        if self.app_initial_states != other.app_initial_states:
            return False
        return True

class _UniffiConverterTypeSimulateInitialStates(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateInitialStates(
            app_initial_states=_UniffiConverterOptionalSequenceTypeApplicationInitialStates.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeApplicationInitialStates.check_lower(value.app_initial_states)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeApplicationInitialStates.write(value.app_initial_states, buf)


class SimulateRequest:
    """
    Request type for simulation endpoint.
    """

    txn_groups: "typing.List[SimulateRequestTransactionGroup]"
    """
    The transaction groups to simulate.
    """

    round: "typing.Optional[int]"
    """
    If provided, specifies the round preceding the simulation. State changes through this round will be used to run this simulation. Usually only the 4 most recent rounds will be available (controlled by the node config value MaxAcctLookback). If not specified, defaults to the latest available round.
    """

    allow_empty_signatures: "typing.Optional[bool]"
    """
    Allows transactions without signatures to be simulated as if they had correct signatures.
    """

    allow_more_logging: "typing.Optional[bool]"
    """
    Lifts limits on log opcode usage during simulation.
    """

    allow_unnamed_resources: "typing.Optional[bool]"
    """
    Allows access to unnamed resources during simulation.
    """

    extra_opcode_budget: "typing.Optional[int]"
    """
    Applies extra opcode budget during simulation for each transaction group.
    """

    exec_trace_config: "typing.Optional[SimulateTraceConfig]"
    fix_signers: "typing.Optional[bool]"
    """
    If true, signers for transactions that are missing signatures will be fixed during evaluation.
    """

    def __init__(self, *, txn_groups: "typing.List[SimulateRequestTransactionGroup]", round: "typing.Optional[int]", allow_empty_signatures: "typing.Optional[bool]", allow_more_logging: "typing.Optional[bool]", allow_unnamed_resources: "typing.Optional[bool]", extra_opcode_budget: "typing.Optional[int]", exec_trace_config: "typing.Optional[SimulateTraceConfig]", fix_signers: "typing.Optional[bool]"):
        self.txn_groups = txn_groups
        self.round = round
        self.allow_empty_signatures = allow_empty_signatures
        self.allow_more_logging = allow_more_logging
        self.allow_unnamed_resources = allow_unnamed_resources
        self.extra_opcode_budget = extra_opcode_budget
        self.exec_trace_config = exec_trace_config
        self.fix_signers = fix_signers

    def __str__(self):
        return "SimulateRequest(txn_groups={}, round={}, allow_empty_signatures={}, allow_more_logging={}, allow_unnamed_resources={}, extra_opcode_budget={}, exec_trace_config={}, fix_signers={})".format(self.txn_groups, self.round, self.allow_empty_signatures, self.allow_more_logging, self.allow_unnamed_resources, self.extra_opcode_budget, self.exec_trace_config, self.fix_signers)

    def __eq__(self, other):
        if self.txn_groups != other.txn_groups:
            return False
        if self.round != other.round:
            return False
        if self.allow_empty_signatures != other.allow_empty_signatures:
            return False
        if self.allow_more_logging != other.allow_more_logging:
            return False
        if self.allow_unnamed_resources != other.allow_unnamed_resources:
            return False
        if self.extra_opcode_budget != other.extra_opcode_budget:
            return False
        if self.exec_trace_config != other.exec_trace_config:
            return False
        if self.fix_signers != other.fix_signers:
            return False
        return True

class _UniffiConverterTypeSimulateRequest(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateRequest(
            txn_groups=_UniffiConverterSequenceTypeSimulateRequestTransactionGroup.read(buf),
            round=_UniffiConverterOptionalUInt64.read(buf),
            allow_empty_signatures=_UniffiConverterOptionalBool.read(buf),
            allow_more_logging=_UniffiConverterOptionalBool.read(buf),
            allow_unnamed_resources=_UniffiConverterOptionalBool.read(buf),
            extra_opcode_budget=_UniffiConverterOptionalUInt64.read(buf),
            exec_trace_config=_UniffiConverterOptionalTypeSimulateTraceConfig.read(buf),
            fix_signers=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeSimulateRequestTransactionGroup.check_lower(value.txn_groups)
        _UniffiConverterOptionalUInt64.check_lower(value.round)
        _UniffiConverterOptionalBool.check_lower(value.allow_empty_signatures)
        _UniffiConverterOptionalBool.check_lower(value.allow_more_logging)
        _UniffiConverterOptionalBool.check_lower(value.allow_unnamed_resources)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_opcode_budget)
        _UniffiConverterOptionalTypeSimulateTraceConfig.check_lower(value.exec_trace_config)
        _UniffiConverterOptionalBool.check_lower(value.fix_signers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeSimulateRequestTransactionGroup.write(value.txn_groups, buf)
        _UniffiConverterOptionalUInt64.write(value.round, buf)
        _UniffiConverterOptionalBool.write(value.allow_empty_signatures, buf)
        _UniffiConverterOptionalBool.write(value.allow_more_logging, buf)
        _UniffiConverterOptionalBool.write(value.allow_unnamed_resources, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_opcode_budget, buf)
        _UniffiConverterOptionalTypeSimulateTraceConfig.write(value.exec_trace_config, buf)
        _UniffiConverterOptionalBool.write(value.fix_signers, buf)


class SimulateRequestTransactionGroup:
    """
    A transaction group to simulate.
    """

    txns: "typing.List[SignedTransaction]"
    """
    An atomic transaction group.
    """

    def __init__(self, *, txns: "typing.List[SignedTransaction]"):
        self.txns = txns

    def __str__(self):
        return "SimulateRequestTransactionGroup(txns={})".format(self.txns)

    def __eq__(self, other):
        if self.txns != other.txns:
            return False
        return True

class _UniffiConverterTypeSimulateRequestTransactionGroup(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateRequestTransactionGroup(
            txns=_UniffiConverterSequenceTypeSignedTransaction.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeSignedTransaction.check_lower(value.txns)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeSignedTransaction.write(value.txns, buf)


class SimulateTraceConfig:
    """
    An object that configures simulation execution trace.
    """

    enable: "typing.Optional[bool]"
    """
    A boolean option for opting in execution trace features simulation endpoint.
    """

    stack_change: "typing.Optional[bool]"
    """
    A boolean option enabling returning stack changes together with execution trace during simulation.
    """

    scratch_change: "typing.Optional[bool]"
    """
    A boolean option enabling returning scratch slot changes together with execution trace during simulation.
    """

    state_change: "typing.Optional[bool]"
    """
    A boolean option enabling returning application state changes (global, local, and box changes) with the execution trace during simulation.
    """

    def __init__(self, *, enable: "typing.Optional[bool]", stack_change: "typing.Optional[bool]", scratch_change: "typing.Optional[bool]", state_change: "typing.Optional[bool]"):
        self.enable = enable
        self.stack_change = stack_change
        self.scratch_change = scratch_change
        self.state_change = state_change

    def __str__(self):
        return "SimulateTraceConfig(enable={}, stack_change={}, scratch_change={}, state_change={})".format(self.enable, self.stack_change, self.scratch_change, self.state_change)

    def __eq__(self, other):
        if self.enable != other.enable:
            return False
        if self.stack_change != other.stack_change:
            return False
        if self.scratch_change != other.scratch_change:
            return False
        if self.state_change != other.state_change:
            return False
        return True

class _UniffiConverterTypeSimulateTraceConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateTraceConfig(
            enable=_UniffiConverterOptionalBool.read(buf),
            stack_change=_UniffiConverterOptionalBool.read(buf),
            scratch_change=_UniffiConverterOptionalBool.read(buf),
            state_change=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalBool.check_lower(value.enable)
        _UniffiConverterOptionalBool.check_lower(value.stack_change)
        _UniffiConverterOptionalBool.check_lower(value.scratch_change)
        _UniffiConverterOptionalBool.check_lower(value.state_change)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalBool.write(value.enable, buf)
        _UniffiConverterOptionalBool.write(value.stack_change, buf)
        _UniffiConverterOptionalBool.write(value.scratch_change, buf)
        _UniffiConverterOptionalBool.write(value.state_change, buf)


class SimulateTransaction:
    """
    Result of a transaction group simulation.
    """

    version: "int"
    """
    The version of this response object.
    """

    last_round: "int"
    """
    The round immediately preceding this simulation. State changes through this round were used to run this simulation.
    """

    txn_groups: "typing.List[SimulateTransactionGroupResult]"
    """
    A result object for each transaction group that was simulated.
    """

    eval_overrides: "typing.Optional[SimulationEvalOverrides]"
    exec_trace_config: "typing.Optional[SimulateTraceConfig]"
    initial_states: "typing.Optional[SimulateInitialStates]"
    def __init__(self, *, version: "int", last_round: "int", txn_groups: "typing.List[SimulateTransactionGroupResult]", eval_overrides: "typing.Optional[SimulationEvalOverrides]", exec_trace_config: "typing.Optional[SimulateTraceConfig]", initial_states: "typing.Optional[SimulateInitialStates]"):
        self.version = version
        self.last_round = last_round
        self.txn_groups = txn_groups
        self.eval_overrides = eval_overrides
        self.exec_trace_config = exec_trace_config
        self.initial_states = initial_states

    def __str__(self):
        return "SimulateTransaction(version={}, last_round={}, txn_groups={}, eval_overrides={}, exec_trace_config={}, initial_states={})".format(self.version, self.last_round, self.txn_groups, self.eval_overrides, self.exec_trace_config, self.initial_states)

    def __eq__(self, other):
        if self.version != other.version:
            return False
        if self.last_round != other.last_round:
            return False
        if self.txn_groups != other.txn_groups:
            return False
        if self.eval_overrides != other.eval_overrides:
            return False
        if self.exec_trace_config != other.exec_trace_config:
            return False
        if self.initial_states != other.initial_states:
            return False
        return True

class _UniffiConverterTypeSimulateTransaction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateTransaction(
            version=_UniffiConverterUInt64.read(buf),
            last_round=_UniffiConverterUInt64.read(buf),
            txn_groups=_UniffiConverterSequenceTypeSimulateTransactionGroupResult.read(buf),
            eval_overrides=_UniffiConverterOptionalTypeSimulationEvalOverrides.read(buf),
            exec_trace_config=_UniffiConverterOptionalTypeSimulateTraceConfig.read(buf),
            initial_states=_UniffiConverterOptionalTypeSimulateInitialStates.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.version)
        _UniffiConverterUInt64.check_lower(value.last_round)
        _UniffiConverterSequenceTypeSimulateTransactionGroupResult.check_lower(value.txn_groups)
        _UniffiConverterOptionalTypeSimulationEvalOverrides.check_lower(value.eval_overrides)
        _UniffiConverterOptionalTypeSimulateTraceConfig.check_lower(value.exec_trace_config)
        _UniffiConverterOptionalTypeSimulateInitialStates.check_lower(value.initial_states)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.version, buf)
        _UniffiConverterUInt64.write(value.last_round, buf)
        _UniffiConverterSequenceTypeSimulateTransactionGroupResult.write(value.txn_groups, buf)
        _UniffiConverterOptionalTypeSimulationEvalOverrides.write(value.eval_overrides, buf)
        _UniffiConverterOptionalTypeSimulateTraceConfig.write(value.exec_trace_config, buf)
        _UniffiConverterOptionalTypeSimulateInitialStates.write(value.initial_states, buf)


class SimulateTransactionGroupResult:
    """
    Simulation result for an atomic transaction group
    """

    txn_results: "typing.List[SimulateTransactionResult]"
    """
    Simulation result for individual transactions
    """

    failure_message: "typing.Optional[str]"
    """
    If present, indicates that the transaction group failed and specifies why that happened
    """

    failed_at: "typing.Optional[typing.List[int]]"
    """
    If present, indicates which transaction in this group caused the failure. This array represents the path to the failing transaction. Indexes are zero based, the first element indicates the top-level transaction, and successive elements indicate deeper inner transactions.
    """

    app_budget_added: "typing.Optional[int]"
    """
    Total budget added during execution of app calls in the transaction group.
    """

    app_budget_consumed: "typing.Optional[int]"
    """
    Total budget consumed during execution of app calls in the transaction group.
    """

    unnamed_resources_accessed: "typing.Optional[SimulateUnnamedResourcesAccessed]"
    def __init__(self, *, txn_results: "typing.List[SimulateTransactionResult]", failure_message: "typing.Optional[str]", failed_at: "typing.Optional[typing.List[int]]", app_budget_added: "typing.Optional[int]", app_budget_consumed: "typing.Optional[int]", unnamed_resources_accessed: "typing.Optional[SimulateUnnamedResourcesAccessed]"):
        self.txn_results = txn_results
        self.failure_message = failure_message
        self.failed_at = failed_at
        self.app_budget_added = app_budget_added
        self.app_budget_consumed = app_budget_consumed
        self.unnamed_resources_accessed = unnamed_resources_accessed

    def __str__(self):
        return "SimulateTransactionGroupResult(txn_results={}, failure_message={}, failed_at={}, app_budget_added={}, app_budget_consumed={}, unnamed_resources_accessed={})".format(self.txn_results, self.failure_message, self.failed_at, self.app_budget_added, self.app_budget_consumed, self.unnamed_resources_accessed)

    def __eq__(self, other):
        if self.txn_results != other.txn_results:
            return False
        if self.failure_message != other.failure_message:
            return False
        if self.failed_at != other.failed_at:
            return False
        if self.app_budget_added != other.app_budget_added:
            return False
        if self.app_budget_consumed != other.app_budget_consumed:
            return False
        if self.unnamed_resources_accessed != other.unnamed_resources_accessed:
            return False
        return True

class _UniffiConverterTypeSimulateTransactionGroupResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateTransactionGroupResult(
            txn_results=_UniffiConverterSequenceTypeSimulateTransactionResult.read(buf),
            failure_message=_UniffiConverterOptionalString.read(buf),
            failed_at=_UniffiConverterOptionalSequenceUInt64.read(buf),
            app_budget_added=_UniffiConverterOptionalUInt64.read(buf),
            app_budget_consumed=_UniffiConverterOptionalUInt64.read(buf),
            unnamed_resources_accessed=_UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeSimulateTransactionResult.check_lower(value.txn_results)
        _UniffiConverterOptionalString.check_lower(value.failure_message)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.failed_at)
        _UniffiConverterOptionalUInt64.check_lower(value.app_budget_added)
        _UniffiConverterOptionalUInt64.check_lower(value.app_budget_consumed)
        _UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed.check_lower(value.unnamed_resources_accessed)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeSimulateTransactionResult.write(value.txn_results, buf)
        _UniffiConverterOptionalString.write(value.failure_message, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.failed_at, buf)
        _UniffiConverterOptionalUInt64.write(value.app_budget_added, buf)
        _UniffiConverterOptionalUInt64.write(value.app_budget_consumed, buf)
        _UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed.write(value.unnamed_resources_accessed, buf)


class SimulateTransactionResult:
    """
    Simulation result for an individual transaction
    """

    txn_result: "PendingTransactionResponse"
    app_budget_consumed: "typing.Optional[int]"
    """
    Budget used during execution of an app call transaction. This value includes budged used by inner app calls spawned by this transaction.
    """

    logic_sig_budget_consumed: "typing.Optional[int]"
    """
    Budget used during execution of a logic sig transaction.
    """

    exec_trace: "typing.Optional[SimulationTransactionExecTrace]"
    unnamed_resources_accessed: "typing.Optional[SimulateUnnamedResourcesAccessed]"
    fixed_signer: "typing.Optional[str]"
    """
    The account that needed to sign this transaction when no signature was provided and the provided signer was incorrect.
    """

    def __init__(self, *, txn_result: "PendingTransactionResponse", app_budget_consumed: "typing.Optional[int]", logic_sig_budget_consumed: "typing.Optional[int]", exec_trace: "typing.Optional[SimulationTransactionExecTrace]", unnamed_resources_accessed: "typing.Optional[SimulateUnnamedResourcesAccessed]", fixed_signer: "typing.Optional[str]"):
        self.txn_result = txn_result
        self.app_budget_consumed = app_budget_consumed
        self.logic_sig_budget_consumed = logic_sig_budget_consumed
        self.exec_trace = exec_trace
        self.unnamed_resources_accessed = unnamed_resources_accessed
        self.fixed_signer = fixed_signer

    def __str__(self):
        return "SimulateTransactionResult(txn_result={}, app_budget_consumed={}, logic_sig_budget_consumed={}, exec_trace={}, unnamed_resources_accessed={}, fixed_signer={})".format(self.txn_result, self.app_budget_consumed, self.logic_sig_budget_consumed, self.exec_trace, self.unnamed_resources_accessed, self.fixed_signer)

    def __eq__(self, other):
        if self.txn_result != other.txn_result:
            return False
        if self.app_budget_consumed != other.app_budget_consumed:
            return False
        if self.logic_sig_budget_consumed != other.logic_sig_budget_consumed:
            return False
        if self.exec_trace != other.exec_trace:
            return False
        if self.unnamed_resources_accessed != other.unnamed_resources_accessed:
            return False
        if self.fixed_signer != other.fixed_signer:
            return False
        return True

class _UniffiConverterTypeSimulateTransactionResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateTransactionResult(
            txn_result=_UniffiConverterTypePendingTransactionResponse.read(buf),
            app_budget_consumed=_UniffiConverterOptionalUInt32.read(buf),
            logic_sig_budget_consumed=_UniffiConverterOptionalUInt32.read(buf),
            exec_trace=_UniffiConverterOptionalTypeSimulationTransactionExecTrace.read(buf),
            unnamed_resources_accessed=_UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed.read(buf),
            fixed_signer=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePendingTransactionResponse.check_lower(value.txn_result)
        _UniffiConverterOptionalUInt32.check_lower(value.app_budget_consumed)
        _UniffiConverterOptionalUInt32.check_lower(value.logic_sig_budget_consumed)
        _UniffiConverterOptionalTypeSimulationTransactionExecTrace.check_lower(value.exec_trace)
        _UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed.check_lower(value.unnamed_resources_accessed)
        _UniffiConverterOptionalString.check_lower(value.fixed_signer)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePendingTransactionResponse.write(value.txn_result, buf)
        _UniffiConverterOptionalUInt32.write(value.app_budget_consumed, buf)
        _UniffiConverterOptionalUInt32.write(value.logic_sig_budget_consumed, buf)
        _UniffiConverterOptionalTypeSimulationTransactionExecTrace.write(value.exec_trace, buf)
        _UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed.write(value.unnamed_resources_accessed, buf)
        _UniffiConverterOptionalString.write(value.fixed_signer, buf)


class SimulateUnnamedResourcesAccessed:
    """
    These are resources that were accessed by this group that would normally have caused failure, but were allowed in simulation. Depending on where this object is in the response, the unnamed resources it contains may or may not qualify for group resource sharing. If this is a field in SimulateTransactionGroupResult, the resources do qualify, but if this is a field in SimulateTransactionResult, they do not qualify. In order to make this group valid for actual submission, resources that qualify for group sharing can be made available by any transaction of the group; otherwise, resources must be placed in the same transaction which accessed them.
    """

    accounts: "typing.Optional[typing.List[str]]"
    """
    The unnamed accounts that were referenced. The order of this array is arbitrary.
    """

    assets: "typing.Optional[typing.List[int]]"
    """
    The unnamed assets that were referenced. The order of this array is arbitrary.
    """

    apps: "typing.Optional[typing.List[int]]"
    """
    The unnamed applications that were referenced. The order of this array is arbitrary.
    """

    boxes: "typing.Optional[typing.List[BoxReference]]"
    """
    The unnamed boxes that were referenced. The order of this array is arbitrary.
    """

    extra_box_refs: "typing.Optional[int]"
    """
    The number of extra box references used to increase the IO budget. This is in addition to the references defined in the input transaction group and any referenced to unnamed boxes.
    """

    asset_holdings: "typing.Optional[typing.List[AssetHoldingReference]]"
    """
    The unnamed asset holdings that were referenced. The order of this array is arbitrary.
    """

    app_locals: "typing.Optional[typing.List[ApplicationLocalReference]]"
    """
    The unnamed application local states that were referenced. The order of this array is arbitrary.
    """

    def __init__(self, *, accounts: "typing.Optional[typing.List[str]]", assets: "typing.Optional[typing.List[int]]", apps: "typing.Optional[typing.List[int]]", boxes: "typing.Optional[typing.List[BoxReference]]", extra_box_refs: "typing.Optional[int]", asset_holdings: "typing.Optional[typing.List[AssetHoldingReference]]", app_locals: "typing.Optional[typing.List[ApplicationLocalReference]]"):
        self.accounts = accounts
        self.assets = assets
        self.apps = apps
        self.boxes = boxes
        self.extra_box_refs = extra_box_refs
        self.asset_holdings = asset_holdings
        self.app_locals = app_locals

    def __str__(self):
        return "SimulateUnnamedResourcesAccessed(accounts={}, assets={}, apps={}, boxes={}, extra_box_refs={}, asset_holdings={}, app_locals={})".format(self.accounts, self.assets, self.apps, self.boxes, self.extra_box_refs, self.asset_holdings, self.app_locals)

    def __eq__(self, other):
        if self.accounts != other.accounts:
            return False
        if self.assets != other.assets:
            return False
        if self.apps != other.apps:
            return False
        if self.boxes != other.boxes:
            return False
        if self.extra_box_refs != other.extra_box_refs:
            return False
        if self.asset_holdings != other.asset_holdings:
            return False
        if self.app_locals != other.app_locals:
            return False
        return True

class _UniffiConverterTypeSimulateUnnamedResourcesAccessed(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulateUnnamedResourcesAccessed(
            accounts=_UniffiConverterOptionalSequenceString.read(buf),
            assets=_UniffiConverterOptionalSequenceUInt64.read(buf),
            apps=_UniffiConverterOptionalSequenceUInt64.read(buf),
            boxes=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
            extra_box_refs=_UniffiConverterOptionalUInt64.read(buf),
            asset_holdings=_UniffiConverterOptionalSequenceTypeAssetHoldingReference.read(buf),
            app_locals=_UniffiConverterOptionalSequenceTypeApplicationLocalReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceString.check_lower(value.accounts)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.assets)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.apps)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.boxes)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_box_refs)
        _UniffiConverterOptionalSequenceTypeAssetHoldingReference.check_lower(value.asset_holdings)
        _UniffiConverterOptionalSequenceTypeApplicationLocalReference.check_lower(value.app_locals)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceString.write(value.accounts, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.assets, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.apps, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.boxes, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_box_refs, buf)
        _UniffiConverterOptionalSequenceTypeAssetHoldingReference.write(value.asset_holdings, buf)
        _UniffiConverterOptionalSequenceTypeApplicationLocalReference.write(value.app_locals, buf)


class SimulationEvalOverrides:
    """
    The set of parameters and limits override during simulation. If this set of parameters is present, then evaluation parameters may differ from standard evaluation in certain ways.
    """

    allow_empty_signatures: "typing.Optional[bool]"
    """
    If true, transactions without signatures are allowed and simulated as if they were properly signed.
    """

    allow_unnamed_resources: "typing.Optional[bool]"
    """
    If true, allows access to unnamed resources during simulation.
    """

    max_log_calls: "typing.Optional[int]"
    """
    The maximum log calls one can make during simulation
    """

    max_log_size: "typing.Optional[int]"
    """
    The maximum byte number to log during simulation
    """

    extra_opcode_budget: "typing.Optional[int]"
    """
    The extra opcode budget added to each transaction group during simulation
    """

    fix_signers: "typing.Optional[bool]"
    """
    If true, signers for transactions that are missing signatures will be fixed during evaluation.
    """

    def __init__(self, *, allow_empty_signatures: "typing.Optional[bool]", allow_unnamed_resources: "typing.Optional[bool]", max_log_calls: "typing.Optional[int]", max_log_size: "typing.Optional[int]", extra_opcode_budget: "typing.Optional[int]", fix_signers: "typing.Optional[bool]"):
        self.allow_empty_signatures = allow_empty_signatures
        self.allow_unnamed_resources = allow_unnamed_resources
        self.max_log_calls = max_log_calls
        self.max_log_size = max_log_size
        self.extra_opcode_budget = extra_opcode_budget
        self.fix_signers = fix_signers

    def __str__(self):
        return "SimulationEvalOverrides(allow_empty_signatures={}, allow_unnamed_resources={}, max_log_calls={}, max_log_size={}, extra_opcode_budget={}, fix_signers={})".format(self.allow_empty_signatures, self.allow_unnamed_resources, self.max_log_calls, self.max_log_size, self.extra_opcode_budget, self.fix_signers)

    def __eq__(self, other):
        if self.allow_empty_signatures != other.allow_empty_signatures:
            return False
        if self.allow_unnamed_resources != other.allow_unnamed_resources:
            return False
        if self.max_log_calls != other.max_log_calls:
            return False
        if self.max_log_size != other.max_log_size:
            return False
        if self.extra_opcode_budget != other.extra_opcode_budget:
            return False
        if self.fix_signers != other.fix_signers:
            return False
        return True

class _UniffiConverterTypeSimulationEvalOverrides(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulationEvalOverrides(
            allow_empty_signatures=_UniffiConverterOptionalBool.read(buf),
            allow_unnamed_resources=_UniffiConverterOptionalBool.read(buf),
            max_log_calls=_UniffiConverterOptionalUInt64.read(buf),
            max_log_size=_UniffiConverterOptionalUInt64.read(buf),
            extra_opcode_budget=_UniffiConverterOptionalUInt64.read(buf),
            fix_signers=_UniffiConverterOptionalBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalBool.check_lower(value.allow_empty_signatures)
        _UniffiConverterOptionalBool.check_lower(value.allow_unnamed_resources)
        _UniffiConverterOptionalUInt64.check_lower(value.max_log_calls)
        _UniffiConverterOptionalUInt64.check_lower(value.max_log_size)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_opcode_budget)
        _UniffiConverterOptionalBool.check_lower(value.fix_signers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalBool.write(value.allow_empty_signatures, buf)
        _UniffiConverterOptionalBool.write(value.allow_unnamed_resources, buf)
        _UniffiConverterOptionalUInt64.write(value.max_log_calls, buf)
        _UniffiConverterOptionalUInt64.write(value.max_log_size, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_opcode_budget, buf)
        _UniffiConverterOptionalBool.write(value.fix_signers, buf)


class SimulationOpcodeTraceUnit:
    """
    The set of trace information and effect from evaluating a single opcode.
    """

    pc: "int"
    """
    The program counter of the current opcode being evaluated.
    """

    scratch_changes: "typing.Optional[typing.List[ScratchChange]]"
    """
    The writes into scratch slots.
    """

    state_changes: "typing.Optional[typing.List[ApplicationStateOperation]]"
    """
    The operations against the current application's states.
    """

    spawned_inners: "typing.Optional[typing.List[int]]"
    """
    The indexes of the traces for inner transactions spawned by this opcode, if any.
    """

    stack_pop_count: "typing.Optional[int]"
    """
    The number of deleted stack values by this opcode.
    """

    stack_additions: "typing.Optional[typing.List[AvmValue]]"
    """
    The values added by this opcode to the stack.
    """

    def __init__(self, *, pc: "int", scratch_changes: "typing.Optional[typing.List[ScratchChange]]", state_changes: "typing.Optional[typing.List[ApplicationStateOperation]]", spawned_inners: "typing.Optional[typing.List[int]]", stack_pop_count: "typing.Optional[int]", stack_additions: "typing.Optional[typing.List[AvmValue]]"):
        self.pc = pc
        self.scratch_changes = scratch_changes
        self.state_changes = state_changes
        self.spawned_inners = spawned_inners
        self.stack_pop_count = stack_pop_count
        self.stack_additions = stack_additions

    def __str__(self):
        return "SimulationOpcodeTraceUnit(pc={}, scratch_changes={}, state_changes={}, spawned_inners={}, stack_pop_count={}, stack_additions={})".format(self.pc, self.scratch_changes, self.state_changes, self.spawned_inners, self.stack_pop_count, self.stack_additions)

    def __eq__(self, other):
        if self.pc != other.pc:
            return False
        if self.scratch_changes != other.scratch_changes:
            return False
        if self.state_changes != other.state_changes:
            return False
        if self.spawned_inners != other.spawned_inners:
            return False
        if self.stack_pop_count != other.stack_pop_count:
            return False
        if self.stack_additions != other.stack_additions:
            return False
        return True

class _UniffiConverterTypeSimulationOpcodeTraceUnit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulationOpcodeTraceUnit(
            pc=_UniffiConverterUInt64.read(buf),
            scratch_changes=_UniffiConverterOptionalSequenceTypeScratchChange.read(buf),
            state_changes=_UniffiConverterOptionalSequenceTypeApplicationStateOperation.read(buf),
            spawned_inners=_UniffiConverterOptionalSequenceUInt64.read(buf),
            stack_pop_count=_UniffiConverterOptionalUInt64.read(buf),
            stack_additions=_UniffiConverterOptionalSequenceTypeAvmValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.pc)
        _UniffiConverterOptionalSequenceTypeScratchChange.check_lower(value.scratch_changes)
        _UniffiConverterOptionalSequenceTypeApplicationStateOperation.check_lower(value.state_changes)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.spawned_inners)
        _UniffiConverterOptionalUInt64.check_lower(value.stack_pop_count)
        _UniffiConverterOptionalSequenceTypeAvmValue.check_lower(value.stack_additions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.pc, buf)
        _UniffiConverterOptionalSequenceTypeScratchChange.write(value.scratch_changes, buf)
        _UniffiConverterOptionalSequenceTypeApplicationStateOperation.write(value.state_changes, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.spawned_inners, buf)
        _UniffiConverterOptionalUInt64.write(value.stack_pop_count, buf)
        _UniffiConverterOptionalSequenceTypeAvmValue.write(value.stack_additions, buf)


class SimulationTransactionExecTrace:
    """
    The execution trace of calling an app or a logic sig, containing the inner app call trace in a recursive way.
    """

    approval_program_trace: "typing.Optional[typing.List[SimulationOpcodeTraceUnit]]"
    """
    Program trace that contains a trace of opcode effects in an approval program.
    """

    approval_program_hash: "typing.Optional[bytes]"
    """
    SHA512_256 hash digest of the approval program executed in transaction.
    """

    clear_state_program_trace: "typing.Optional[typing.List[SimulationOpcodeTraceUnit]]"
    """
    Program trace that contains a trace of opcode effects in a clear state program.
    """

    clear_state_program_hash: "typing.Optional[bytes]"
    """
    SHA512_256 hash digest of the clear state program executed in transaction.
    """

    clear_state_rollback: "typing.Optional[bool]"
    """
    If true, indicates that the clear state program failed and any persistent state changes it produced should be reverted once the program exits.
    """

    clear_state_rollback_error: "typing.Optional[str]"
    """
    The error message explaining why the clear state program failed. This field will only be populated if clear-state-rollback is true and the failure was due to an execution error.
    """

    logic_sig_trace: "typing.Optional[typing.List[SimulationOpcodeTraceUnit]]"
    """
    Program trace that contains a trace of opcode effects in a logic sig.
    """

    logic_sig_hash: "typing.Optional[bytes]"
    """
    SHA512_256 hash digest of the logic sig executed in transaction.
    """

    inner_trace: "typing.Optional[typing.List[SimulationTransactionExecTrace]]"
    """
    An array of SimulationTransactionExecTrace representing the execution trace of any inner transactions executed.
    """

    def __init__(self, *, approval_program_trace: "typing.Optional[typing.List[SimulationOpcodeTraceUnit]]", approval_program_hash: "typing.Optional[bytes]", clear_state_program_trace: "typing.Optional[typing.List[SimulationOpcodeTraceUnit]]", clear_state_program_hash: "typing.Optional[bytes]", clear_state_rollback: "typing.Optional[bool]", clear_state_rollback_error: "typing.Optional[str]", logic_sig_trace: "typing.Optional[typing.List[SimulationOpcodeTraceUnit]]", logic_sig_hash: "typing.Optional[bytes]", inner_trace: "typing.Optional[typing.List[SimulationTransactionExecTrace]]"):
        self.approval_program_trace = approval_program_trace
        self.approval_program_hash = approval_program_hash
        self.clear_state_program_trace = clear_state_program_trace
        self.clear_state_program_hash = clear_state_program_hash
        self.clear_state_rollback = clear_state_rollback
        self.clear_state_rollback_error = clear_state_rollback_error
        self.logic_sig_trace = logic_sig_trace
        self.logic_sig_hash = logic_sig_hash
        self.inner_trace = inner_trace

    def __str__(self):
        return "SimulationTransactionExecTrace(approval_program_trace={}, approval_program_hash={}, clear_state_program_trace={}, clear_state_program_hash={}, clear_state_rollback={}, clear_state_rollback_error={}, logic_sig_trace={}, logic_sig_hash={}, inner_trace={})".format(self.approval_program_trace, self.approval_program_hash, self.clear_state_program_trace, self.clear_state_program_hash, self.clear_state_rollback, self.clear_state_rollback_error, self.logic_sig_trace, self.logic_sig_hash, self.inner_trace)

    def __eq__(self, other):
        if self.approval_program_trace != other.approval_program_trace:
            return False
        if self.approval_program_hash != other.approval_program_hash:
            return False
        if self.clear_state_program_trace != other.clear_state_program_trace:
            return False
        if self.clear_state_program_hash != other.clear_state_program_hash:
            return False
        if self.clear_state_rollback != other.clear_state_rollback:
            return False
        if self.clear_state_rollback_error != other.clear_state_rollback_error:
            return False
        if self.logic_sig_trace != other.logic_sig_trace:
            return False
        if self.logic_sig_hash != other.logic_sig_hash:
            return False
        if self.inner_trace != other.inner_trace:
            return False
        return True

class _UniffiConverterTypeSimulationTransactionExecTrace(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SimulationTransactionExecTrace(
            approval_program_trace=_UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.read(buf),
            approval_program_hash=_UniffiConverterOptionalBytes.read(buf),
            clear_state_program_trace=_UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.read(buf),
            clear_state_program_hash=_UniffiConverterOptionalBytes.read(buf),
            clear_state_rollback=_UniffiConverterOptionalBool.read(buf),
            clear_state_rollback_error=_UniffiConverterOptionalString.read(buf),
            logic_sig_trace=_UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.read(buf),
            logic_sig_hash=_UniffiConverterOptionalBytes.read(buf),
            inner_trace=_UniffiConverterOptionalSequenceTypeSimulationTransactionExecTrace.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.check_lower(value.approval_program_trace)
        _UniffiConverterOptionalBytes.check_lower(value.approval_program_hash)
        _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.check_lower(value.clear_state_program_trace)
        _UniffiConverterOptionalBytes.check_lower(value.clear_state_program_hash)
        _UniffiConverterOptionalBool.check_lower(value.clear_state_rollback)
        _UniffiConverterOptionalString.check_lower(value.clear_state_rollback_error)
        _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.check_lower(value.logic_sig_trace)
        _UniffiConverterOptionalBytes.check_lower(value.logic_sig_hash)
        _UniffiConverterOptionalSequenceTypeSimulationTransactionExecTrace.check_lower(value.inner_trace)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.write(value.approval_program_trace, buf)
        _UniffiConverterOptionalBytes.write(value.approval_program_hash, buf)
        _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.write(value.clear_state_program_trace, buf)
        _UniffiConverterOptionalBytes.write(value.clear_state_program_hash, buf)
        _UniffiConverterOptionalBool.write(value.clear_state_rollback, buf)
        _UniffiConverterOptionalString.write(value.clear_state_rollback_error, buf)
        _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit.write(value.logic_sig_trace, buf)
        _UniffiConverterOptionalBytes.write(value.logic_sig_hash, buf)
        _UniffiConverterOptionalSequenceTypeSimulationTransactionExecTrace.write(value.inner_trace, buf)


class StartCatchup:
    """
    An catchpoint start response.
    """

    catchup_message: "str"
    """
    Catchup start response string
    """

    def __init__(self, *, catchup_message: "str"):
        self.catchup_message = catchup_message

    def __str__(self):
        return "StartCatchup(catchup_message={})".format(self.catchup_message)

    def __eq__(self, other):
        if self.catchup_message != other.catchup_message:
            return False
        return True

class _UniffiConverterTypeStartCatchup(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StartCatchup(
            catchup_message=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.catchup_message)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.catchup_message, buf)


class StateProof:
    """
    Represents a state proof and its corresponding message
    """

    message: "StateProofMessage"
    state_proof: "bytes"
    """
    The encoded StateProof for the message.
    """

    def __init__(self, *, message: "StateProofMessage", state_proof: "bytes"):
        self.message = message
        self.state_proof = state_proof

    def __str__(self):
        return "StateProof(message={}, state_proof={})".format(self.message, self.state_proof)

    def __eq__(self, other):
        if self.message != other.message:
            return False
        if self.state_proof != other.state_proof:
            return False
        return True

class _UniffiConverterTypeStateProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateProof(
            message=_UniffiConverterTypeStateProofMessage.read(buf),
            state_proof=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeStateProofMessage.check_lower(value.message)
        _UniffiConverterBytes.check_lower(value.state_proof)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeStateProofMessage.write(value.message, buf)
        _UniffiConverterBytes.write(value.state_proof, buf)


class StateProofMessage:
    """
    Represents the message that the state proofs are attesting to.
    """

    block_headers_commitment: "bytes"
    """
    The vector commitment root on all light block headers within a state proof interval.
    """

    voters_commitment: "bytes"
    """
    The vector commitment root of the top N accounts to sign the next StateProof.
    """

    ln_proven_weight: "int"
    """
    An integer value representing the natural log of the proven weight with 16 bits of precision. This value would be used to verify the next state proof.
    """

    first_attested_round: "int"
    """
    The first round the message attests to.
    """

    last_attested_round: "int"
    """
    The last round the message attests to.
    """

    def __init__(self, *, block_headers_commitment: "bytes", voters_commitment: "bytes", ln_proven_weight: "int", first_attested_round: "int", last_attested_round: "int"):
        self.block_headers_commitment = block_headers_commitment
        self.voters_commitment = voters_commitment
        self.ln_proven_weight = ln_proven_weight
        self.first_attested_round = first_attested_round
        self.last_attested_round = last_attested_round

    def __str__(self):
        return "StateProofMessage(block_headers_commitment={}, voters_commitment={}, ln_proven_weight={}, first_attested_round={}, last_attested_round={})".format(self.block_headers_commitment, self.voters_commitment, self.ln_proven_weight, self.first_attested_round, self.last_attested_round)

    def __eq__(self, other):
        if self.block_headers_commitment != other.block_headers_commitment:
            return False
        if self.voters_commitment != other.voters_commitment:
            return False
        if self.ln_proven_weight != other.ln_proven_weight:
            return False
        if self.first_attested_round != other.first_attested_round:
            return False
        if self.last_attested_round != other.last_attested_round:
            return False
        return True

class _UniffiConverterTypeStateProofMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateProofMessage(
            block_headers_commitment=_UniffiConverterBytes.read(buf),
            voters_commitment=_UniffiConverterBytes.read(buf),
            ln_proven_weight=_UniffiConverterUInt64.read(buf),
            first_attested_round=_UniffiConverterUInt64.read(buf),
            last_attested_round=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.block_headers_commitment)
        _UniffiConverterBytes.check_lower(value.voters_commitment)
        _UniffiConverterUInt64.check_lower(value.ln_proven_weight)
        _UniffiConverterUInt64.check_lower(value.first_attested_round)
        _UniffiConverterUInt64.check_lower(value.last_attested_round)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.block_headers_commitment, buf)
        _UniffiConverterBytes.write(value.voters_commitment, buf)
        _UniffiConverterUInt64.write(value.ln_proven_weight, buf)
        _UniffiConverterUInt64.write(value.first_attested_round, buf)
        _UniffiConverterUInt64.write(value.last_attested_round, buf)


class TealCompile:
    """
    Teal compile Result
    """

    hash: "str"
    """
    base32 SHA512_256 of program bytes (Address style)
    """

    result: "bytes"
    """
    base64 encoded program bytes
    """

    sourcemap: "typing.Optional[UnknownJsonValue]"
    """
    JSON of the source map
    """

    def __init__(self, *, hash: "str", result: "bytes", sourcemap: "typing.Optional[UnknownJsonValue]"):
        self.hash = hash
        self.result = result
        self.sourcemap = sourcemap

    def __str__(self):
        return "TealCompile(hash={}, result={}, sourcemap={})".format(self.hash, self.result, self.sourcemap)

    def __eq__(self, other):
        if self.hash != other.hash:
            return False
        if self.result != other.result:
            return False
        if self.sourcemap != other.sourcemap:
            return False
        return True

class _UniffiConverterTypeTealCompile(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TealCompile(
            hash=_UniffiConverterString.read(buf),
            result=_UniffiConverterBytes.read(buf),
            sourcemap=_UniffiConverterOptionalTypeUnknownJsonValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.hash)
        _UniffiConverterBytes.check_lower(value.result)
        _UniffiConverterOptionalTypeUnknownJsonValue.check_lower(value.sourcemap)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.hash, buf)
        _UniffiConverterBytes.write(value.result, buf)
        _UniffiConverterOptionalTypeUnknownJsonValue.write(value.sourcemap, buf)


class TealDisassemble:
    """
    Teal disassembly Result
    """

    result: "str"
    """
    disassembled Teal code
    """

    def __init__(self, *, result: "str"):
        self.result = result

    def __str__(self):
        return "TealDisassemble(result={})".format(self.result)

    def __eq__(self, other):
        if self.result != other.result:
            return False
        return True

class _UniffiConverterTypeTealDisassemble(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TealDisassemble(
            result=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.result)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.result, buf)


class TealDryrun:
    """
    DryrunResponse contains per-txn debug information from a dryrun.
    """

    txns: "typing.List[DryrunTxnResult]"
    error: "str"
    protocol_version: "str"
    """
    Protocol version is the protocol version Dryrun was operated under.
    """

    def __init__(self, *, txns: "typing.List[DryrunTxnResult]", error: "str", protocol_version: "str"):
        self.txns = txns
        self.error = error
        self.protocol_version = protocol_version

    def __str__(self):
        return "TealDryrun(txns={}, error={}, protocol_version={})".format(self.txns, self.error, self.protocol_version)

    def __eq__(self, other):
        if self.txns != other.txns:
            return False
        if self.error != other.error:
            return False
        if self.protocol_version != other.protocol_version:
            return False
        return True

class _UniffiConverterTypeTealDryrun(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TealDryrun(
            txns=_UniffiConverterSequenceTypeDryrunTxnResult.read(buf),
            error=_UniffiConverterString.read(buf),
            protocol_version=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeDryrunTxnResult.check_lower(value.txns)
        _UniffiConverterString.check_lower(value.error)
        _UniffiConverterString.check_lower(value.protocol_version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeDryrunTxnResult.write(value.txns, buf)
        _UniffiConverterString.write(value.error, buf)
        _UniffiConverterString.write(value.protocol_version, buf)


class TealKeyValue:
    """
    Represents a key-value pair in an application store.
    """

    key: "str"
    value: "TealValue"
    def __init__(self, *, key: "str", value: "TealValue"):
        self.key = key
        self.value = value

    def __str__(self):
        return "TealKeyValue(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeTealKeyValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TealKeyValue(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterTypeTealValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterTypeTealValue.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterTypeTealValue.write(value.value, buf)


class TealValue:
    """
    Represents a TEAL value.
    """

    type: "int"
    """
    [tt] value type. Value `1` refers to **bytes**, value `2` refers to **uint**
    """

    bytes: "bytes"
    """
    [tb] bytes value.
    """

    uint: "int"
    """
    [ui] uint value.
    """

    def __init__(self, *, type: "int", bytes: "bytes", uint: "int"):
        self.type = type
        self.bytes = bytes
        self.uint = uint

    def __str__(self):
        return "TealValue(type={}, bytes={}, uint={})".format(self.type, self.bytes, self.uint)

    def __eq__(self, other):
        if self.type != other.type:
            return False
        if self.bytes != other.bytes:
            return False
        if self.uint != other.uint:
            return False
        return True

class _UniffiConverterTypeTealValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TealValue(
            type=_UniffiConverterUInt64.read(buf),
            bytes=_UniffiConverterBytes.read(buf),
            uint=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.type)
        _UniffiConverterBytes.check_lower(value.bytes)
        _UniffiConverterUInt64.check_lower(value.uint)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.type, buf)
        _UniffiConverterBytes.write(value.bytes, buf)
        _UniffiConverterUInt64.write(value.uint, buf)


class TransactionParams:
    """
    TransactionParams contains the parameters that help a client construct
    a new transaction.
    """

    consensus_version: "str"
    """
    ConsensusVersion indicates the consensus protocol version
    as of LastRound.
    """

    fee: "int"
    """
    Fee is the suggested transaction fee
    Fee is in units of micro-Algos per byte.
    Fee may fall to zero but transactions must still have a fee of
    at least MinTxnFee for the current network protocol.
    """

    genesis_hash: "bytes"
    """
    GenesisHash is the hash of the genesis block.
    """

    genesis_id: "str"
    """
    GenesisID is an ID listed in the genesis block.
    """

    last_round: "int"
    """
    LastRound indicates the last round seen
    """

    min_fee: "int"
    """
    The minimum transaction fee (not per byte) required for the
    txn to validate for the current network protocol.
    """

    def __init__(self, *, consensus_version: "str", fee: "int", genesis_hash: "bytes", genesis_id: "str", last_round: "int", min_fee: "int"):
        self.consensus_version = consensus_version
        self.fee = fee
        self.genesis_hash = genesis_hash
        self.genesis_id = genesis_id
        self.last_round = last_round
        self.min_fee = min_fee

    def __str__(self):
        return "TransactionParams(consensus_version={}, fee={}, genesis_hash={}, genesis_id={}, last_round={}, min_fee={})".format(self.consensus_version, self.fee, self.genesis_hash, self.genesis_id, self.last_round, self.min_fee)

    def __eq__(self, other):
        if self.consensus_version != other.consensus_version:
            return False
        if self.fee != other.fee:
            return False
        if self.genesis_hash != other.genesis_hash:
            return False
        if self.genesis_id != other.genesis_id:
            return False
        if self.last_round != other.last_round:
            return False
        if self.min_fee != other.min_fee:
            return False
        return True

class _UniffiConverterTypeTransactionParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionParams(
            consensus_version=_UniffiConverterString.read(buf),
            fee=_UniffiConverterUInt64.read(buf),
            genesis_hash=_UniffiConverterBytes.read(buf),
            genesis_id=_UniffiConverterString.read(buf),
            last_round=_UniffiConverterUInt64.read(buf),
            min_fee=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.consensus_version)
        _UniffiConverterUInt64.check_lower(value.fee)
        _UniffiConverterBytes.check_lower(value.genesis_hash)
        _UniffiConverterString.check_lower(value.genesis_id)
        _UniffiConverterUInt64.check_lower(value.last_round)
        _UniffiConverterUInt64.check_lower(value.min_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.consensus_version, buf)
        _UniffiConverterUInt64.write(value.fee, buf)
        _UniffiConverterBytes.write(value.genesis_hash, buf)
        _UniffiConverterString.write(value.genesis_id, buf)
        _UniffiConverterUInt64.write(value.last_round, buf)
        _UniffiConverterUInt64.write(value.min_fee, buf)


class TransactionProof:
    """
    Proof of transaction in a block.
    """

    proof: "bytes"
    """
    Proof of transaction membership.
    """

    stibhash: "bytes"
    """
    Hash of SignedTxnInBlock for verifying proof.
    """

    treedepth: "int"
    """
    Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root.
    """

    idx: "int"
    """
    Index of the transaction in the block's payset.
    """

    hashtype: "str"
    """
    The type of hash function used to create the proof, must be one of:
    * sha512_256
    * sha256
    """

    def __init__(self, *, proof: "bytes", stibhash: "bytes", treedepth: "int", idx: "int", hashtype: "str"):
        self.proof = proof
        self.stibhash = stibhash
        self.treedepth = treedepth
        self.idx = idx
        self.hashtype = hashtype

    def __str__(self):
        return "TransactionProof(proof={}, stibhash={}, treedepth={}, idx={}, hashtype={})".format(self.proof, self.stibhash, self.treedepth, self.idx, self.hashtype)

    def __eq__(self, other):
        if self.proof != other.proof:
            return False
        if self.stibhash != other.stibhash:
            return False
        if self.treedepth != other.treedepth:
            return False
        if self.idx != other.idx:
            return False
        if self.hashtype != other.hashtype:
            return False
        return True

class _UniffiConverterTypeTransactionProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionProof(
            proof=_UniffiConverterBytes.read(buf),
            stibhash=_UniffiConverterBytes.read(buf),
            treedepth=_UniffiConverterUInt64.read(buf),
            idx=_UniffiConverterUInt64.read(buf),
            hashtype=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.proof)
        _UniffiConverterBytes.check_lower(value.stibhash)
        _UniffiConverterUInt64.check_lower(value.treedepth)
        _UniffiConverterUInt64.check_lower(value.idx)
        _UniffiConverterString.check_lower(value.hashtype)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.proof, buf)
        _UniffiConverterBytes.write(value.stibhash, buf)
        _UniffiConverterUInt64.write(value.treedepth, buf)
        _UniffiConverterUInt64.write(value.idx, buf)
        _UniffiConverterString.write(value.hashtype, buf)


class Version:
    """
    algod version information.
    """

    build: "BuildVersion"
    genesis_hash_b64: "bytes"
    genesis_id: "str"
    versions: "typing.List[str]"
    def __init__(self, *, build: "BuildVersion", genesis_hash_b64: "bytes", genesis_id: "str", versions: "typing.List[str]"):
        self.build = build
        self.genesis_hash_b64 = genesis_hash_b64
        self.genesis_id = genesis_id
        self.versions = versions

    def __str__(self):
        return "Version(build={}, genesis_hash_b64={}, genesis_id={}, versions={})".format(self.build, self.genesis_hash_b64, self.genesis_id, self.versions)

    def __eq__(self, other):
        if self.build != other.build:
            return False
        if self.genesis_hash_b64 != other.genesis_hash_b64:
            return False
        if self.genesis_id != other.genesis_id:
            return False
        if self.versions != other.versions:
            return False
        return True

class _UniffiConverterTypeVersion(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Version(
            build=_UniffiConverterTypeBuildVersion.read(buf),
            genesis_hash_b64=_UniffiConverterBytes.read(buf),
            genesis_id=_UniffiConverterString.read(buf),
            versions=_UniffiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeBuildVersion.check_lower(value.build)
        _UniffiConverterBytes.check_lower(value.genesis_hash_b64)
        _UniffiConverterString.check_lower(value.genesis_id)
        _UniffiConverterSequenceString.check_lower(value.versions)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeBuildVersion.write(value.build, buf)
        _UniffiConverterBytes.write(value.genesis_hash_b64, buf)
        _UniffiConverterString.write(value.genesis_id, buf)
        _UniffiConverterSequenceString.write(value.versions, buf)


class WaitForBlock:
    """
    NodeStatus contains the information about a node status
    """

    catchup_time: "int"
    """
    CatchupTime in nanoseconds
    """

    last_round: "int"
    """
    LastRound indicates the last round seen
    """

    last_version: "str"
    """
    LastVersion indicates the last consensus version supported
    """

    next_version: "str"
    """
    NextVersion of consensus protocol to use
    """

    next_version_round: "int"
    """
    NextVersionRound is the round at which the next consensus version will apply
    """

    next_version_supported: "bool"
    """
    NextVersionSupported indicates whether the next consensus version is supported by this node
    """

    stopped_at_unsupported_round: "bool"
    """
    StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
    """

    time_since_last_round: "int"
    """
    TimeSinceLastRound in nanoseconds
    """

    last_catchpoint: "typing.Optional[str]"
    """
    The last catchpoint seen by the node
    """

    catchpoint: "typing.Optional[str]"
    """
    The current catchpoint that is being caught up to
    """

    catchpoint_total_accounts: "typing.Optional[int]"
    """
    The total number of accounts included in the current catchpoint
    """

    catchpoint_processed_accounts: "typing.Optional[int]"
    """
    The number of accounts from the current catchpoint that have been processed so far as part of the catchup
    """

    catchpoint_verified_accounts: "typing.Optional[int]"
    """
    The number of accounts from the current catchpoint that have been verified so far as part of the catchup
    """

    catchpoint_total_kvs: "typing.Optional[int]"
    """
    The total number of key-values (KVs) included in the current catchpoint
    """

    catchpoint_processed_kvs: "typing.Optional[int]"
    """
    The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
    """

    catchpoint_verified_kvs: "typing.Optional[int]"
    """
    The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
    """

    catchpoint_total_blocks: "typing.Optional[int]"
    """
    The total number of blocks that are required to complete the current catchpoint catchup
    """

    catchpoint_acquired_blocks: "typing.Optional[int]"
    """
    The number of blocks that have already been obtained by the node as part of the catchup
    """

    upgrade_delay: "typing.Optional[int]"
    """
    Upgrade delay
    """

    upgrade_node_vote: "typing.Optional[bool]"
    """
    This node's upgrade vote
    """

    upgrade_votes_required: "typing.Optional[int]"
    """
    Yes votes required for consensus upgrade
    """

    upgrade_votes: "typing.Optional[int]"
    """
    Total votes cast for consensus upgrade
    """

    upgrade_yes_votes: "typing.Optional[int]"
    """
    Yes votes cast for consensus upgrade
    """

    upgrade_no_votes: "typing.Optional[int]"
    """
    No votes cast for consensus upgrade
    """

    upgrade_next_protocol_vote_before: "typing.Optional[int]"
    """
    Next protocol round
    """

    upgrade_vote_rounds: "typing.Optional[int]"
    """
    Total voting rounds for current upgrade
    """

    def __init__(self, *, catchup_time: "int", last_round: "int", last_version: "str", next_version: "str", next_version_round: "int", next_version_supported: "bool", stopped_at_unsupported_round: "bool", time_since_last_round: "int", last_catchpoint: "typing.Optional[str]", catchpoint: "typing.Optional[str]", catchpoint_total_accounts: "typing.Optional[int]", catchpoint_processed_accounts: "typing.Optional[int]", catchpoint_verified_accounts: "typing.Optional[int]", catchpoint_total_kvs: "typing.Optional[int]", catchpoint_processed_kvs: "typing.Optional[int]", catchpoint_verified_kvs: "typing.Optional[int]", catchpoint_total_blocks: "typing.Optional[int]", catchpoint_acquired_blocks: "typing.Optional[int]", upgrade_delay: "typing.Optional[int]", upgrade_node_vote: "typing.Optional[bool]", upgrade_votes_required: "typing.Optional[int]", upgrade_votes: "typing.Optional[int]", upgrade_yes_votes: "typing.Optional[int]", upgrade_no_votes: "typing.Optional[int]", upgrade_next_protocol_vote_before: "typing.Optional[int]", upgrade_vote_rounds: "typing.Optional[int]"):
        self.catchup_time = catchup_time
        self.last_round = last_round
        self.last_version = last_version
        self.next_version = next_version
        self.next_version_round = next_version_round
        self.next_version_supported = next_version_supported
        self.stopped_at_unsupported_round = stopped_at_unsupported_round
        self.time_since_last_round = time_since_last_round
        self.last_catchpoint = last_catchpoint
        self.catchpoint = catchpoint
        self.catchpoint_total_accounts = catchpoint_total_accounts
        self.catchpoint_processed_accounts = catchpoint_processed_accounts
        self.catchpoint_verified_accounts = catchpoint_verified_accounts
        self.catchpoint_total_kvs = catchpoint_total_kvs
        self.catchpoint_processed_kvs = catchpoint_processed_kvs
        self.catchpoint_verified_kvs = catchpoint_verified_kvs
        self.catchpoint_total_blocks = catchpoint_total_blocks
        self.catchpoint_acquired_blocks = catchpoint_acquired_blocks
        self.upgrade_delay = upgrade_delay
        self.upgrade_node_vote = upgrade_node_vote
        self.upgrade_votes_required = upgrade_votes_required
        self.upgrade_votes = upgrade_votes
        self.upgrade_yes_votes = upgrade_yes_votes
        self.upgrade_no_votes = upgrade_no_votes
        self.upgrade_next_protocol_vote_before = upgrade_next_protocol_vote_before
        self.upgrade_vote_rounds = upgrade_vote_rounds

    def __str__(self):
        return "WaitForBlock(catchup_time={}, last_round={}, last_version={}, next_version={}, next_version_round={}, next_version_supported={}, stopped_at_unsupported_round={}, time_since_last_round={}, last_catchpoint={}, catchpoint={}, catchpoint_total_accounts={}, catchpoint_processed_accounts={}, catchpoint_verified_accounts={}, catchpoint_total_kvs={}, catchpoint_processed_kvs={}, catchpoint_verified_kvs={}, catchpoint_total_blocks={}, catchpoint_acquired_blocks={}, upgrade_delay={}, upgrade_node_vote={}, upgrade_votes_required={}, upgrade_votes={}, upgrade_yes_votes={}, upgrade_no_votes={}, upgrade_next_protocol_vote_before={}, upgrade_vote_rounds={})".format(self.catchup_time, self.last_round, self.last_version, self.next_version, self.next_version_round, self.next_version_supported, self.stopped_at_unsupported_round, self.time_since_last_round, self.last_catchpoint, self.catchpoint, self.catchpoint_total_accounts, self.catchpoint_processed_accounts, self.catchpoint_verified_accounts, self.catchpoint_total_kvs, self.catchpoint_processed_kvs, self.catchpoint_verified_kvs, self.catchpoint_total_blocks, self.catchpoint_acquired_blocks, self.upgrade_delay, self.upgrade_node_vote, self.upgrade_votes_required, self.upgrade_votes, self.upgrade_yes_votes, self.upgrade_no_votes, self.upgrade_next_protocol_vote_before, self.upgrade_vote_rounds)

    def __eq__(self, other):
        if self.catchup_time != other.catchup_time:
            return False
        if self.last_round != other.last_round:
            return False
        if self.last_version != other.last_version:
            return False
        if self.next_version != other.next_version:
            return False
        if self.next_version_round != other.next_version_round:
            return False
        if self.next_version_supported != other.next_version_supported:
            return False
        if self.stopped_at_unsupported_round != other.stopped_at_unsupported_round:
            return False
        if self.time_since_last_round != other.time_since_last_round:
            return False
        if self.last_catchpoint != other.last_catchpoint:
            return False
        if self.catchpoint != other.catchpoint:
            return False
        if self.catchpoint_total_accounts != other.catchpoint_total_accounts:
            return False
        if self.catchpoint_processed_accounts != other.catchpoint_processed_accounts:
            return False
        if self.catchpoint_verified_accounts != other.catchpoint_verified_accounts:
            return False
        if self.catchpoint_total_kvs != other.catchpoint_total_kvs:
            return False
        if self.catchpoint_processed_kvs != other.catchpoint_processed_kvs:
            return False
        if self.catchpoint_verified_kvs != other.catchpoint_verified_kvs:
            return False
        if self.catchpoint_total_blocks != other.catchpoint_total_blocks:
            return False
        if self.catchpoint_acquired_blocks != other.catchpoint_acquired_blocks:
            return False
        if self.upgrade_delay != other.upgrade_delay:
            return False
        if self.upgrade_node_vote != other.upgrade_node_vote:
            return False
        if self.upgrade_votes_required != other.upgrade_votes_required:
            return False
        if self.upgrade_votes != other.upgrade_votes:
            return False
        if self.upgrade_yes_votes != other.upgrade_yes_votes:
            return False
        if self.upgrade_no_votes != other.upgrade_no_votes:
            return False
        if self.upgrade_next_protocol_vote_before != other.upgrade_next_protocol_vote_before:
            return False
        if self.upgrade_vote_rounds != other.upgrade_vote_rounds:
            return False
        return True

class _UniffiConverterTypeWaitForBlock(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WaitForBlock(
            catchup_time=_UniffiConverterUInt64.read(buf),
            last_round=_UniffiConverterUInt64.read(buf),
            last_version=_UniffiConverterString.read(buf),
            next_version=_UniffiConverterString.read(buf),
            next_version_round=_UniffiConverterUInt64.read(buf),
            next_version_supported=_UniffiConverterBool.read(buf),
            stopped_at_unsupported_round=_UniffiConverterBool.read(buf),
            time_since_last_round=_UniffiConverterUInt64.read(buf),
            last_catchpoint=_UniffiConverterOptionalString.read(buf),
            catchpoint=_UniffiConverterOptionalString.read(buf),
            catchpoint_total_accounts=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_processed_accounts=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_verified_accounts=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_total_kvs=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_processed_kvs=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_verified_kvs=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_total_blocks=_UniffiConverterOptionalUInt64.read(buf),
            catchpoint_acquired_blocks=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_delay=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_node_vote=_UniffiConverterOptionalBool.read(buf),
            upgrade_votes_required=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_votes=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_yes_votes=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_no_votes=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_next_protocol_vote_before=_UniffiConverterOptionalUInt64.read(buf),
            upgrade_vote_rounds=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.catchup_time)
        _UniffiConverterUInt64.check_lower(value.last_round)
        _UniffiConverterString.check_lower(value.last_version)
        _UniffiConverterString.check_lower(value.next_version)
        _UniffiConverterUInt64.check_lower(value.next_version_round)
        _UniffiConverterBool.check_lower(value.next_version_supported)
        _UniffiConverterBool.check_lower(value.stopped_at_unsupported_round)
        _UniffiConverterUInt64.check_lower(value.time_since_last_round)
        _UniffiConverterOptionalString.check_lower(value.last_catchpoint)
        _UniffiConverterOptionalString.check_lower(value.catchpoint)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_total_accounts)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_processed_accounts)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_verified_accounts)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_total_kvs)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_processed_kvs)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_verified_kvs)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_total_blocks)
        _UniffiConverterOptionalUInt64.check_lower(value.catchpoint_acquired_blocks)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_delay)
        _UniffiConverterOptionalBool.check_lower(value.upgrade_node_vote)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_votes_required)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_votes)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_yes_votes)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_no_votes)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_next_protocol_vote_before)
        _UniffiConverterOptionalUInt64.check_lower(value.upgrade_vote_rounds)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.catchup_time, buf)
        _UniffiConverterUInt64.write(value.last_round, buf)
        _UniffiConverterString.write(value.last_version, buf)
        _UniffiConverterString.write(value.next_version, buf)
        _UniffiConverterUInt64.write(value.next_version_round, buf)
        _UniffiConverterBool.write(value.next_version_supported, buf)
        _UniffiConverterBool.write(value.stopped_at_unsupported_round, buf)
        _UniffiConverterUInt64.write(value.time_since_last_round, buf)
        _UniffiConverterOptionalString.write(value.last_catchpoint, buf)
        _UniffiConverterOptionalString.write(value.catchpoint, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_total_accounts, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_processed_accounts, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_verified_accounts, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_total_kvs, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_processed_kvs, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_verified_kvs, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_total_blocks, buf)
        _UniffiConverterOptionalUInt64.write(value.catchpoint_acquired_blocks, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_delay, buf)
        _UniffiConverterOptionalBool.write(value.upgrade_node_vote, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_votes_required, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_votes, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_yes_votes, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_no_votes, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_next_protocol_vote_before, buf)
        _UniffiConverterOptionalUInt64.write(value.upgrade_vote_rounds, buf)


# AbortCatchupError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AbortCatchupError(Exception):
    """
    struct for typed errors of method [`abort_catchup`]
    """

    pass

_UniffiTempAbortCatchupError = AbortCatchupError

class AbortCatchupError:  # type: ignore
    """
    struct for typed errors of method [`abort_catchup`]
    """

    class Status400(_UniffiTempAbortCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AbortCatchupError.Status400({})".format(str(self))
    _UniffiTempAbortCatchupError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAbortCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AbortCatchupError.Status401({})".format(str(self))
    _UniffiTempAbortCatchupError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempAbortCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AbortCatchupError.Status500({})".format(str(self))
    _UniffiTempAbortCatchupError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempAbortCatchupError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AbortCatchupError.Statusdefault({})".format(str(self))
    _UniffiTempAbortCatchupError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAbortCatchupError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AbortCatchupError.DefaultResponse({})".format(str(self))
    _UniffiTempAbortCatchupError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAbortCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AbortCatchupError.UnknownValue({})".format(str(self))
    _UniffiTempAbortCatchupError.UnknownValue = UnknownValue # type: ignore

AbortCatchupError = _UniffiTempAbortCatchupError # type: ignore
del _UniffiTempAbortCatchupError


class _UniffiConverterTypeAbortCatchupError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AbortCatchupError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AbortCatchupError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AbortCatchupError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AbortCatchupError.Statusdefault(
            )
        if variant == 5:
            return AbortCatchupError.DefaultResponse(
            )
        if variant == 6:
            return AbortCatchupError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AbortCatchupError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AbortCatchupError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AbortCatchupError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AbortCatchupError.Statusdefault):
            return
        if isinstance(value, AbortCatchupError.DefaultResponse):
            return
        if isinstance(value, AbortCatchupError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AbortCatchupError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AbortCatchupError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AbortCatchupError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AbortCatchupError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, AbortCatchupError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, AbortCatchupError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# AccountApplicationInformationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AccountApplicationInformationError(Exception):
    """
    struct for typed errors of method [`account_application_information`]
    """

    pass

_UniffiTempAccountApplicationInformationError = AccountApplicationInformationError

class AccountApplicationInformationError:  # type: ignore
    """
    struct for typed errors of method [`account_application_information`]
    """

    class Status400(_UniffiTempAccountApplicationInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountApplicationInformationError.Status400({})".format(str(self))
    _UniffiTempAccountApplicationInformationError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAccountApplicationInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountApplicationInformationError.Status401({})".format(str(self))
    _UniffiTempAccountApplicationInformationError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempAccountApplicationInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountApplicationInformationError.Status500({})".format(str(self))
    _UniffiTempAccountApplicationInformationError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempAccountApplicationInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountApplicationInformationError.Statusdefault({})".format(str(self))
    _UniffiTempAccountApplicationInformationError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAccountApplicationInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountApplicationInformationError.DefaultResponse({})".format(str(self))
    _UniffiTempAccountApplicationInformationError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAccountApplicationInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountApplicationInformationError.UnknownValue({})".format(str(self))
    _UniffiTempAccountApplicationInformationError.UnknownValue = UnknownValue # type: ignore

AccountApplicationInformationError = _UniffiTempAccountApplicationInformationError # type: ignore
del _UniffiTempAccountApplicationInformationError


class _UniffiConverterTypeAccountApplicationInformationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountApplicationInformationError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AccountApplicationInformationError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AccountApplicationInformationError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AccountApplicationInformationError.Statusdefault(
            )
        if variant == 5:
            return AccountApplicationInformationError.DefaultResponse(
            )
        if variant == 6:
            return AccountApplicationInformationError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AccountApplicationInformationError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountApplicationInformationError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountApplicationInformationError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountApplicationInformationError.Statusdefault):
            return
        if isinstance(value, AccountApplicationInformationError.DefaultResponse):
            return
        if isinstance(value, AccountApplicationInformationError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AccountApplicationInformationError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountApplicationInformationError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountApplicationInformationError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountApplicationInformationError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, AccountApplicationInformationError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, AccountApplicationInformationError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# AccountAssetInformationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AccountAssetInformationError(Exception):
    """
    struct for typed errors of method [`account_asset_information`]
    """

    pass

_UniffiTempAccountAssetInformationError = AccountAssetInformationError

class AccountAssetInformationError:  # type: ignore
    """
    struct for typed errors of method [`account_asset_information`]
    """

    class Status400(_UniffiTempAccountAssetInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetInformationError.Status400({})".format(str(self))
    _UniffiTempAccountAssetInformationError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAccountAssetInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetInformationError.Status401({})".format(str(self))
    _UniffiTempAccountAssetInformationError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempAccountAssetInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetInformationError.Status500({})".format(str(self))
    _UniffiTempAccountAssetInformationError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempAccountAssetInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountAssetInformationError.Statusdefault({})".format(str(self))
    _UniffiTempAccountAssetInformationError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAccountAssetInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountAssetInformationError.DefaultResponse({})".format(str(self))
    _UniffiTempAccountAssetInformationError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAccountAssetInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetInformationError.UnknownValue({})".format(str(self))
    _UniffiTempAccountAssetInformationError.UnknownValue = UnknownValue # type: ignore

AccountAssetInformationError = _UniffiTempAccountAssetInformationError # type: ignore
del _UniffiTempAccountAssetInformationError


class _UniffiConverterTypeAccountAssetInformationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountAssetInformationError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AccountAssetInformationError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AccountAssetInformationError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AccountAssetInformationError.Statusdefault(
            )
        if variant == 5:
            return AccountAssetInformationError.DefaultResponse(
            )
        if variant == 6:
            return AccountAssetInformationError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AccountAssetInformationError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountAssetInformationError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountAssetInformationError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountAssetInformationError.Statusdefault):
            return
        if isinstance(value, AccountAssetInformationError.DefaultResponse):
            return
        if isinstance(value, AccountAssetInformationError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AccountAssetInformationError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountAssetInformationError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountAssetInformationError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountAssetInformationError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, AccountAssetInformationError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, AccountAssetInformationError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# AccountAssetsInformationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AccountAssetsInformationError(Exception):
    """
    struct for typed errors of method [`account_assets_information`]
    """

    pass

_UniffiTempAccountAssetsInformationError = AccountAssetsInformationError

class AccountAssetsInformationError:  # type: ignore
    """
    struct for typed errors of method [`account_assets_information`]
    """

    class Status400(_UniffiTempAccountAssetsInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetsInformationError.Status400({})".format(str(self))
    _UniffiTempAccountAssetsInformationError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAccountAssetsInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetsInformationError.Status401({})".format(str(self))
    _UniffiTempAccountAssetsInformationError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempAccountAssetsInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetsInformationError.Status500({})".format(str(self))
    _UniffiTempAccountAssetsInformationError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempAccountAssetsInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountAssetsInformationError.Statusdefault({})".format(str(self))
    _UniffiTempAccountAssetsInformationError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAccountAssetsInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountAssetsInformationError.DefaultResponse({})".format(str(self))
    _UniffiTempAccountAssetsInformationError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAccountAssetsInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountAssetsInformationError.UnknownValue({})".format(str(self))
    _UniffiTempAccountAssetsInformationError.UnknownValue = UnknownValue # type: ignore

AccountAssetsInformationError = _UniffiTempAccountAssetsInformationError # type: ignore
del _UniffiTempAccountAssetsInformationError


class _UniffiConverterTypeAccountAssetsInformationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountAssetsInformationError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AccountAssetsInformationError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AccountAssetsInformationError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AccountAssetsInformationError.Statusdefault(
            )
        if variant == 5:
            return AccountAssetsInformationError.DefaultResponse(
            )
        if variant == 6:
            return AccountAssetsInformationError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AccountAssetsInformationError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountAssetsInformationError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountAssetsInformationError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountAssetsInformationError.Statusdefault):
            return
        if isinstance(value, AccountAssetsInformationError.DefaultResponse):
            return
        if isinstance(value, AccountAssetsInformationError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AccountAssetsInformationError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountAssetsInformationError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountAssetsInformationError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountAssetsInformationError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, AccountAssetsInformationError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, AccountAssetsInformationError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# AccountInformationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AccountInformationError(Exception):
    """
    struct for typed errors of method [`account_information`]
    """

    pass

_UniffiTempAccountInformationError = AccountInformationError

class AccountInformationError:  # type: ignore
    """
    struct for typed errors of method [`account_information`]
    """

    class Status400(_UniffiTempAccountInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountInformationError.Status400({})".format(str(self))
    _UniffiTempAccountInformationError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAccountInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountInformationError.Status401({})".format(str(self))
    _UniffiTempAccountInformationError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempAccountInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountInformationError.Status500({})".format(str(self))
    _UniffiTempAccountInformationError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempAccountInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountInformationError.Statusdefault({})".format(str(self))
    _UniffiTempAccountInformationError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAccountInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AccountInformationError.DefaultResponse({})".format(str(self))
    _UniffiTempAccountInformationError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAccountInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AccountInformationError.UnknownValue({})".format(str(self))
    _UniffiTempAccountInformationError.UnknownValue = UnknownValue # type: ignore

AccountInformationError = _UniffiTempAccountInformationError # type: ignore
del _UniffiTempAccountInformationError


class _UniffiConverterTypeAccountInformationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccountInformationError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AccountInformationError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AccountInformationError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AccountInformationError.Statusdefault(
            )
        if variant == 5:
            return AccountInformationError.DefaultResponse(
            )
        if variant == 6:
            return AccountInformationError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AccountInformationError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountInformationError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountInformationError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AccountInformationError.Statusdefault):
            return
        if isinstance(value, AccountInformationError.DefaultResponse):
            return
        if isinstance(value, AccountInformationError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AccountInformationError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountInformationError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountInformationError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AccountInformationError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, AccountInformationError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, AccountInformationError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# AddParticipationKeyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AddParticipationKeyError(Exception):
    """
    struct for typed errors of method [`add_participation_key`]
    """

    pass

_UniffiTempAddParticipationKeyError = AddParticipationKeyError

class AddParticipationKeyError:  # type: ignore
    """
    struct for typed errors of method [`add_participation_key`]
    """

    class Status400(_UniffiTempAddParticipationKeyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AddParticipationKeyError.Status400({})".format(str(self))
    _UniffiTempAddParticipationKeyError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAddParticipationKeyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AddParticipationKeyError.Status401({})".format(str(self))
    _UniffiTempAddParticipationKeyError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempAddParticipationKeyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AddParticipationKeyError.Status404({})".format(str(self))
    _UniffiTempAddParticipationKeyError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempAddParticipationKeyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AddParticipationKeyError.Status500({})".format(str(self))
    _UniffiTempAddParticipationKeyError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempAddParticipationKeyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AddParticipationKeyError.Status503({})".format(str(self))
    _UniffiTempAddParticipationKeyError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempAddParticipationKeyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddParticipationKeyError.Statusdefault({})".format(str(self))
    _UniffiTempAddParticipationKeyError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAddParticipationKeyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddParticipationKeyError.DefaultResponse({})".format(str(self))
    _UniffiTempAddParticipationKeyError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAddParticipationKeyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AddParticipationKeyError.UnknownValue({})".format(str(self))
    _UniffiTempAddParticipationKeyError.UnknownValue = UnknownValue # type: ignore

AddParticipationKeyError = _UniffiTempAddParticipationKeyError # type: ignore
del _UniffiTempAddParticipationKeyError


class _UniffiConverterTypeAddParticipationKeyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddParticipationKeyError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AddParticipationKeyError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AddParticipationKeyError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AddParticipationKeyError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return AddParticipationKeyError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return AddParticipationKeyError.Statusdefault(
            )
        if variant == 7:
            return AddParticipationKeyError.DefaultResponse(
            )
        if variant == 8:
            return AddParticipationKeyError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AddParticipationKeyError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AddParticipationKeyError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AddParticipationKeyError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AddParticipationKeyError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AddParticipationKeyError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AddParticipationKeyError.Statusdefault):
            return
        if isinstance(value, AddParticipationKeyError.DefaultResponse):
            return
        if isinstance(value, AddParticipationKeyError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AddParticipationKeyError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AddParticipationKeyError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AddParticipationKeyError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AddParticipationKeyError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AddParticipationKeyError.Status503):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AddParticipationKeyError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, AddParticipationKeyError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, AddParticipationKeyError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# AlgodApiError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AlgodApiError(Exception):
    """
    Unified error type that can represent any API error from any endpoint
    """

    pass

_UniffiTempAlgodApiError = AlgodApiError

class AlgodApiError:  # type: ignore
    """
    Unified error type that can represent any API error from any endpoint
    """

    class HealthCheck(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.HealthCheck({})".format(str(self))
    _UniffiTempAlgodApiError.HealthCheck = HealthCheck # type: ignore
    class GetReady(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetReady({})".format(str(self))
    _UniffiTempAlgodApiError.GetReady = GetReady # type: ignore
    class Metrics(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.Metrics({})".format(str(self))
    _UniffiTempAlgodApiError.Metrics = Metrics # type: ignore
    class GetGenesis(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetGenesis({})".format(str(self))
    _UniffiTempAlgodApiError.GetGenesis = GetGenesis # type: ignore
    class SwaggerJson(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.SwaggerJson({})".format(str(self))
    _UniffiTempAlgodApiError.SwaggerJson = SwaggerJson # type: ignore
    class GetVersion(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetVersion({})".format(str(self))
    _UniffiTempAlgodApiError.GetVersion = GetVersion # type: ignore
    class GetDebugSettingsProf(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetDebugSettingsProf({})".format(str(self))
    _UniffiTempAlgodApiError.GetDebugSettingsProf = GetDebugSettingsProf # type: ignore
    class PutDebugSettingsProf(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.PutDebugSettingsProf({})".format(str(self))
    _UniffiTempAlgodApiError.PutDebugSettingsProf = PutDebugSettingsProf # type: ignore
    class GetConfig(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetConfig({})".format(str(self))
    _UniffiTempAlgodApiError.GetConfig = GetConfig # type: ignore
    class AccountInformation(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AccountInformation({})".format(str(self))
    _UniffiTempAlgodApiError.AccountInformation = AccountInformation # type: ignore
    class AccountAssetInformation(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AccountAssetInformation({})".format(str(self))
    _UniffiTempAlgodApiError.AccountAssetInformation = AccountAssetInformation # type: ignore
    class AccountAssetsInformation(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AccountAssetsInformation({})".format(str(self))
    _UniffiTempAlgodApiError.AccountAssetsInformation = AccountAssetsInformation # type: ignore
    class AccountApplicationInformation(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AccountApplicationInformation({})".format(str(self))
    _UniffiTempAlgodApiError.AccountApplicationInformation = AccountApplicationInformation # type: ignore
    class GetPendingTransactionsByAddress(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetPendingTransactionsByAddress({})".format(str(self))
    _UniffiTempAlgodApiError.GetPendingTransactionsByAddress = GetPendingTransactionsByAddress # type: ignore
    class GetBlock(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetBlock({})".format(str(self))
    _UniffiTempAlgodApiError.GetBlock = GetBlock # type: ignore
    class GetBlockTxids(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetBlockTxids({})".format(str(self))
    _UniffiTempAlgodApiError.GetBlockTxids = GetBlockTxids # type: ignore
    class GetBlockHash(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetBlockHash({})".format(str(self))
    _UniffiTempAlgodApiError.GetBlockHash = GetBlockHash # type: ignore
    class GetTransactionProof(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetTransactionProof({})".format(str(self))
    _UniffiTempAlgodApiError.GetTransactionProof = GetTransactionProof # type: ignore
    class GetBlockLogs(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetBlockLogs({})".format(str(self))
    _UniffiTempAlgodApiError.GetBlockLogs = GetBlockLogs # type: ignore
    class GetSupply(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetSupply({})".format(str(self))
    _UniffiTempAlgodApiError.GetSupply = GetSupply # type: ignore
    class GetParticipationKeys(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetParticipationKeys({})".format(str(self))
    _UniffiTempAlgodApiError.GetParticipationKeys = GetParticipationKeys # type: ignore
    class AddParticipationKey(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AddParticipationKey({})".format(str(self))
    _UniffiTempAlgodApiError.AddParticipationKey = AddParticipationKey # type: ignore
    class GenerateParticipationKeys(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GenerateParticipationKeys({})".format(str(self))
    _UniffiTempAlgodApiError.GenerateParticipationKeys = GenerateParticipationKeys # type: ignore
    class GetParticipationKeyById(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetParticipationKeyById({})".format(str(self))
    _UniffiTempAlgodApiError.GetParticipationKeyById = GetParticipationKeyById # type: ignore
    class AppendKeys(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AppendKeys({})".format(str(self))
    _UniffiTempAlgodApiError.AppendKeys = AppendKeys # type: ignore
    class DeleteParticipationKeyById(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.DeleteParticipationKeyById({})".format(str(self))
    _UniffiTempAlgodApiError.DeleteParticipationKeyById = DeleteParticipationKeyById # type: ignore
    class ShutdownNode(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.ShutdownNode({})".format(str(self))
    _UniffiTempAlgodApiError.ShutdownNode = ShutdownNode # type: ignore
    class GetStatus(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetStatus({})".format(str(self))
    _UniffiTempAlgodApiError.GetStatus = GetStatus # type: ignore
    class WaitForBlock(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.WaitForBlock({})".format(str(self))
    _UniffiTempAlgodApiError.WaitForBlock = WaitForBlock # type: ignore
    class RawTransaction(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.RawTransaction({})".format(str(self))
    _UniffiTempAlgodApiError.RawTransaction = RawTransaction # type: ignore
    class RawTransactionAsync(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.RawTransactionAsync({})".format(str(self))
    _UniffiTempAlgodApiError.RawTransactionAsync = RawTransactionAsync # type: ignore
    class SimulateTransaction(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.SimulateTransaction({})".format(str(self))
    _UniffiTempAlgodApiError.SimulateTransaction = SimulateTransaction # type: ignore
    class TransactionParams(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.TransactionParams({})".format(str(self))
    _UniffiTempAlgodApiError.TransactionParams = TransactionParams # type: ignore
    class GetPendingTransactions(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetPendingTransactions({})".format(str(self))
    _UniffiTempAlgodApiError.GetPendingTransactions = GetPendingTransactions # type: ignore
    class PendingTransactionInformation(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.PendingTransactionInformation({})".format(str(self))
    _UniffiTempAlgodApiError.PendingTransactionInformation = PendingTransactionInformation # type: ignore
    class GetLedgerStateDelta(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetLedgerStateDelta({})".format(str(self))
    _UniffiTempAlgodApiError.GetLedgerStateDelta = GetLedgerStateDelta # type: ignore
    class GetTransactionGroupLedgerStateDeltasForRound(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetTransactionGroupLedgerStateDeltasForRound({})".format(str(self))
    _UniffiTempAlgodApiError.GetTransactionGroupLedgerStateDeltasForRound = GetTransactionGroupLedgerStateDeltasForRound # type: ignore
    class GetLedgerStateDeltaForTransactionGroup(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetLedgerStateDeltaForTransactionGroup({})".format(str(self))
    _UniffiTempAlgodApiError.GetLedgerStateDeltaForTransactionGroup = GetLedgerStateDeltaForTransactionGroup # type: ignore
    class GetStateProof(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetStateProof({})".format(str(self))
    _UniffiTempAlgodApiError.GetStateProof = GetStateProof # type: ignore
    class GetLightBlockHeaderProof(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetLightBlockHeaderProof({})".format(str(self))
    _UniffiTempAlgodApiError.GetLightBlockHeaderProof = GetLightBlockHeaderProof # type: ignore
    class GetApplicationById(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetApplicationById({})".format(str(self))
    _UniffiTempAlgodApiError.GetApplicationById = GetApplicationById # type: ignore
    class GetApplicationBoxes(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetApplicationBoxes({})".format(str(self))
    _UniffiTempAlgodApiError.GetApplicationBoxes = GetApplicationBoxes # type: ignore
    class GetApplicationBoxByName(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetApplicationBoxByName({})".format(str(self))
    _UniffiTempAlgodApiError.GetApplicationBoxByName = GetApplicationBoxByName # type: ignore
    class GetAssetById(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetAssetById({})".format(str(self))
    _UniffiTempAlgodApiError.GetAssetById = GetAssetById # type: ignore
    class GetSyncRound(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetSyncRound({})".format(str(self))
    _UniffiTempAlgodApiError.GetSyncRound = GetSyncRound # type: ignore
    class UnsetSyncRound(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.UnsetSyncRound({})".format(str(self))
    _UniffiTempAlgodApiError.UnsetSyncRound = UnsetSyncRound # type: ignore
    class SetSyncRound(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.SetSyncRound({})".format(str(self))
    _UniffiTempAlgodApiError.SetSyncRound = SetSyncRound # type: ignore
    class TealCompile(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.TealCompile({})".format(str(self))
    _UniffiTempAlgodApiError.TealCompile = TealCompile # type: ignore
    class TealDisassemble(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.TealDisassemble({})".format(str(self))
    _UniffiTempAlgodApiError.TealDisassemble = TealDisassemble # type: ignore
    class StartCatchup(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.StartCatchup({})".format(str(self))
    _UniffiTempAlgodApiError.StartCatchup = StartCatchup # type: ignore
    class AbortCatchup(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.AbortCatchup({})".format(str(self))
    _UniffiTempAlgodApiError.AbortCatchup = AbortCatchup # type: ignore
    class TealDryrun(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.TealDryrun({})".format(str(self))
    _UniffiTempAlgodApiError.TealDryrun = TealDryrun # type: ignore
    class ExperimentalCheck(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.ExperimentalCheck({})".format(str(self))
    _UniffiTempAlgodApiError.ExperimentalCheck = ExperimentalCheck # type: ignore
    class GetBlockTimeStampOffset(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.GetBlockTimeStampOffset({})".format(str(self))
    _UniffiTempAlgodApiError.GetBlockTimeStampOffset = GetBlockTimeStampOffset # type: ignore
    class SetBlockTimeStampOffset(_UniffiTempAlgodApiError):
        def __init__(self, error):
            super().__init__(", ".join([
                "error={!r}".format(error),
            ]))
            self.error = error

        def __repr__(self):
            return "AlgodApiError.SetBlockTimeStampOffset({})".format(str(self))
    _UniffiTempAlgodApiError.SetBlockTimeStampOffset = SetBlockTimeStampOffset # type: ignore
    class Unknown(_UniffiTempAlgodApiError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "AlgodApiError.Unknown({})".format(str(self))
    _UniffiTempAlgodApiError.Unknown = Unknown # type: ignore

AlgodApiError = _UniffiTempAlgodApiError # type: ignore
del _UniffiTempAlgodApiError


class _UniffiConverterTypeAlgodApiError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AlgodApiError.HealthCheck(
                _UniffiConverterTypeHealthCheckError.read(buf),
            )
        if variant == 2:
            return AlgodApiError.GetReady(
                _UniffiConverterTypeGetReadyError.read(buf),
            )
        if variant == 3:
            return AlgodApiError.Metrics(
                _UniffiConverterTypeMetricsError.read(buf),
            )
        if variant == 4:
            return AlgodApiError.GetGenesis(
                _UniffiConverterTypeGetGenesisError.read(buf),
            )
        if variant == 5:
            return AlgodApiError.SwaggerJson(
                _UniffiConverterTypeSwaggerJsonError.read(buf),
            )
        if variant == 6:
            return AlgodApiError.GetVersion(
                _UniffiConverterTypeGetVersionError.read(buf),
            )
        if variant == 7:
            return AlgodApiError.GetDebugSettingsProf(
                _UniffiConverterTypeGetDebugSettingsProfError.read(buf),
            )
        if variant == 8:
            return AlgodApiError.PutDebugSettingsProf(
                _UniffiConverterTypePutDebugSettingsProfError.read(buf),
            )
        if variant == 9:
            return AlgodApiError.GetConfig(
                _UniffiConverterTypeGetConfigError.read(buf),
            )
        if variant == 10:
            return AlgodApiError.AccountInformation(
                _UniffiConverterTypeAccountInformationError.read(buf),
            )
        if variant == 11:
            return AlgodApiError.AccountAssetInformation(
                _UniffiConverterTypeAccountAssetInformationError.read(buf),
            )
        if variant == 12:
            return AlgodApiError.AccountAssetsInformation(
                _UniffiConverterTypeAccountAssetsInformationError.read(buf),
            )
        if variant == 13:
            return AlgodApiError.AccountApplicationInformation(
                _UniffiConverterTypeAccountApplicationInformationError.read(buf),
            )
        if variant == 14:
            return AlgodApiError.GetPendingTransactionsByAddress(
                _UniffiConverterTypeGetPendingTransactionsByAddressError.read(buf),
            )
        if variant == 15:
            return AlgodApiError.GetBlock(
                _UniffiConverterTypeGetBlockError.read(buf),
            )
        if variant == 16:
            return AlgodApiError.GetBlockTxids(
                _UniffiConverterTypeGetBlockTxidsError.read(buf),
            )
        if variant == 17:
            return AlgodApiError.GetBlockHash(
                _UniffiConverterTypeGetBlockHashError.read(buf),
            )
        if variant == 18:
            return AlgodApiError.GetTransactionProof(
                _UniffiConverterTypeGetTransactionProofError.read(buf),
            )
        if variant == 19:
            return AlgodApiError.GetBlockLogs(
                _UniffiConverterTypeGetBlockLogsError.read(buf),
            )
        if variant == 20:
            return AlgodApiError.GetSupply(
                _UniffiConverterTypeGetSupplyError.read(buf),
            )
        if variant == 21:
            return AlgodApiError.GetParticipationKeys(
                _UniffiConverterTypeGetParticipationKeysError.read(buf),
            )
        if variant == 22:
            return AlgodApiError.AddParticipationKey(
                _UniffiConverterTypeAddParticipationKeyError.read(buf),
            )
        if variant == 23:
            return AlgodApiError.GenerateParticipationKeys(
                _UniffiConverterTypeGenerateParticipationKeysError.read(buf),
            )
        if variant == 24:
            return AlgodApiError.GetParticipationKeyById(
                _UniffiConverterTypeGetParticipationKeyByIdError.read(buf),
            )
        if variant == 25:
            return AlgodApiError.AppendKeys(
                _UniffiConverterTypeAppendKeysError.read(buf),
            )
        if variant == 26:
            return AlgodApiError.DeleteParticipationKeyById(
                _UniffiConverterTypeDeleteParticipationKeyByIdError.read(buf),
            )
        if variant == 27:
            return AlgodApiError.ShutdownNode(
                _UniffiConverterTypeShutdownNodeError.read(buf),
            )
        if variant == 28:
            return AlgodApiError.GetStatus(
                _UniffiConverterTypeGetStatusError.read(buf),
            )
        if variant == 29:
            return AlgodApiError.WaitForBlock(
                _UniffiConverterTypeWaitForBlockError.read(buf),
            )
        if variant == 30:
            return AlgodApiError.RawTransaction(
                _UniffiConverterTypeRawTransactionError.read(buf),
            )
        if variant == 31:
            return AlgodApiError.RawTransactionAsync(
                _UniffiConverterTypeRawTransactionAsyncError.read(buf),
            )
        if variant == 32:
            return AlgodApiError.SimulateTransaction(
                _UniffiConverterTypeSimulateTransactionError.read(buf),
            )
        if variant == 33:
            return AlgodApiError.TransactionParams(
                _UniffiConverterTypeTransactionParamsError.read(buf),
            )
        if variant == 34:
            return AlgodApiError.GetPendingTransactions(
                _UniffiConverterTypeGetPendingTransactionsError.read(buf),
            )
        if variant == 35:
            return AlgodApiError.PendingTransactionInformation(
                _UniffiConverterTypePendingTransactionInformationError.read(buf),
            )
        if variant == 36:
            return AlgodApiError.GetLedgerStateDelta(
                _UniffiConverterTypeGetLedgerStateDeltaError.read(buf),
            )
        if variant == 37:
            return AlgodApiError.GetTransactionGroupLedgerStateDeltasForRound(
                _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRoundError.read(buf),
            )
        if variant == 38:
            return AlgodApiError.GetLedgerStateDeltaForTransactionGroup(
                _UniffiConverterTypeGetLedgerStateDeltaForTransactionGroupError.read(buf),
            )
        if variant == 39:
            return AlgodApiError.GetStateProof(
                _UniffiConverterTypeGetStateProofError.read(buf),
            )
        if variant == 40:
            return AlgodApiError.GetLightBlockHeaderProof(
                _UniffiConverterTypeGetLightBlockHeaderProofError.read(buf),
            )
        if variant == 41:
            return AlgodApiError.GetApplicationById(
                _UniffiConverterTypeGetApplicationByIdError.read(buf),
            )
        if variant == 42:
            return AlgodApiError.GetApplicationBoxes(
                _UniffiConverterTypeGetApplicationBoxesError.read(buf),
            )
        if variant == 43:
            return AlgodApiError.GetApplicationBoxByName(
                _UniffiConverterTypeGetApplicationBoxByNameError.read(buf),
            )
        if variant == 44:
            return AlgodApiError.GetAssetById(
                _UniffiConverterTypeGetAssetByIdError.read(buf),
            )
        if variant == 45:
            return AlgodApiError.GetSyncRound(
                _UniffiConverterTypeGetSyncRoundError.read(buf),
            )
        if variant == 46:
            return AlgodApiError.UnsetSyncRound(
                _UniffiConverterTypeUnsetSyncRoundError.read(buf),
            )
        if variant == 47:
            return AlgodApiError.SetSyncRound(
                _UniffiConverterTypeSetSyncRoundError.read(buf),
            )
        if variant == 48:
            return AlgodApiError.TealCompile(
                _UniffiConverterTypeTealCompileError.read(buf),
            )
        if variant == 49:
            return AlgodApiError.TealDisassemble(
                _UniffiConverterTypeTealDisassembleError.read(buf),
            )
        if variant == 50:
            return AlgodApiError.StartCatchup(
                _UniffiConverterTypeStartCatchupError.read(buf),
            )
        if variant == 51:
            return AlgodApiError.AbortCatchup(
                _UniffiConverterTypeAbortCatchupError.read(buf),
            )
        if variant == 52:
            return AlgodApiError.TealDryrun(
                _UniffiConverterTypeTealDryrunError.read(buf),
            )
        if variant == 53:
            return AlgodApiError.ExperimentalCheck(
                _UniffiConverterTypeExperimentalCheckError.read(buf),
            )
        if variant == 54:
            return AlgodApiError.GetBlockTimeStampOffset(
                _UniffiConverterTypeGetBlockTimeStampOffsetError.read(buf),
            )
        if variant == 55:
            return AlgodApiError.SetBlockTimeStampOffset(
                _UniffiConverterTypeSetBlockTimeStampOffsetError.read(buf),
            )
        if variant == 56:
            return AlgodApiError.Unknown(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AlgodApiError.HealthCheck):
            _UniffiConverterTypeHealthCheckError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetReady):
            _UniffiConverterTypeGetReadyError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.Metrics):
            _UniffiConverterTypeMetricsError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetGenesis):
            _UniffiConverterTypeGetGenesisError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.SwaggerJson):
            _UniffiConverterTypeSwaggerJsonError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetVersion):
            _UniffiConverterTypeGetVersionError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetDebugSettingsProf):
            _UniffiConverterTypeGetDebugSettingsProfError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.PutDebugSettingsProf):
            _UniffiConverterTypePutDebugSettingsProfError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetConfig):
            _UniffiConverterTypeGetConfigError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AccountInformation):
            _UniffiConverterTypeAccountInformationError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AccountAssetInformation):
            _UniffiConverterTypeAccountAssetInformationError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AccountAssetsInformation):
            _UniffiConverterTypeAccountAssetsInformationError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AccountApplicationInformation):
            _UniffiConverterTypeAccountApplicationInformationError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetPendingTransactionsByAddress):
            _UniffiConverterTypeGetPendingTransactionsByAddressError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetBlock):
            _UniffiConverterTypeGetBlockError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetBlockTxids):
            _UniffiConverterTypeGetBlockTxidsError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetBlockHash):
            _UniffiConverterTypeGetBlockHashError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetTransactionProof):
            _UniffiConverterTypeGetTransactionProofError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetBlockLogs):
            _UniffiConverterTypeGetBlockLogsError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetSupply):
            _UniffiConverterTypeGetSupplyError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetParticipationKeys):
            _UniffiConverterTypeGetParticipationKeysError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AddParticipationKey):
            _UniffiConverterTypeAddParticipationKeyError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GenerateParticipationKeys):
            _UniffiConverterTypeGenerateParticipationKeysError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetParticipationKeyById):
            _UniffiConverterTypeGetParticipationKeyByIdError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AppendKeys):
            _UniffiConverterTypeAppendKeysError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.DeleteParticipationKeyById):
            _UniffiConverterTypeDeleteParticipationKeyByIdError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.ShutdownNode):
            _UniffiConverterTypeShutdownNodeError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetStatus):
            _UniffiConverterTypeGetStatusError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.WaitForBlock):
            _UniffiConverterTypeWaitForBlockError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.RawTransaction):
            _UniffiConverterTypeRawTransactionError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.RawTransactionAsync):
            _UniffiConverterTypeRawTransactionAsyncError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.SimulateTransaction):
            _UniffiConverterTypeSimulateTransactionError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.TransactionParams):
            _UniffiConverterTypeTransactionParamsError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetPendingTransactions):
            _UniffiConverterTypeGetPendingTransactionsError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.PendingTransactionInformation):
            _UniffiConverterTypePendingTransactionInformationError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetLedgerStateDelta):
            _UniffiConverterTypeGetLedgerStateDeltaError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetTransactionGroupLedgerStateDeltasForRound):
            _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRoundError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetLedgerStateDeltaForTransactionGroup):
            _UniffiConverterTypeGetLedgerStateDeltaForTransactionGroupError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetStateProof):
            _UniffiConverterTypeGetStateProofError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetLightBlockHeaderProof):
            _UniffiConverterTypeGetLightBlockHeaderProofError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetApplicationById):
            _UniffiConverterTypeGetApplicationByIdError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetApplicationBoxes):
            _UniffiConverterTypeGetApplicationBoxesError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetApplicationBoxByName):
            _UniffiConverterTypeGetApplicationBoxByNameError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetAssetById):
            _UniffiConverterTypeGetAssetByIdError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetSyncRound):
            _UniffiConverterTypeGetSyncRoundError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.UnsetSyncRound):
            _UniffiConverterTypeUnsetSyncRoundError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.SetSyncRound):
            _UniffiConverterTypeSetSyncRoundError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.TealCompile):
            _UniffiConverterTypeTealCompileError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.TealDisassemble):
            _UniffiConverterTypeTealDisassembleError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.StartCatchup):
            _UniffiConverterTypeStartCatchupError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.AbortCatchup):
            _UniffiConverterTypeAbortCatchupError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.TealDryrun):
            _UniffiConverterTypeTealDryrunError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.ExperimentalCheck):
            _UniffiConverterTypeExperimentalCheckError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.GetBlockTimeStampOffset):
            _UniffiConverterTypeGetBlockTimeStampOffsetError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.SetBlockTimeStampOffset):
            _UniffiConverterTypeSetBlockTimeStampOffsetError.check_lower(value.error)
            return
        if isinstance(value, AlgodApiError.Unknown):
            _UniffiConverterString.check_lower(value.message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AlgodApiError.HealthCheck):
            buf.write_i32(1)
            _UniffiConverterTypeHealthCheckError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetReady):
            buf.write_i32(2)
            _UniffiConverterTypeGetReadyError.write(value.error, buf)
        if isinstance(value, AlgodApiError.Metrics):
            buf.write_i32(3)
            _UniffiConverterTypeMetricsError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetGenesis):
            buf.write_i32(4)
            _UniffiConverterTypeGetGenesisError.write(value.error, buf)
        if isinstance(value, AlgodApiError.SwaggerJson):
            buf.write_i32(5)
            _UniffiConverterTypeSwaggerJsonError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetVersion):
            buf.write_i32(6)
            _UniffiConverterTypeGetVersionError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetDebugSettingsProf):
            buf.write_i32(7)
            _UniffiConverterTypeGetDebugSettingsProfError.write(value.error, buf)
        if isinstance(value, AlgodApiError.PutDebugSettingsProf):
            buf.write_i32(8)
            _UniffiConverterTypePutDebugSettingsProfError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetConfig):
            buf.write_i32(9)
            _UniffiConverterTypeGetConfigError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AccountInformation):
            buf.write_i32(10)
            _UniffiConverterTypeAccountInformationError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AccountAssetInformation):
            buf.write_i32(11)
            _UniffiConverterTypeAccountAssetInformationError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AccountAssetsInformation):
            buf.write_i32(12)
            _UniffiConverterTypeAccountAssetsInformationError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AccountApplicationInformation):
            buf.write_i32(13)
            _UniffiConverterTypeAccountApplicationInformationError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetPendingTransactionsByAddress):
            buf.write_i32(14)
            _UniffiConverterTypeGetPendingTransactionsByAddressError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetBlock):
            buf.write_i32(15)
            _UniffiConverterTypeGetBlockError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetBlockTxids):
            buf.write_i32(16)
            _UniffiConverterTypeGetBlockTxidsError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetBlockHash):
            buf.write_i32(17)
            _UniffiConverterTypeGetBlockHashError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetTransactionProof):
            buf.write_i32(18)
            _UniffiConverterTypeGetTransactionProofError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetBlockLogs):
            buf.write_i32(19)
            _UniffiConverterTypeGetBlockLogsError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetSupply):
            buf.write_i32(20)
            _UniffiConverterTypeGetSupplyError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetParticipationKeys):
            buf.write_i32(21)
            _UniffiConverterTypeGetParticipationKeysError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AddParticipationKey):
            buf.write_i32(22)
            _UniffiConverterTypeAddParticipationKeyError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GenerateParticipationKeys):
            buf.write_i32(23)
            _UniffiConverterTypeGenerateParticipationKeysError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetParticipationKeyById):
            buf.write_i32(24)
            _UniffiConverterTypeGetParticipationKeyByIdError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AppendKeys):
            buf.write_i32(25)
            _UniffiConverterTypeAppendKeysError.write(value.error, buf)
        if isinstance(value, AlgodApiError.DeleteParticipationKeyById):
            buf.write_i32(26)
            _UniffiConverterTypeDeleteParticipationKeyByIdError.write(value.error, buf)
        if isinstance(value, AlgodApiError.ShutdownNode):
            buf.write_i32(27)
            _UniffiConverterTypeShutdownNodeError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetStatus):
            buf.write_i32(28)
            _UniffiConverterTypeGetStatusError.write(value.error, buf)
        if isinstance(value, AlgodApiError.WaitForBlock):
            buf.write_i32(29)
            _UniffiConverterTypeWaitForBlockError.write(value.error, buf)
        if isinstance(value, AlgodApiError.RawTransaction):
            buf.write_i32(30)
            _UniffiConverterTypeRawTransactionError.write(value.error, buf)
        if isinstance(value, AlgodApiError.RawTransactionAsync):
            buf.write_i32(31)
            _UniffiConverterTypeRawTransactionAsyncError.write(value.error, buf)
        if isinstance(value, AlgodApiError.SimulateTransaction):
            buf.write_i32(32)
            _UniffiConverterTypeSimulateTransactionError.write(value.error, buf)
        if isinstance(value, AlgodApiError.TransactionParams):
            buf.write_i32(33)
            _UniffiConverterTypeTransactionParamsError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetPendingTransactions):
            buf.write_i32(34)
            _UniffiConverterTypeGetPendingTransactionsError.write(value.error, buf)
        if isinstance(value, AlgodApiError.PendingTransactionInformation):
            buf.write_i32(35)
            _UniffiConverterTypePendingTransactionInformationError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetLedgerStateDelta):
            buf.write_i32(36)
            _UniffiConverterTypeGetLedgerStateDeltaError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetTransactionGroupLedgerStateDeltasForRound):
            buf.write_i32(37)
            _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRoundError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetLedgerStateDeltaForTransactionGroup):
            buf.write_i32(38)
            _UniffiConverterTypeGetLedgerStateDeltaForTransactionGroupError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetStateProof):
            buf.write_i32(39)
            _UniffiConverterTypeGetStateProofError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetLightBlockHeaderProof):
            buf.write_i32(40)
            _UniffiConverterTypeGetLightBlockHeaderProofError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetApplicationById):
            buf.write_i32(41)
            _UniffiConverterTypeGetApplicationByIdError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetApplicationBoxes):
            buf.write_i32(42)
            _UniffiConverterTypeGetApplicationBoxesError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetApplicationBoxByName):
            buf.write_i32(43)
            _UniffiConverterTypeGetApplicationBoxByNameError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetAssetById):
            buf.write_i32(44)
            _UniffiConverterTypeGetAssetByIdError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetSyncRound):
            buf.write_i32(45)
            _UniffiConverterTypeGetSyncRoundError.write(value.error, buf)
        if isinstance(value, AlgodApiError.UnsetSyncRound):
            buf.write_i32(46)
            _UniffiConverterTypeUnsetSyncRoundError.write(value.error, buf)
        if isinstance(value, AlgodApiError.SetSyncRound):
            buf.write_i32(47)
            _UniffiConverterTypeSetSyncRoundError.write(value.error, buf)
        if isinstance(value, AlgodApiError.TealCompile):
            buf.write_i32(48)
            _UniffiConverterTypeTealCompileError.write(value.error, buf)
        if isinstance(value, AlgodApiError.TealDisassemble):
            buf.write_i32(49)
            _UniffiConverterTypeTealDisassembleError.write(value.error, buf)
        if isinstance(value, AlgodApiError.StartCatchup):
            buf.write_i32(50)
            _UniffiConverterTypeStartCatchupError.write(value.error, buf)
        if isinstance(value, AlgodApiError.AbortCatchup):
            buf.write_i32(51)
            _UniffiConverterTypeAbortCatchupError.write(value.error, buf)
        if isinstance(value, AlgodApiError.TealDryrun):
            buf.write_i32(52)
            _UniffiConverterTypeTealDryrunError.write(value.error, buf)
        if isinstance(value, AlgodApiError.ExperimentalCheck):
            buf.write_i32(53)
            _UniffiConverterTypeExperimentalCheckError.write(value.error, buf)
        if isinstance(value, AlgodApiError.GetBlockTimeStampOffset):
            buf.write_i32(54)
            _UniffiConverterTypeGetBlockTimeStampOffsetError.write(value.error, buf)
        if isinstance(value, AlgodApiError.SetBlockTimeStampOffset):
            buf.write_i32(55)
            _UniffiConverterTypeSetBlockTimeStampOffsetError.write(value.error, buf)
        if isinstance(value, AlgodApiError.Unknown):
            buf.write_i32(56)
            _UniffiConverterString.write(value.message, buf)


# AppendKeysError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AppendKeysError(Exception):
    """
    struct for typed errors of method [`append_keys`]
    """

    pass

_UniffiTempAppendKeysError = AppendKeysError

class AppendKeysError:  # type: ignore
    """
    struct for typed errors of method [`append_keys`]
    """

    class Status400(_UniffiTempAppendKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AppendKeysError.Status400({})".format(str(self))
    _UniffiTempAppendKeysError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempAppendKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AppendKeysError.Status401({})".format(str(self))
    _UniffiTempAppendKeysError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempAppendKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AppendKeysError.Status404({})".format(str(self))
    _UniffiTempAppendKeysError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempAppendKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AppendKeysError.Status500({})".format(str(self))
    _UniffiTempAppendKeysError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempAppendKeysError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AppendKeysError.Statusdefault({})".format(str(self))
    _UniffiTempAppendKeysError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempAppendKeysError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AppendKeysError.DefaultResponse({})".format(str(self))
    _UniffiTempAppendKeysError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempAppendKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "AppendKeysError.UnknownValue({})".format(str(self))
    _UniffiTempAppendKeysError.UnknownValue = UnknownValue # type: ignore

AppendKeysError = _UniffiTempAppendKeysError # type: ignore
del _UniffiTempAppendKeysError


class _UniffiConverterTypeAppendKeysError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AppendKeysError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return AppendKeysError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return AppendKeysError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return AppendKeysError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return AppendKeysError.Statusdefault(
            )
        if variant == 6:
            return AppendKeysError.DefaultResponse(
            )
        if variant == 7:
            return AppendKeysError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AppendKeysError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AppendKeysError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AppendKeysError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AppendKeysError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, AppendKeysError.Statusdefault):
            return
        if isinstance(value, AppendKeysError.DefaultResponse):
            return
        if isinstance(value, AppendKeysError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AppendKeysError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AppendKeysError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AppendKeysError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AppendKeysError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, AppendKeysError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, AppendKeysError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, AppendKeysError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# DeleteParticipationKeyByIdError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DeleteParticipationKeyByIdError(Exception):
    """
    struct for typed errors of method [`delete_participation_key_by_id`]
    """

    pass

_UniffiTempDeleteParticipationKeyByIdError = DeleteParticipationKeyByIdError

class DeleteParticipationKeyByIdError:  # type: ignore
    """
    struct for typed errors of method [`delete_participation_key_by_id`]
    """

    class Status400(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.Status400({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.Status401({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.Status404({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.Status500({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.Statusdefault({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.DefaultResponse({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempDeleteParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "DeleteParticipationKeyByIdError.UnknownValue({})".format(str(self))
    _UniffiTempDeleteParticipationKeyByIdError.UnknownValue = UnknownValue # type: ignore

DeleteParticipationKeyByIdError = _UniffiTempDeleteParticipationKeyByIdError # type: ignore
del _UniffiTempDeleteParticipationKeyByIdError


class _UniffiConverterTypeDeleteParticipationKeyByIdError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DeleteParticipationKeyByIdError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return DeleteParticipationKeyByIdError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return DeleteParticipationKeyByIdError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return DeleteParticipationKeyByIdError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return DeleteParticipationKeyByIdError.Statusdefault(
            )
        if variant == 6:
            return DeleteParticipationKeyByIdError.DefaultResponse(
            )
        if variant == 7:
            return DeleteParticipationKeyByIdError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DeleteParticipationKeyByIdError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, DeleteParticipationKeyByIdError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, DeleteParticipationKeyByIdError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, DeleteParticipationKeyByIdError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, DeleteParticipationKeyByIdError.Statusdefault):
            return
        if isinstance(value, DeleteParticipationKeyByIdError.DefaultResponse):
            return
        if isinstance(value, DeleteParticipationKeyByIdError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DeleteParticipationKeyByIdError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, DeleteParticipationKeyByIdError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, DeleteParticipationKeyByIdError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, DeleteParticipationKeyByIdError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, DeleteParticipationKeyByIdError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, DeleteParticipationKeyByIdError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, DeleteParticipationKeyByIdError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Error(Exception):
    """
    The main error type for all algod client operations
    """

    pass

_UniffiTempError = Error

class Error:  # type: ignore
    """
    The main error type for all algod client operations
    """

    class Http(_UniffiTempError):
        def __init__(self, source):
            super().__init__(", ".join([
                "source={!r}".format(source),
            ]))
            self.source = source

        def __repr__(self):
            return "Error.Http({})".format(str(self))
    _UniffiTempError.Http = Http # type: ignore
    class Serde(_UniffiTempError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "Error.Serde({})".format(str(self))
    _UniffiTempError.Serde = Serde # type: ignore
    class Api(_UniffiTempError):
        def __init__(self, source):
            super().__init__(", ".join([
                "source={!r}".format(source),
            ]))
            self.source = source

        def __repr__(self):
            return "Error.Api({})".format(str(self))
    _UniffiTempError.Api = Api # type: ignore

Error = _UniffiTempError # type: ignore
del _UniffiTempError


class _UniffiConverterTypeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Error.Http(
                _UniffiConverterTypeHttpError.read(buf),
            )
        if variant == 2:
            return Error.Serde(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Error.Api(
                _UniffiConverterTypeAlgodApiError.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Error.Http):
            _UniffiConverterTypeHttpError.check_lower(value.source)
            return
        if isinstance(value, Error.Serde):
            _UniffiConverterString.check_lower(value.message)
            return
        if isinstance(value, Error.Api):
            _UniffiConverterTypeAlgodApiError.check_lower(value.source)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Error.Http):
            buf.write_i32(1)
            _UniffiConverterTypeHttpError.write(value.source, buf)
        if isinstance(value, Error.Serde):
            buf.write_i32(2)
            _UniffiConverterString.write(value.message, buf)
        if isinstance(value, Error.Api):
            buf.write_i32(3)
            _UniffiConverterTypeAlgodApiError.write(value.source, buf)





class Exclude(enum.Enum):
    """
    When set to `all` will exclude asset holdings, application local state, created asset parameters, any created application parameters. Defaults to `none`.
    """

    ALL = 0
    """
    all
    """

    
    NONE = 1
    """
    none
    """

    


class _UniffiConverterTypeExclude(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Exclude.ALL
        if variant == 2:
            return Exclude.NONE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Exclude.ALL:
            return
        if value == Exclude.NONE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Exclude.ALL:
            buf.write_i32(1)
        if value == Exclude.NONE:
            buf.write_i32(2)




# ExperimentalCheckError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ExperimentalCheckError(Exception):
    """
    struct for typed errors of method [`experimental_check`]
    """

    pass

_UniffiTempExperimentalCheckError = ExperimentalCheckError

class ExperimentalCheckError:  # type: ignore
    """
    struct for typed errors of method [`experimental_check`]
    """

    class Status404(_UniffiTempExperimentalCheckError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ExperimentalCheckError.Status404({})".format(str(self))
    _UniffiTempExperimentalCheckError.Status404 = Status404 # type: ignore
    class Statusdefault(_UniffiTempExperimentalCheckError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ExperimentalCheckError.Statusdefault({})".format(str(self))
    _UniffiTempExperimentalCheckError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempExperimentalCheckError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ExperimentalCheckError.DefaultResponse({})".format(str(self))
    _UniffiTempExperimentalCheckError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempExperimentalCheckError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ExperimentalCheckError.UnknownValue({})".format(str(self))
    _UniffiTempExperimentalCheckError.UnknownValue = UnknownValue # type: ignore

ExperimentalCheckError = _UniffiTempExperimentalCheckError # type: ignore
del _UniffiTempExperimentalCheckError


class _UniffiConverterTypeExperimentalCheckError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExperimentalCheckError.Status404(
            )
        if variant == 2:
            return ExperimentalCheckError.Statusdefault(
            )
        if variant == 3:
            return ExperimentalCheckError.DefaultResponse(
            )
        if variant == 4:
            return ExperimentalCheckError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ExperimentalCheckError.Status404):
            return
        if isinstance(value, ExperimentalCheckError.Statusdefault):
            return
        if isinstance(value, ExperimentalCheckError.DefaultResponse):
            return
        if isinstance(value, ExperimentalCheckError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ExperimentalCheckError.Status404):
            buf.write_i32(1)
        if isinstance(value, ExperimentalCheckError.Statusdefault):
            buf.write_i32(2)
        if isinstance(value, ExperimentalCheckError.DefaultResponse):
            buf.write_i32(3)
        if isinstance(value, ExperimentalCheckError.UnknownValue):
            buf.write_i32(4)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)





class Format(enum.Enum):
    """
    Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
    """

    JSON = 0
    """
    json
    """

    
    MSGPACK = 1
    """
    msgpack
    """

    


class _UniffiConverterTypeFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Format.JSON
        if variant == 2:
            return Format.MSGPACK
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Format.JSON:
            return
        if value == Format.MSGPACK:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Format.JSON:
            buf.write_i32(1)
        if value == Format.MSGPACK:
            buf.write_i32(2)




# GenerateParticipationKeysError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GenerateParticipationKeysError(Exception):
    """
    struct for typed errors of method [`generate_participation_keys`]
    """

    pass

_UniffiTempGenerateParticipationKeysError = GenerateParticipationKeysError

class GenerateParticipationKeysError:  # type: ignore
    """
    struct for typed errors of method [`generate_participation_keys`]
    """

    class Status400(_UniffiTempGenerateParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GenerateParticipationKeysError.Status400({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGenerateParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GenerateParticipationKeysError.Status401({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempGenerateParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GenerateParticipationKeysError.Status500({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGenerateParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GenerateParticipationKeysError.Status503({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGenerateParticipationKeysError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GenerateParticipationKeysError.Statusdefault({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGenerateParticipationKeysError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GenerateParticipationKeysError.DefaultResponse({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGenerateParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GenerateParticipationKeysError.UnknownValue({})".format(str(self))
    _UniffiTempGenerateParticipationKeysError.UnknownValue = UnknownValue # type: ignore

GenerateParticipationKeysError = _UniffiTempGenerateParticipationKeysError # type: ignore
del _UniffiTempGenerateParticipationKeysError


class _UniffiConverterTypeGenerateParticipationKeysError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GenerateParticipationKeysError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GenerateParticipationKeysError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GenerateParticipationKeysError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GenerateParticipationKeysError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GenerateParticipationKeysError.Statusdefault(
            )
        if variant == 6:
            return GenerateParticipationKeysError.DefaultResponse(
            )
        if variant == 7:
            return GenerateParticipationKeysError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GenerateParticipationKeysError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GenerateParticipationKeysError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GenerateParticipationKeysError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GenerateParticipationKeysError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GenerateParticipationKeysError.Statusdefault):
            return
        if isinstance(value, GenerateParticipationKeysError.DefaultResponse):
            return
        if isinstance(value, GenerateParticipationKeysError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GenerateParticipationKeysError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GenerateParticipationKeysError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GenerateParticipationKeysError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GenerateParticipationKeysError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GenerateParticipationKeysError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GenerateParticipationKeysError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GenerateParticipationKeysError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetApplicationBoxByNameError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetApplicationBoxByNameError(Exception):
    """
    struct for typed errors of method [`get_application_box_by_name`]
    """

    pass

_UniffiTempGetApplicationBoxByNameError = GetApplicationBoxByNameError

class GetApplicationBoxByNameError:  # type: ignore
    """
    struct for typed errors of method [`get_application_box_by_name`]
    """

    class Status400(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxByNameError.Status400({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxByNameError.Status401({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxByNameError.Status404({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxByNameError.Status500({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetApplicationBoxByNameError.Statusdefault({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetApplicationBoxByNameError.DefaultResponse({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetApplicationBoxByNameError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxByNameError.UnknownValue({})".format(str(self))
    _UniffiTempGetApplicationBoxByNameError.UnknownValue = UnknownValue # type: ignore

GetApplicationBoxByNameError = _UniffiTempGetApplicationBoxByNameError # type: ignore
del _UniffiTempGetApplicationBoxByNameError


class _UniffiConverterTypeGetApplicationBoxByNameError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetApplicationBoxByNameError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetApplicationBoxByNameError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetApplicationBoxByNameError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetApplicationBoxByNameError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetApplicationBoxByNameError.Statusdefault(
            )
        if variant == 6:
            return GetApplicationBoxByNameError.DefaultResponse(
            )
        if variant == 7:
            return GetApplicationBoxByNameError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetApplicationBoxByNameError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxByNameError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxByNameError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxByNameError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxByNameError.Statusdefault):
            return
        if isinstance(value, GetApplicationBoxByNameError.DefaultResponse):
            return
        if isinstance(value, GetApplicationBoxByNameError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetApplicationBoxByNameError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxByNameError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxByNameError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxByNameError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxByNameError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetApplicationBoxByNameError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetApplicationBoxByNameError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetApplicationBoxesError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetApplicationBoxesError(Exception):
    """
    struct for typed errors of method [`get_application_boxes`]
    """

    pass

_UniffiTempGetApplicationBoxesError = GetApplicationBoxesError

class GetApplicationBoxesError:  # type: ignore
    """
    struct for typed errors of method [`get_application_boxes`]
    """

    class Status400(_UniffiTempGetApplicationBoxesError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxesError.Status400({})".format(str(self))
    _UniffiTempGetApplicationBoxesError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetApplicationBoxesError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxesError.Status401({})".format(str(self))
    _UniffiTempGetApplicationBoxesError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempGetApplicationBoxesError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxesError.Status500({})".format(str(self))
    _UniffiTempGetApplicationBoxesError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetApplicationBoxesError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetApplicationBoxesError.Statusdefault({})".format(str(self))
    _UniffiTempGetApplicationBoxesError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetApplicationBoxesError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetApplicationBoxesError.DefaultResponse({})".format(str(self))
    _UniffiTempGetApplicationBoxesError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetApplicationBoxesError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationBoxesError.UnknownValue({})".format(str(self))
    _UniffiTempGetApplicationBoxesError.UnknownValue = UnknownValue # type: ignore

GetApplicationBoxesError = _UniffiTempGetApplicationBoxesError # type: ignore
del _UniffiTempGetApplicationBoxesError


class _UniffiConverterTypeGetApplicationBoxesError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetApplicationBoxesError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetApplicationBoxesError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetApplicationBoxesError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetApplicationBoxesError.Statusdefault(
            )
        if variant == 5:
            return GetApplicationBoxesError.DefaultResponse(
            )
        if variant == 6:
            return GetApplicationBoxesError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetApplicationBoxesError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxesError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxesError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationBoxesError.Statusdefault):
            return
        if isinstance(value, GetApplicationBoxesError.DefaultResponse):
            return
        if isinstance(value, GetApplicationBoxesError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetApplicationBoxesError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxesError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxesError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationBoxesError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, GetApplicationBoxesError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, GetApplicationBoxesError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetApplicationByIdError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetApplicationByIdError(Exception):
    """
    struct for typed errors of method [`get_application_by_id`]
    """

    pass

_UniffiTempGetApplicationByIdError = GetApplicationByIdError

class GetApplicationByIdError:  # type: ignore
    """
    struct for typed errors of method [`get_application_by_id`]
    """

    class Status400(_UniffiTempGetApplicationByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationByIdError.Status400({})".format(str(self))
    _UniffiTempGetApplicationByIdError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetApplicationByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationByIdError.Status401({})".format(str(self))
    _UniffiTempGetApplicationByIdError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetApplicationByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationByIdError.Status404({})".format(str(self))
    _UniffiTempGetApplicationByIdError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetApplicationByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationByIdError.Status500({})".format(str(self))
    _UniffiTempGetApplicationByIdError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetApplicationByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetApplicationByIdError.Statusdefault({})".format(str(self))
    _UniffiTempGetApplicationByIdError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetApplicationByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetApplicationByIdError.DefaultResponse({})".format(str(self))
    _UniffiTempGetApplicationByIdError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetApplicationByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetApplicationByIdError.UnknownValue({})".format(str(self))
    _UniffiTempGetApplicationByIdError.UnknownValue = UnknownValue # type: ignore

GetApplicationByIdError = _UniffiTempGetApplicationByIdError # type: ignore
del _UniffiTempGetApplicationByIdError


class _UniffiConverterTypeGetApplicationByIdError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetApplicationByIdError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetApplicationByIdError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetApplicationByIdError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetApplicationByIdError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetApplicationByIdError.Statusdefault(
            )
        if variant == 6:
            return GetApplicationByIdError.DefaultResponse(
            )
        if variant == 7:
            return GetApplicationByIdError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetApplicationByIdError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationByIdError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationByIdError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationByIdError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetApplicationByIdError.Statusdefault):
            return
        if isinstance(value, GetApplicationByIdError.DefaultResponse):
            return
        if isinstance(value, GetApplicationByIdError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetApplicationByIdError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationByIdError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationByIdError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationByIdError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetApplicationByIdError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetApplicationByIdError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetApplicationByIdError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetAssetByIdError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetAssetByIdError(Exception):
    """
    struct for typed errors of method [`get_asset_by_id`]
    """

    pass

_UniffiTempGetAssetByIdError = GetAssetByIdError

class GetAssetByIdError:  # type: ignore
    """
    struct for typed errors of method [`get_asset_by_id`]
    """

    class Status400(_UniffiTempGetAssetByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetAssetByIdError.Status400({})".format(str(self))
    _UniffiTempGetAssetByIdError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetAssetByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetAssetByIdError.Status401({})".format(str(self))
    _UniffiTempGetAssetByIdError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetAssetByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetAssetByIdError.Status404({})".format(str(self))
    _UniffiTempGetAssetByIdError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetAssetByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetAssetByIdError.Status500({})".format(str(self))
    _UniffiTempGetAssetByIdError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetAssetByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetAssetByIdError.Statusdefault({})".format(str(self))
    _UniffiTempGetAssetByIdError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetAssetByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetAssetByIdError.DefaultResponse({})".format(str(self))
    _UniffiTempGetAssetByIdError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetAssetByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetAssetByIdError.UnknownValue({})".format(str(self))
    _UniffiTempGetAssetByIdError.UnknownValue = UnknownValue # type: ignore

GetAssetByIdError = _UniffiTempGetAssetByIdError # type: ignore
del _UniffiTempGetAssetByIdError


class _UniffiConverterTypeGetAssetByIdError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetAssetByIdError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetAssetByIdError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetAssetByIdError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetAssetByIdError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetAssetByIdError.Statusdefault(
            )
        if variant == 6:
            return GetAssetByIdError.DefaultResponse(
            )
        if variant == 7:
            return GetAssetByIdError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetAssetByIdError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetAssetByIdError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetAssetByIdError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetAssetByIdError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetAssetByIdError.Statusdefault):
            return
        if isinstance(value, GetAssetByIdError.DefaultResponse):
            return
        if isinstance(value, GetAssetByIdError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetAssetByIdError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetAssetByIdError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetAssetByIdError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetAssetByIdError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetAssetByIdError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetAssetByIdError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetAssetByIdError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetBlockError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetBlockError(Exception):
    """
    struct for typed errors of method [`get_block`]
    """

    pass

_UniffiTempGetBlockError = GetBlockError

class GetBlockError:  # type: ignore
    """
    struct for typed errors of method [`get_block`]
    """

    class Status400(_UniffiTempGetBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockError.Status400({})".format(str(self))
    _UniffiTempGetBlockError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockError.Status401({})".format(str(self))
    _UniffiTempGetBlockError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockError.Status404({})".format(str(self))
    _UniffiTempGetBlockError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockError.Status500({})".format(str(self))
    _UniffiTempGetBlockError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetBlockError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockError.Statusdefault({})".format(str(self))
    _UniffiTempGetBlockError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetBlockError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockError.DefaultResponse({})".format(str(self))
    _UniffiTempGetBlockError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockError.UnknownValue({})".format(str(self))
    _UniffiTempGetBlockError.UnknownValue = UnknownValue # type: ignore

GetBlockError = _UniffiTempGetBlockError # type: ignore
del _UniffiTempGetBlockError


class _UniffiConverterTypeGetBlockError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetBlockError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetBlockError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetBlockError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetBlockError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetBlockError.Statusdefault(
            )
        if variant == 6:
            return GetBlockError.DefaultResponse(
            )
        if variant == 7:
            return GetBlockError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetBlockError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockError.Statusdefault):
            return
        if isinstance(value, GetBlockError.DefaultResponse):
            return
        if isinstance(value, GetBlockError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetBlockError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetBlockError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetBlockError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetBlockHashError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetBlockHashError(Exception):
    """
    struct for typed errors of method [`get_block_hash`]
    """

    pass

_UniffiTempGetBlockHashError = GetBlockHashError

class GetBlockHashError:  # type: ignore
    """
    struct for typed errors of method [`get_block_hash`]
    """

    class Status400(_UniffiTempGetBlockHashError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockHashError.Status400({})".format(str(self))
    _UniffiTempGetBlockHashError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetBlockHashError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockHashError.Status401({})".format(str(self))
    _UniffiTempGetBlockHashError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetBlockHashError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockHashError.Status404({})".format(str(self))
    _UniffiTempGetBlockHashError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetBlockHashError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockHashError.Status500({})".format(str(self))
    _UniffiTempGetBlockHashError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetBlockHashError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockHashError.Statusdefault({})".format(str(self))
    _UniffiTempGetBlockHashError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetBlockHashError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockHashError.DefaultResponse({})".format(str(self))
    _UniffiTempGetBlockHashError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetBlockHashError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockHashError.UnknownValue({})".format(str(self))
    _UniffiTempGetBlockHashError.UnknownValue = UnknownValue # type: ignore

GetBlockHashError = _UniffiTempGetBlockHashError # type: ignore
del _UniffiTempGetBlockHashError


class _UniffiConverterTypeGetBlockHashError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetBlockHashError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetBlockHashError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetBlockHashError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetBlockHashError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetBlockHashError.Statusdefault(
            )
        if variant == 6:
            return GetBlockHashError.DefaultResponse(
            )
        if variant == 7:
            return GetBlockHashError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetBlockHashError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockHashError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockHashError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockHashError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockHashError.Statusdefault):
            return
        if isinstance(value, GetBlockHashError.DefaultResponse):
            return
        if isinstance(value, GetBlockHashError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetBlockHashError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockHashError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockHashError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockHashError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockHashError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetBlockHashError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetBlockHashError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetBlockLogsError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetBlockLogsError(Exception):
    """
    struct for typed errors of method [`get_block_logs`]
    """

    pass

_UniffiTempGetBlockLogsError = GetBlockLogsError

class GetBlockLogsError:  # type: ignore
    """
    struct for typed errors of method [`get_block_logs`]
    """

    class Status400(_UniffiTempGetBlockLogsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockLogsError.Status400({})".format(str(self))
    _UniffiTempGetBlockLogsError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetBlockLogsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockLogsError.Status401({})".format(str(self))
    _UniffiTempGetBlockLogsError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetBlockLogsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockLogsError.Status404({})".format(str(self))
    _UniffiTempGetBlockLogsError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetBlockLogsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockLogsError.Status500({})".format(str(self))
    _UniffiTempGetBlockLogsError.Status500 = Status500 # type: ignore
    class DefaultResponse(_UniffiTempGetBlockLogsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockLogsError.DefaultResponse({})".format(str(self))
    _UniffiTempGetBlockLogsError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetBlockLogsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockLogsError.UnknownValue({})".format(str(self))
    _UniffiTempGetBlockLogsError.UnknownValue = UnknownValue # type: ignore

GetBlockLogsError = _UniffiTempGetBlockLogsError # type: ignore
del _UniffiTempGetBlockLogsError


class _UniffiConverterTypeGetBlockLogsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetBlockLogsError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetBlockLogsError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetBlockLogsError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetBlockLogsError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetBlockLogsError.DefaultResponse(
            )
        if variant == 6:
            return GetBlockLogsError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetBlockLogsError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockLogsError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockLogsError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockLogsError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockLogsError.DefaultResponse):
            return
        if isinstance(value, GetBlockLogsError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetBlockLogsError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockLogsError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockLogsError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockLogsError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockLogsError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, GetBlockLogsError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetBlockTimeStampOffsetError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetBlockTimeStampOffsetError(Exception):
    """
    struct for typed errors of method [`get_block_time_stamp_offset`]
    """

    pass

_UniffiTempGetBlockTimeStampOffsetError = GetBlockTimeStampOffsetError

class GetBlockTimeStampOffsetError:  # type: ignore
    """
    struct for typed errors of method [`get_block_time_stamp_offset`]
    """

    class Status400(_UniffiTempGetBlockTimeStampOffsetError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTimeStampOffsetError.Status400({})".format(str(self))
    _UniffiTempGetBlockTimeStampOffsetError.Status400 = Status400 # type: ignore
    class Statusdefault(_UniffiTempGetBlockTimeStampOffsetError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockTimeStampOffsetError.Statusdefault({})".format(str(self))
    _UniffiTempGetBlockTimeStampOffsetError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetBlockTimeStampOffsetError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockTimeStampOffsetError.DefaultResponse({})".format(str(self))
    _UniffiTempGetBlockTimeStampOffsetError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetBlockTimeStampOffsetError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTimeStampOffsetError.UnknownValue({})".format(str(self))
    _UniffiTempGetBlockTimeStampOffsetError.UnknownValue = UnknownValue # type: ignore

GetBlockTimeStampOffsetError = _UniffiTempGetBlockTimeStampOffsetError # type: ignore
del _UniffiTempGetBlockTimeStampOffsetError


class _UniffiConverterTypeGetBlockTimeStampOffsetError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetBlockTimeStampOffsetError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetBlockTimeStampOffsetError.Statusdefault(
            )
        if variant == 3:
            return GetBlockTimeStampOffsetError.DefaultResponse(
            )
        if variant == 4:
            return GetBlockTimeStampOffsetError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetBlockTimeStampOffsetError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockTimeStampOffsetError.Statusdefault):
            return
        if isinstance(value, GetBlockTimeStampOffsetError.DefaultResponse):
            return
        if isinstance(value, GetBlockTimeStampOffsetError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetBlockTimeStampOffsetError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockTimeStampOffsetError.Statusdefault):
            buf.write_i32(2)
        if isinstance(value, GetBlockTimeStampOffsetError.DefaultResponse):
            buf.write_i32(3)
        if isinstance(value, GetBlockTimeStampOffsetError.UnknownValue):
            buf.write_i32(4)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetBlockTxidsError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetBlockTxidsError(Exception):
    """
    struct for typed errors of method [`get_block_txids`]
    """

    pass

_UniffiTempGetBlockTxidsError = GetBlockTxidsError

class GetBlockTxidsError:  # type: ignore
    """
    struct for typed errors of method [`get_block_txids`]
    """

    class Status400(_UniffiTempGetBlockTxidsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTxidsError.Status400({})".format(str(self))
    _UniffiTempGetBlockTxidsError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetBlockTxidsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTxidsError.Status401({})".format(str(self))
    _UniffiTempGetBlockTxidsError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetBlockTxidsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTxidsError.Status404({})".format(str(self))
    _UniffiTempGetBlockTxidsError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetBlockTxidsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTxidsError.Status500({})".format(str(self))
    _UniffiTempGetBlockTxidsError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetBlockTxidsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockTxidsError.Statusdefault({})".format(str(self))
    _UniffiTempGetBlockTxidsError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetBlockTxidsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetBlockTxidsError.DefaultResponse({})".format(str(self))
    _UniffiTempGetBlockTxidsError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetBlockTxidsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetBlockTxidsError.UnknownValue({})".format(str(self))
    _UniffiTempGetBlockTxidsError.UnknownValue = UnknownValue # type: ignore

GetBlockTxidsError = _UniffiTempGetBlockTxidsError # type: ignore
del _UniffiTempGetBlockTxidsError


class _UniffiConverterTypeGetBlockTxidsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetBlockTxidsError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetBlockTxidsError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetBlockTxidsError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetBlockTxidsError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetBlockTxidsError.Statusdefault(
            )
        if variant == 6:
            return GetBlockTxidsError.DefaultResponse(
            )
        if variant == 7:
            return GetBlockTxidsError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetBlockTxidsError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockTxidsError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockTxidsError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockTxidsError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetBlockTxidsError.Statusdefault):
            return
        if isinstance(value, GetBlockTxidsError.DefaultResponse):
            return
        if isinstance(value, GetBlockTxidsError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetBlockTxidsError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockTxidsError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockTxidsError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockTxidsError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetBlockTxidsError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetBlockTxidsError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetBlockTxidsError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetConfigError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetConfigError(Exception):
    """
    struct for typed errors of method [`get_config`]
    """

    pass

_UniffiTempGetConfigError = GetConfigError

class GetConfigError:  # type: ignore
    """
    struct for typed errors of method [`get_config`]
    """

    class Statusdefault(_UniffiTempGetConfigError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetConfigError.Statusdefault({})".format(str(self))
    _UniffiTempGetConfigError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetConfigError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetConfigError.DefaultResponse({})".format(str(self))
    _UniffiTempGetConfigError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetConfigError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetConfigError.UnknownValue({})".format(str(self))
    _UniffiTempGetConfigError.UnknownValue = UnknownValue # type: ignore

GetConfigError = _UniffiTempGetConfigError # type: ignore
del _UniffiTempGetConfigError


class _UniffiConverterTypeGetConfigError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetConfigError.Statusdefault(
            )
        if variant == 2:
            return GetConfigError.DefaultResponse(
            )
        if variant == 3:
            return GetConfigError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetConfigError.Statusdefault):
            return
        if isinstance(value, GetConfigError.DefaultResponse):
            return
        if isinstance(value, GetConfigError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetConfigError.Statusdefault):
            buf.write_i32(1)
        if isinstance(value, GetConfigError.DefaultResponse):
            buf.write_i32(2)
        if isinstance(value, GetConfigError.UnknownValue):
            buf.write_i32(3)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetDebugSettingsProfError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetDebugSettingsProfError(Exception):
    """
    struct for typed errors of method [`get_debug_settings_prof`]
    """

    pass

_UniffiTempGetDebugSettingsProfError = GetDebugSettingsProfError

class GetDebugSettingsProfError:  # type: ignore
    """
    struct for typed errors of method [`get_debug_settings_prof`]
    """

    class DefaultResponse(_UniffiTempGetDebugSettingsProfError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetDebugSettingsProfError.DefaultResponse({})".format(str(self))
    _UniffiTempGetDebugSettingsProfError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetDebugSettingsProfError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetDebugSettingsProfError.UnknownValue({})".format(str(self))
    _UniffiTempGetDebugSettingsProfError.UnknownValue = UnknownValue # type: ignore

GetDebugSettingsProfError = _UniffiTempGetDebugSettingsProfError # type: ignore
del _UniffiTempGetDebugSettingsProfError


class _UniffiConverterTypeGetDebugSettingsProfError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetDebugSettingsProfError.DefaultResponse(
            )
        if variant == 2:
            return GetDebugSettingsProfError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetDebugSettingsProfError.DefaultResponse):
            return
        if isinstance(value, GetDebugSettingsProfError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetDebugSettingsProfError.DefaultResponse):
            buf.write_i32(1)
        if isinstance(value, GetDebugSettingsProfError.UnknownValue):
            buf.write_i32(2)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetGenesisError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetGenesisError(Exception):
    """
    struct for typed errors of method [`get_genesis`]
    """

    pass

_UniffiTempGetGenesisError = GetGenesisError

class GetGenesisError:  # type: ignore
    """
    struct for typed errors of method [`get_genesis`]
    """

    class Statusdefault(_UniffiTempGetGenesisError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetGenesisError.Statusdefault({})".format(str(self))
    _UniffiTempGetGenesisError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetGenesisError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetGenesisError.DefaultResponse({})".format(str(self))
    _UniffiTempGetGenesisError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetGenesisError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetGenesisError.UnknownValue({})".format(str(self))
    _UniffiTempGetGenesisError.UnknownValue = UnknownValue # type: ignore

GetGenesisError = _UniffiTempGetGenesisError # type: ignore
del _UniffiTempGetGenesisError


class _UniffiConverterTypeGetGenesisError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetGenesisError.Statusdefault(
            )
        if variant == 2:
            return GetGenesisError.DefaultResponse(
            )
        if variant == 3:
            return GetGenesisError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetGenesisError.Statusdefault):
            return
        if isinstance(value, GetGenesisError.DefaultResponse):
            return
        if isinstance(value, GetGenesisError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetGenesisError.Statusdefault):
            buf.write_i32(1)
        if isinstance(value, GetGenesisError.DefaultResponse):
            buf.write_i32(2)
        if isinstance(value, GetGenesisError.UnknownValue):
            buf.write_i32(3)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetLedgerStateDeltaError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetLedgerStateDeltaError(Exception):
    """
    struct for typed errors of method [`get_ledger_state_delta`]
    """

    pass

_UniffiTempGetLedgerStateDeltaError = GetLedgerStateDeltaError

class GetLedgerStateDeltaError:  # type: ignore
    """
    struct for typed errors of method [`get_ledger_state_delta`]
    """

    class Status401(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaError.Status401({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaError.Status404({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.Status404 = Status404 # type: ignore
    class Status408(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaError.Status408({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.Status408 = Status408 # type: ignore
    class Status500(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaError.Status500({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaError.Status503({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetLedgerStateDeltaError.Statusdefault({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetLedgerStateDeltaError.DefaultResponse({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetLedgerStateDeltaError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaError.UnknownValue({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaError.UnknownValue = UnknownValue # type: ignore

GetLedgerStateDeltaError = _UniffiTempGetLedgerStateDeltaError # type: ignore
del _UniffiTempGetLedgerStateDeltaError


class _UniffiConverterTypeGetLedgerStateDeltaError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetLedgerStateDeltaError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetLedgerStateDeltaError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetLedgerStateDeltaError.Status408(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetLedgerStateDeltaError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetLedgerStateDeltaError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return GetLedgerStateDeltaError.Statusdefault(
            )
        if variant == 7:
            return GetLedgerStateDeltaError.DefaultResponse(
            )
        if variant == 8:
            return GetLedgerStateDeltaError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetLedgerStateDeltaError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaError.Status408):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaError.Statusdefault):
            return
        if isinstance(value, GetLedgerStateDeltaError.DefaultResponse):
            return
        if isinstance(value, GetLedgerStateDeltaError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetLedgerStateDeltaError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaError.Status404):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaError.Status408):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaError.Status503):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, GetLedgerStateDeltaError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, GetLedgerStateDeltaError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetLedgerStateDeltaForTransactionGroupError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetLedgerStateDeltaForTransactionGroupError(Exception):
    """
    struct for typed errors of method [`get_ledger_state_delta_for_transaction_group`]
    """

    pass

_UniffiTempGetLedgerStateDeltaForTransactionGroupError = GetLedgerStateDeltaForTransactionGroupError

class GetLedgerStateDeltaForTransactionGroupError:  # type: ignore
    """
    struct for typed errors of method [`get_ledger_state_delta_for_transaction_group`]
    """

    class Status401(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.Status401({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.Status404({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.Status404 = Status404 # type: ignore
    class Status408(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.Status408({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.Status408 = Status408 # type: ignore
    class Status500(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.Status500({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.Status500 = Status500 # type: ignore
    class Status501(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.Status501({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.Status501 = Status501 # type: ignore
    class Statusdefault(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.Statusdefault({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.DefaultResponse({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetLedgerStateDeltaForTransactionGroupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLedgerStateDeltaForTransactionGroupError.UnknownValue({})".format(str(self))
    _UniffiTempGetLedgerStateDeltaForTransactionGroupError.UnknownValue = UnknownValue # type: ignore

GetLedgerStateDeltaForTransactionGroupError = _UniffiTempGetLedgerStateDeltaForTransactionGroupError # type: ignore
del _UniffiTempGetLedgerStateDeltaForTransactionGroupError


class _UniffiConverterTypeGetLedgerStateDeltaForTransactionGroupError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetLedgerStateDeltaForTransactionGroupError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetLedgerStateDeltaForTransactionGroupError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetLedgerStateDeltaForTransactionGroupError.Status408(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetLedgerStateDeltaForTransactionGroupError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetLedgerStateDeltaForTransactionGroupError.Status501(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return GetLedgerStateDeltaForTransactionGroupError.Statusdefault(
            )
        if variant == 7:
            return GetLedgerStateDeltaForTransactionGroupError.DefaultResponse(
            )
        if variant == 8:
            return GetLedgerStateDeltaForTransactionGroupError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status408):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status501):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Statusdefault):
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.DefaultResponse):
            return
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status404):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status408):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Status501):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, GetLedgerStateDeltaForTransactionGroupError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetLightBlockHeaderProofError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetLightBlockHeaderProofError(Exception):
    """
    struct for typed errors of method [`get_light_block_header_proof`]
    """

    pass

_UniffiTempGetLightBlockHeaderProofError = GetLightBlockHeaderProofError

class GetLightBlockHeaderProofError:  # type: ignore
    """
    struct for typed errors of method [`get_light_block_header_proof`]
    """

    class Status401(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLightBlockHeaderProofError.Status401({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLightBlockHeaderProofError.Status404({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.Status404 = Status404 # type: ignore
    class Status408(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLightBlockHeaderProofError.Status408({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.Status408 = Status408 # type: ignore
    class Status500(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLightBlockHeaderProofError.Status500({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLightBlockHeaderProofError.Status503({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetLightBlockHeaderProofError.Statusdefault({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetLightBlockHeaderProofError.DefaultResponse({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetLightBlockHeaderProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetLightBlockHeaderProofError.UnknownValue({})".format(str(self))
    _UniffiTempGetLightBlockHeaderProofError.UnknownValue = UnknownValue # type: ignore

GetLightBlockHeaderProofError = _UniffiTempGetLightBlockHeaderProofError # type: ignore
del _UniffiTempGetLightBlockHeaderProofError


class _UniffiConverterTypeGetLightBlockHeaderProofError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetLightBlockHeaderProofError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetLightBlockHeaderProofError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetLightBlockHeaderProofError.Status408(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetLightBlockHeaderProofError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetLightBlockHeaderProofError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return GetLightBlockHeaderProofError.Statusdefault(
            )
        if variant == 7:
            return GetLightBlockHeaderProofError.DefaultResponse(
            )
        if variant == 8:
            return GetLightBlockHeaderProofError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetLightBlockHeaderProofError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLightBlockHeaderProofError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLightBlockHeaderProofError.Status408):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLightBlockHeaderProofError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLightBlockHeaderProofError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetLightBlockHeaderProofError.Statusdefault):
            return
        if isinstance(value, GetLightBlockHeaderProofError.DefaultResponse):
            return
        if isinstance(value, GetLightBlockHeaderProofError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetLightBlockHeaderProofError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLightBlockHeaderProofError.Status404):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLightBlockHeaderProofError.Status408):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLightBlockHeaderProofError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLightBlockHeaderProofError.Status503):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetLightBlockHeaderProofError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, GetLightBlockHeaderProofError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, GetLightBlockHeaderProofError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetParticipationKeyByIdError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetParticipationKeyByIdError(Exception):
    """
    struct for typed errors of method [`get_participation_key_by_id`]
    """

    pass

_UniffiTempGetParticipationKeyByIdError = GetParticipationKeyByIdError

class GetParticipationKeyByIdError:  # type: ignore
    """
    struct for typed errors of method [`get_participation_key_by_id`]
    """

    class Status400(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeyByIdError.Status400({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeyByIdError.Status401({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeyByIdError.Status404({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeyByIdError.Status500({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetParticipationKeyByIdError.Statusdefault({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetParticipationKeyByIdError.DefaultResponse({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetParticipationKeyByIdError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeyByIdError.UnknownValue({})".format(str(self))
    _UniffiTempGetParticipationKeyByIdError.UnknownValue = UnknownValue # type: ignore

GetParticipationKeyByIdError = _UniffiTempGetParticipationKeyByIdError # type: ignore
del _UniffiTempGetParticipationKeyByIdError


class _UniffiConverterTypeGetParticipationKeyByIdError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetParticipationKeyByIdError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetParticipationKeyByIdError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetParticipationKeyByIdError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetParticipationKeyByIdError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetParticipationKeyByIdError.Statusdefault(
            )
        if variant == 6:
            return GetParticipationKeyByIdError.DefaultResponse(
            )
        if variant == 7:
            return GetParticipationKeyByIdError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetParticipationKeyByIdError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeyByIdError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeyByIdError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeyByIdError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeyByIdError.Statusdefault):
            return
        if isinstance(value, GetParticipationKeyByIdError.DefaultResponse):
            return
        if isinstance(value, GetParticipationKeyByIdError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetParticipationKeyByIdError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeyByIdError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeyByIdError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeyByIdError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeyByIdError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetParticipationKeyByIdError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetParticipationKeyByIdError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetParticipationKeysError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetParticipationKeysError(Exception):
    """
    struct for typed errors of method [`get_participation_keys`]
    """

    pass

_UniffiTempGetParticipationKeysError = GetParticipationKeysError

class GetParticipationKeysError:  # type: ignore
    """
    struct for typed errors of method [`get_participation_keys`]
    """

    class Status400(_UniffiTempGetParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeysError.Status400({})".format(str(self))
    _UniffiTempGetParticipationKeysError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeysError.Status401({})".format(str(self))
    _UniffiTempGetParticipationKeysError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeysError.Status404({})".format(str(self))
    _UniffiTempGetParticipationKeysError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeysError.Status500({})".format(str(self))
    _UniffiTempGetParticipationKeysError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetParticipationKeysError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetParticipationKeysError.Statusdefault({})".format(str(self))
    _UniffiTempGetParticipationKeysError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetParticipationKeysError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetParticipationKeysError.DefaultResponse({})".format(str(self))
    _UniffiTempGetParticipationKeysError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetParticipationKeysError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetParticipationKeysError.UnknownValue({})".format(str(self))
    _UniffiTempGetParticipationKeysError.UnknownValue = UnknownValue # type: ignore

GetParticipationKeysError = _UniffiTempGetParticipationKeysError # type: ignore
del _UniffiTempGetParticipationKeysError


class _UniffiConverterTypeGetParticipationKeysError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetParticipationKeysError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetParticipationKeysError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetParticipationKeysError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetParticipationKeysError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetParticipationKeysError.Statusdefault(
            )
        if variant == 6:
            return GetParticipationKeysError.DefaultResponse(
            )
        if variant == 7:
            return GetParticipationKeysError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetParticipationKeysError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeysError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeysError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeysError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetParticipationKeysError.Statusdefault):
            return
        if isinstance(value, GetParticipationKeysError.DefaultResponse):
            return
        if isinstance(value, GetParticipationKeysError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetParticipationKeysError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeysError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeysError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeysError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetParticipationKeysError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetParticipationKeysError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetParticipationKeysError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetPendingTransactionsByAddressError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetPendingTransactionsByAddressError(Exception):
    """
    struct for typed errors of method [`get_pending_transactions_by_address`]
    """

    pass

_UniffiTempGetPendingTransactionsByAddressError = GetPendingTransactionsByAddressError

class GetPendingTransactionsByAddressError:  # type: ignore
    """
    struct for typed errors of method [`get_pending_transactions_by_address`]
    """

    class Status400(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.Status400({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.Status401({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.Status500({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.Status503({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.Statusdefault({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.DefaultResponse({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetPendingTransactionsByAddressError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsByAddressError.UnknownValue({})".format(str(self))
    _UniffiTempGetPendingTransactionsByAddressError.UnknownValue = UnknownValue # type: ignore

GetPendingTransactionsByAddressError = _UniffiTempGetPendingTransactionsByAddressError # type: ignore
del _UniffiTempGetPendingTransactionsByAddressError


class _UniffiConverterTypeGetPendingTransactionsByAddressError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetPendingTransactionsByAddressError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetPendingTransactionsByAddressError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetPendingTransactionsByAddressError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetPendingTransactionsByAddressError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetPendingTransactionsByAddressError.Statusdefault(
            )
        if variant == 6:
            return GetPendingTransactionsByAddressError.DefaultResponse(
            )
        if variant == 7:
            return GetPendingTransactionsByAddressError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetPendingTransactionsByAddressError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsByAddressError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsByAddressError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsByAddressError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsByAddressError.Statusdefault):
            return
        if isinstance(value, GetPendingTransactionsByAddressError.DefaultResponse):
            return
        if isinstance(value, GetPendingTransactionsByAddressError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetPendingTransactionsByAddressError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsByAddressError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsByAddressError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsByAddressError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsByAddressError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetPendingTransactionsByAddressError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetPendingTransactionsByAddressError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetPendingTransactionsError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetPendingTransactionsError(Exception):
    """
    struct for typed errors of method [`get_pending_transactions`]
    """

    pass

_UniffiTempGetPendingTransactionsError = GetPendingTransactionsError

class GetPendingTransactionsError:  # type: ignore
    """
    struct for typed errors of method [`get_pending_transactions`]
    """

    class Status401(_UniffiTempGetPendingTransactionsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsError.Status401({})".format(str(self))
    _UniffiTempGetPendingTransactionsError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempGetPendingTransactionsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsError.Status500({})".format(str(self))
    _UniffiTempGetPendingTransactionsError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetPendingTransactionsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsError.Status503({})".format(str(self))
    _UniffiTempGetPendingTransactionsError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetPendingTransactionsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetPendingTransactionsError.Statusdefault({})".format(str(self))
    _UniffiTempGetPendingTransactionsError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetPendingTransactionsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetPendingTransactionsError.DefaultResponse({})".format(str(self))
    _UniffiTempGetPendingTransactionsError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetPendingTransactionsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetPendingTransactionsError.UnknownValue({})".format(str(self))
    _UniffiTempGetPendingTransactionsError.UnknownValue = UnknownValue # type: ignore

GetPendingTransactionsError = _UniffiTempGetPendingTransactionsError # type: ignore
del _UniffiTempGetPendingTransactionsError


class _UniffiConverterTypeGetPendingTransactionsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetPendingTransactionsError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetPendingTransactionsError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetPendingTransactionsError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetPendingTransactionsError.Statusdefault(
            )
        if variant == 5:
            return GetPendingTransactionsError.DefaultResponse(
            )
        if variant == 6:
            return GetPendingTransactionsError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetPendingTransactionsError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetPendingTransactionsError.Statusdefault):
            return
        if isinstance(value, GetPendingTransactionsError.DefaultResponse):
            return
        if isinstance(value, GetPendingTransactionsError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetPendingTransactionsError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsError.Status500):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsError.Status503):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetPendingTransactionsError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, GetPendingTransactionsError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, GetPendingTransactionsError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetReadyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetReadyError(Exception):
    """
    struct for typed errors of method [`get_ready`]
    """

    pass

_UniffiTempGetReadyError = GetReadyError

class GetReadyError:  # type: ignore
    """
    struct for typed errors of method [`get_ready`]
    """

    class Status500(_UniffiTempGetReadyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetReadyError.Status500({})".format(str(self))
    _UniffiTempGetReadyError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetReadyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetReadyError.Status503({})".format(str(self))
    _UniffiTempGetReadyError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetReadyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetReadyError.Statusdefault({})".format(str(self))
    _UniffiTempGetReadyError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetReadyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetReadyError.DefaultResponse({})".format(str(self))
    _UniffiTempGetReadyError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetReadyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetReadyError.UnknownValue({})".format(str(self))
    _UniffiTempGetReadyError.UnknownValue = UnknownValue # type: ignore

GetReadyError = _UniffiTempGetReadyError # type: ignore
del _UniffiTempGetReadyError


class _UniffiConverterTypeGetReadyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetReadyError.Status500(
            )
        if variant == 2:
            return GetReadyError.Status503(
            )
        if variant == 3:
            return GetReadyError.Statusdefault(
            )
        if variant == 4:
            return GetReadyError.DefaultResponse(
            )
        if variant == 5:
            return GetReadyError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetReadyError.Status500):
            return
        if isinstance(value, GetReadyError.Status503):
            return
        if isinstance(value, GetReadyError.Statusdefault):
            return
        if isinstance(value, GetReadyError.DefaultResponse):
            return
        if isinstance(value, GetReadyError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetReadyError.Status500):
            buf.write_i32(1)
        if isinstance(value, GetReadyError.Status503):
            buf.write_i32(2)
        if isinstance(value, GetReadyError.Statusdefault):
            buf.write_i32(3)
        if isinstance(value, GetReadyError.DefaultResponse):
            buf.write_i32(4)
        if isinstance(value, GetReadyError.UnknownValue):
            buf.write_i32(5)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetStateProofError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetStateProofError(Exception):
    """
    struct for typed errors of method [`get_state_proof`]
    """

    pass

_UniffiTempGetStateProofError = GetStateProofError

class GetStateProofError:  # type: ignore
    """
    struct for typed errors of method [`get_state_proof`]
    """

    class Status401(_UniffiTempGetStateProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStateProofError.Status401({})".format(str(self))
    _UniffiTempGetStateProofError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetStateProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStateProofError.Status404({})".format(str(self))
    _UniffiTempGetStateProofError.Status404 = Status404 # type: ignore
    class Status408(_UniffiTempGetStateProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStateProofError.Status408({})".format(str(self))
    _UniffiTempGetStateProofError.Status408 = Status408 # type: ignore
    class Status500(_UniffiTempGetStateProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStateProofError.Status500({})".format(str(self))
    _UniffiTempGetStateProofError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetStateProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStateProofError.Status503({})".format(str(self))
    _UniffiTempGetStateProofError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetStateProofError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetStateProofError.Statusdefault({})".format(str(self))
    _UniffiTempGetStateProofError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetStateProofError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetStateProofError.DefaultResponse({})".format(str(self))
    _UniffiTempGetStateProofError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetStateProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStateProofError.UnknownValue({})".format(str(self))
    _UniffiTempGetStateProofError.UnknownValue = UnknownValue # type: ignore

GetStateProofError = _UniffiTempGetStateProofError # type: ignore
del _UniffiTempGetStateProofError


class _UniffiConverterTypeGetStateProofError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetStateProofError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetStateProofError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetStateProofError.Status408(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetStateProofError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetStateProofError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return GetStateProofError.Statusdefault(
            )
        if variant == 7:
            return GetStateProofError.DefaultResponse(
            )
        if variant == 8:
            return GetStateProofError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetStateProofError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetStateProofError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetStateProofError.Status408):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetStateProofError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetStateProofError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetStateProofError.Statusdefault):
            return
        if isinstance(value, GetStateProofError.DefaultResponse):
            return
        if isinstance(value, GetStateProofError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetStateProofError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetStateProofError.Status404):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetStateProofError.Status408):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetStateProofError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetStateProofError.Status503):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetStateProofError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, GetStateProofError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, GetStateProofError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetStatusError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetStatusError(Exception):
    """
    struct for typed errors of method [`get_status`]
    """

    pass

_UniffiTempGetStatusError = GetStatusError

class GetStatusError:  # type: ignore
    """
    struct for typed errors of method [`get_status`]
    """

    class Status401(_UniffiTempGetStatusError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStatusError.Status401({})".format(str(self))
    _UniffiTempGetStatusError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempGetStatusError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStatusError.Status500({})".format(str(self))
    _UniffiTempGetStatusError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetStatusError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetStatusError.Statusdefault({})".format(str(self))
    _UniffiTempGetStatusError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetStatusError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetStatusError.DefaultResponse({})".format(str(self))
    _UniffiTempGetStatusError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetStatusError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetStatusError.UnknownValue({})".format(str(self))
    _UniffiTempGetStatusError.UnknownValue = UnknownValue # type: ignore

GetStatusError = _UniffiTempGetStatusError # type: ignore
del _UniffiTempGetStatusError


class _UniffiConverterTypeGetStatusError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetStatusError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetStatusError.Status500(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return GetStatusError.Statusdefault(
            )
        if variant == 4:
            return GetStatusError.DefaultResponse(
            )
        if variant == 5:
            return GetStatusError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetStatusError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetStatusError.Status500):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, GetStatusError.Statusdefault):
            return
        if isinstance(value, GetStatusError.DefaultResponse):
            return
        if isinstance(value, GetStatusError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetStatusError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetStatusError.Status500):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, GetStatusError.Statusdefault):
            buf.write_i32(3)
        if isinstance(value, GetStatusError.DefaultResponse):
            buf.write_i32(4)
        if isinstance(value, GetStatusError.UnknownValue):
            buf.write_i32(5)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetSupplyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetSupplyError(Exception):
    """
    struct for typed errors of method [`get_supply`]
    """

    pass

_UniffiTempGetSupplyError = GetSupplyError

class GetSupplyError:  # type: ignore
    """
    struct for typed errors of method [`get_supply`]
    """

    class Status401(_UniffiTempGetSupplyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSupplyError.Status401({})".format(str(self))
    _UniffiTempGetSupplyError.Status401 = Status401 # type: ignore
    class Statusdefault(_UniffiTempGetSupplyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetSupplyError.Statusdefault({})".format(str(self))
    _UniffiTempGetSupplyError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetSupplyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetSupplyError.DefaultResponse({})".format(str(self))
    _UniffiTempGetSupplyError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetSupplyError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSupplyError.UnknownValue({})".format(str(self))
    _UniffiTempGetSupplyError.UnknownValue = UnknownValue # type: ignore

GetSupplyError = _UniffiTempGetSupplyError # type: ignore
del _UniffiTempGetSupplyError


class _UniffiConverterTypeGetSupplyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetSupplyError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetSupplyError.Statusdefault(
            )
        if variant == 3:
            return GetSupplyError.DefaultResponse(
            )
        if variant == 4:
            return GetSupplyError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetSupplyError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetSupplyError.Statusdefault):
            return
        if isinstance(value, GetSupplyError.DefaultResponse):
            return
        if isinstance(value, GetSupplyError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetSupplyError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetSupplyError.Statusdefault):
            buf.write_i32(2)
        if isinstance(value, GetSupplyError.DefaultResponse):
            buf.write_i32(3)
        if isinstance(value, GetSupplyError.UnknownValue):
            buf.write_i32(4)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetSyncRoundError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetSyncRoundError(Exception):
    """
    struct for typed errors of method [`get_sync_round`]
    """

    pass

_UniffiTempGetSyncRoundError = GetSyncRoundError

class GetSyncRoundError:  # type: ignore
    """
    struct for typed errors of method [`get_sync_round`]
    """

    class Status400(_UniffiTempGetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSyncRoundError.Status400({})".format(str(self))
    _UniffiTempGetSyncRoundError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSyncRoundError.Status401({})".format(str(self))
    _UniffiTempGetSyncRoundError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempGetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSyncRoundError.Status500({})".format(str(self))
    _UniffiTempGetSyncRoundError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempGetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSyncRoundError.Status503({})".format(str(self))
    _UniffiTempGetSyncRoundError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempGetSyncRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetSyncRoundError.Statusdefault({})".format(str(self))
    _UniffiTempGetSyncRoundError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetSyncRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetSyncRoundError.DefaultResponse({})".format(str(self))
    _UniffiTempGetSyncRoundError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetSyncRoundError.UnknownValue({})".format(str(self))
    _UniffiTempGetSyncRoundError.UnknownValue = UnknownValue # type: ignore

GetSyncRoundError = _UniffiTempGetSyncRoundError # type: ignore
del _UniffiTempGetSyncRoundError


class _UniffiConverterTypeGetSyncRoundError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetSyncRoundError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetSyncRoundError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetSyncRoundError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetSyncRoundError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetSyncRoundError.Statusdefault(
            )
        if variant == 6:
            return GetSyncRoundError.DefaultResponse(
            )
        if variant == 7:
            return GetSyncRoundError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetSyncRoundError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetSyncRoundError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetSyncRoundError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetSyncRoundError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetSyncRoundError.Statusdefault):
            return
        if isinstance(value, GetSyncRoundError.DefaultResponse):
            return
        if isinstance(value, GetSyncRoundError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetSyncRoundError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetSyncRoundError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetSyncRoundError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetSyncRoundError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetSyncRoundError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetSyncRoundError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetSyncRoundError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetTransactionGroupLedgerStateDeltasForRoundError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetTransactionGroupLedgerStateDeltasForRoundError(Exception):
    """
    struct for typed errors of method [`get_transaction_group_ledger_state_deltas_for_round`]
    """

    pass

_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError = GetTransactionGroupLedgerStateDeltasForRoundError

class GetTransactionGroupLedgerStateDeltasForRoundError:  # type: ignore
    """
    struct for typed errors of method [`get_transaction_group_ledger_state_deltas_for_round`]
    """

    class Status401(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.Status401({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.Status404({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.Status404 = Status404 # type: ignore
    class Status408(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.Status408({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.Status408 = Status408 # type: ignore
    class Status500(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.Status500({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.Status500 = Status500 # type: ignore
    class Status501(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.Status501({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.Status501 = Status501 # type: ignore
    class Statusdefault(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.Statusdefault({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.DefaultResponse({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionGroupLedgerStateDeltasForRoundError.UnknownValue({})".format(str(self))
    _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError.UnknownValue = UnknownValue # type: ignore

GetTransactionGroupLedgerStateDeltasForRoundError = _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError # type: ignore
del _UniffiTempGetTransactionGroupLedgerStateDeltasForRoundError


class _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRoundError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetTransactionGroupLedgerStateDeltasForRoundError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetTransactionGroupLedgerStateDeltasForRoundError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetTransactionGroupLedgerStateDeltasForRoundError.Status408(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetTransactionGroupLedgerStateDeltasForRoundError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetTransactionGroupLedgerStateDeltasForRoundError.Status501(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return GetTransactionGroupLedgerStateDeltasForRoundError.Statusdefault(
            )
        if variant == 7:
            return GetTransactionGroupLedgerStateDeltasForRoundError.DefaultResponse(
            )
        if variant == 8:
            return GetTransactionGroupLedgerStateDeltasForRoundError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status408):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status501):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Statusdefault):
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.DefaultResponse):
            return
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status404):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status408):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Status501):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, GetTransactionGroupLedgerStateDeltasForRoundError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetTransactionProofError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetTransactionProofError(Exception):
    """
    struct for typed errors of method [`get_transaction_proof`]
    """

    pass

_UniffiTempGetTransactionProofError = GetTransactionProofError

class GetTransactionProofError:  # type: ignore
    """
    struct for typed errors of method [`get_transaction_proof`]
    """

    class Status400(_UniffiTempGetTransactionProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionProofError.Status400({})".format(str(self))
    _UniffiTempGetTransactionProofError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempGetTransactionProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionProofError.Status401({})".format(str(self))
    _UniffiTempGetTransactionProofError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempGetTransactionProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionProofError.Status404({})".format(str(self))
    _UniffiTempGetTransactionProofError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempGetTransactionProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionProofError.Status500({})".format(str(self))
    _UniffiTempGetTransactionProofError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempGetTransactionProofError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetTransactionProofError.Statusdefault({})".format(str(self))
    _UniffiTempGetTransactionProofError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempGetTransactionProofError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetTransactionProofError.DefaultResponse({})".format(str(self))
    _UniffiTempGetTransactionProofError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetTransactionProofError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetTransactionProofError.UnknownValue({})".format(str(self))
    _UniffiTempGetTransactionProofError.UnknownValue = UnknownValue # type: ignore

GetTransactionProofError = _UniffiTempGetTransactionProofError # type: ignore
del _UniffiTempGetTransactionProofError


class _UniffiConverterTypeGetTransactionProofError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetTransactionProofError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return GetTransactionProofError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return GetTransactionProofError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return GetTransactionProofError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return GetTransactionProofError.Statusdefault(
            )
        if variant == 6:
            return GetTransactionProofError.DefaultResponse(
            )
        if variant == 7:
            return GetTransactionProofError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetTransactionProofError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionProofError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionProofError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionProofError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, GetTransactionProofError.Statusdefault):
            return
        if isinstance(value, GetTransactionProofError.DefaultResponse):
            return
        if isinstance(value, GetTransactionProofError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetTransactionProofError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionProofError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionProofError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionProofError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, GetTransactionProofError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, GetTransactionProofError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, GetTransactionProofError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# GetVersionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class GetVersionError(Exception):
    """
    struct for typed errors of method [`get_version`]
    """

    pass

_UniffiTempGetVersionError = GetVersionError

class GetVersionError:  # type: ignore
    """
    struct for typed errors of method [`get_version`]
    """

    class DefaultResponse(_UniffiTempGetVersionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "GetVersionError.DefaultResponse({})".format(str(self))
    _UniffiTempGetVersionError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempGetVersionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "GetVersionError.UnknownValue({})".format(str(self))
    _UniffiTempGetVersionError.UnknownValue = UnknownValue # type: ignore

GetVersionError = _UniffiTempGetVersionError # type: ignore
del _UniffiTempGetVersionError


class _UniffiConverterTypeGetVersionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return GetVersionError.DefaultResponse(
            )
        if variant == 2:
            return GetVersionError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, GetVersionError.DefaultResponse):
            return
        if isinstance(value, GetVersionError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, GetVersionError.DefaultResponse):
            buf.write_i32(1)
        if isinstance(value, GetVersionError.UnknownValue):
            buf.write_i32(2)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)





class Hashtype(enum.Enum):
    """
    The type of hash function used to create the proof, must be one of:
    * sha512_256
    * sha256
    """

    SHA512256 = 0
    """
    sha512_256
    """

    
    SHA256 = 1
    """
    sha256
    """

    


class _UniffiConverterTypeHashtype(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Hashtype.SHA512256
        if variant == 2:
            return Hashtype.SHA256
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Hashtype.SHA512256:
            return
        if value == Hashtype.SHA256:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Hashtype.SHA512256:
            buf.write_i32(1)
        if value == Hashtype.SHA256:
            buf.write_i32(2)




# HealthCheckError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class HealthCheckError(Exception):
    """
    struct for typed errors of method [`health_check`]
    """

    pass

_UniffiTempHealthCheckError = HealthCheckError

class HealthCheckError:  # type: ignore
    """
    struct for typed errors of method [`health_check`]
    """

    class Statusdefault(_UniffiTempHealthCheckError):
        def __init__(self):
            pass

        def __repr__(self):
            return "HealthCheckError.Statusdefault({})".format(str(self))
    _UniffiTempHealthCheckError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempHealthCheckError):
        def __init__(self):
            pass

        def __repr__(self):
            return "HealthCheckError.DefaultResponse({})".format(str(self))
    _UniffiTempHealthCheckError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempHealthCheckError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "HealthCheckError.UnknownValue({})".format(str(self))
    _UniffiTempHealthCheckError.UnknownValue = UnknownValue # type: ignore

HealthCheckError = _UniffiTempHealthCheckError # type: ignore
del _UniffiTempHealthCheckError


class _UniffiConverterTypeHealthCheckError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return HealthCheckError.Statusdefault(
            )
        if variant == 2:
            return HealthCheckError.DefaultResponse(
            )
        if variant == 3:
            return HealthCheckError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, HealthCheckError.Statusdefault):
            return
        if isinstance(value, HealthCheckError.DefaultResponse):
            return
        if isinstance(value, HealthCheckError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, HealthCheckError.Statusdefault):
            buf.write_i32(1)
        if isinstance(value, HealthCheckError.DefaultResponse):
            buf.write_i32(2)
        if isinstance(value, HealthCheckError.UnknownValue):
            buf.write_i32(3)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# MetricsError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MetricsError(Exception):
    """
    struct for typed errors of method [`metrics`]
    """

    pass

_UniffiTempMetricsError = MetricsError

class MetricsError:  # type: ignore
    """
    struct for typed errors of method [`metrics`]
    """

    class Status404(_UniffiTempMetricsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MetricsError.Status404({})".format(str(self))
    _UniffiTempMetricsError.Status404 = Status404 # type: ignore
    class DefaultResponse(_UniffiTempMetricsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "MetricsError.DefaultResponse({})".format(str(self))
    _UniffiTempMetricsError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempMetricsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "MetricsError.UnknownValue({})".format(str(self))
    _UniffiTempMetricsError.UnknownValue = UnknownValue # type: ignore

MetricsError = _UniffiTempMetricsError # type: ignore
del _UniffiTempMetricsError


class _UniffiConverterTypeMetricsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MetricsError.Status404(
            )
        if variant == 2:
            return MetricsError.DefaultResponse(
            )
        if variant == 3:
            return MetricsError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MetricsError.Status404):
            return
        if isinstance(value, MetricsError.DefaultResponse):
            return
        if isinstance(value, MetricsError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MetricsError.Status404):
            buf.write_i32(1)
        if isinstance(value, MetricsError.DefaultResponse):
            buf.write_i32(2)
        if isinstance(value, MetricsError.UnknownValue):
            buf.write_i32(3)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# PendingTransactionInformationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PendingTransactionInformationError(Exception):
    """
    struct for typed errors of method [`pending_transaction_information`]
    """

    pass

_UniffiTempPendingTransactionInformationError = PendingTransactionInformationError

class PendingTransactionInformationError:  # type: ignore
    """
    struct for typed errors of method [`pending_transaction_information`]
    """

    class Status400(_UniffiTempPendingTransactionInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PendingTransactionInformationError.Status400({})".format(str(self))
    _UniffiTempPendingTransactionInformationError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempPendingTransactionInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PendingTransactionInformationError.Status401({})".format(str(self))
    _UniffiTempPendingTransactionInformationError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempPendingTransactionInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PendingTransactionInformationError.Status404({})".format(str(self))
    _UniffiTempPendingTransactionInformationError.Status404 = Status404 # type: ignore
    class Statusdefault(_UniffiTempPendingTransactionInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PendingTransactionInformationError.Statusdefault({})".format(str(self))
    _UniffiTempPendingTransactionInformationError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempPendingTransactionInformationError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PendingTransactionInformationError.DefaultResponse({})".format(str(self))
    _UniffiTempPendingTransactionInformationError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempPendingTransactionInformationError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PendingTransactionInformationError.UnknownValue({})".format(str(self))
    _UniffiTempPendingTransactionInformationError.UnknownValue = UnknownValue # type: ignore

PendingTransactionInformationError = _UniffiTempPendingTransactionInformationError # type: ignore
del _UniffiTempPendingTransactionInformationError


class _UniffiConverterTypePendingTransactionInformationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PendingTransactionInformationError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return PendingTransactionInformationError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return PendingTransactionInformationError.Status404(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return PendingTransactionInformationError.Statusdefault(
            )
        if variant == 5:
            return PendingTransactionInformationError.DefaultResponse(
            )
        if variant == 6:
            return PendingTransactionInformationError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PendingTransactionInformationError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, PendingTransactionInformationError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, PendingTransactionInformationError.Status404):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, PendingTransactionInformationError.Statusdefault):
            return
        if isinstance(value, PendingTransactionInformationError.DefaultResponse):
            return
        if isinstance(value, PendingTransactionInformationError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PendingTransactionInformationError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, PendingTransactionInformationError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, PendingTransactionInformationError.Status404):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, PendingTransactionInformationError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, PendingTransactionInformationError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, PendingTransactionInformationError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# PutDebugSettingsProfError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PutDebugSettingsProfError(Exception):
    """
    struct for typed errors of method [`put_debug_settings_prof`]
    """

    pass

_UniffiTempPutDebugSettingsProfError = PutDebugSettingsProfError

class PutDebugSettingsProfError:  # type: ignore
    """
    struct for typed errors of method [`put_debug_settings_prof`]
    """

    class DefaultResponse(_UniffiTempPutDebugSettingsProfError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PutDebugSettingsProfError.DefaultResponse({})".format(str(self))
    _UniffiTempPutDebugSettingsProfError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempPutDebugSettingsProfError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "PutDebugSettingsProfError.UnknownValue({})".format(str(self))
    _UniffiTempPutDebugSettingsProfError.UnknownValue = UnknownValue # type: ignore

PutDebugSettingsProfError = _UniffiTempPutDebugSettingsProfError # type: ignore
del _UniffiTempPutDebugSettingsProfError


class _UniffiConverterTypePutDebugSettingsProfError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PutDebugSettingsProfError.DefaultResponse(
            )
        if variant == 2:
            return PutDebugSettingsProfError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PutDebugSettingsProfError.DefaultResponse):
            return
        if isinstance(value, PutDebugSettingsProfError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PutDebugSettingsProfError.DefaultResponse):
            buf.write_i32(1)
        if isinstance(value, PutDebugSettingsProfError.UnknownValue):
            buf.write_i32(2)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# RawTransactionAsyncError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RawTransactionAsyncError(Exception):
    """
    struct for typed errors of method [`raw_transaction_async`]
    """

    pass

_UniffiTempRawTransactionAsyncError = RawTransactionAsyncError

class RawTransactionAsyncError:  # type: ignore
    """
    struct for typed errors of method [`raw_transaction_async`]
    """

    class Status400(_UniffiTempRawTransactionAsyncError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionAsyncError.Status400({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempRawTransactionAsyncError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionAsyncError.Status401({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempRawTransactionAsyncError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RawTransactionAsyncError.Status404({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempRawTransactionAsyncError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionAsyncError.Status500({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempRawTransactionAsyncError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionAsyncError.Status503({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempRawTransactionAsyncError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RawTransactionAsyncError.Statusdefault({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempRawTransactionAsyncError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RawTransactionAsyncError.DefaultResponse({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempRawTransactionAsyncError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionAsyncError.UnknownValue({})".format(str(self))
    _UniffiTempRawTransactionAsyncError.UnknownValue = UnknownValue # type: ignore

RawTransactionAsyncError = _UniffiTempRawTransactionAsyncError # type: ignore
del _UniffiTempRawTransactionAsyncError


class _UniffiConverterTypeRawTransactionAsyncError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RawTransactionAsyncError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return RawTransactionAsyncError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return RawTransactionAsyncError.Status404(
            )
        if variant == 4:
            return RawTransactionAsyncError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return RawTransactionAsyncError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 6:
            return RawTransactionAsyncError.Statusdefault(
            )
        if variant == 7:
            return RawTransactionAsyncError.DefaultResponse(
            )
        if variant == 8:
            return RawTransactionAsyncError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, RawTransactionAsyncError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionAsyncError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionAsyncError.Status404):
            return
        if isinstance(value, RawTransactionAsyncError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionAsyncError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionAsyncError.Statusdefault):
            return
        if isinstance(value, RawTransactionAsyncError.DefaultResponse):
            return
        if isinstance(value, RawTransactionAsyncError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, RawTransactionAsyncError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionAsyncError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionAsyncError.Status404):
            buf.write_i32(3)
        if isinstance(value, RawTransactionAsyncError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionAsyncError.Status503):
            buf.write_i32(5)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionAsyncError.Statusdefault):
            buf.write_i32(6)
        if isinstance(value, RawTransactionAsyncError.DefaultResponse):
            buf.write_i32(7)
        if isinstance(value, RawTransactionAsyncError.UnknownValue):
            buf.write_i32(8)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# RawTransactionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RawTransactionError(Exception):
    """
    struct for typed errors of method [`raw_transaction`]
    """

    pass

_UniffiTempRawTransactionError = RawTransactionError

class RawTransactionError:  # type: ignore
    """
    struct for typed errors of method [`raw_transaction`]
    """

    class Status400(_UniffiTempRawTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionError.Status400({})".format(str(self))
    _UniffiTempRawTransactionError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempRawTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionError.Status401({})".format(str(self))
    _UniffiTempRawTransactionError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempRawTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionError.Status500({})".format(str(self))
    _UniffiTempRawTransactionError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempRawTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionError.Status503({})".format(str(self))
    _UniffiTempRawTransactionError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempRawTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RawTransactionError.Statusdefault({})".format(str(self))
    _UniffiTempRawTransactionError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempRawTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RawTransactionError.DefaultResponse({})".format(str(self))
    _UniffiTempRawTransactionError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempRawTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "RawTransactionError.UnknownValue({})".format(str(self))
    _UniffiTempRawTransactionError.UnknownValue = UnknownValue # type: ignore

RawTransactionError = _UniffiTempRawTransactionError # type: ignore
del _UniffiTempRawTransactionError


class _UniffiConverterTypeRawTransactionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RawTransactionError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return RawTransactionError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return RawTransactionError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return RawTransactionError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return RawTransactionError.Statusdefault(
            )
        if variant == 6:
            return RawTransactionError.DefaultResponse(
            )
        if variant == 7:
            return RawTransactionError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, RawTransactionError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, RawTransactionError.Statusdefault):
            return
        if isinstance(value, RawTransactionError.DefaultResponse):
            return
        if isinstance(value, RawTransactionError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, RawTransactionError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, RawTransactionError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, RawTransactionError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, RawTransactionError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# SetBlockTimeStampOffsetError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SetBlockTimeStampOffsetError(Exception):
    """
    struct for typed errors of method [`set_block_time_stamp_offset`]
    """

    pass

_UniffiTempSetBlockTimeStampOffsetError = SetBlockTimeStampOffsetError

class SetBlockTimeStampOffsetError:  # type: ignore
    """
    struct for typed errors of method [`set_block_time_stamp_offset`]
    """

    class Status400(_UniffiTempSetBlockTimeStampOffsetError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetBlockTimeStampOffsetError.Status400({})".format(str(self))
    _UniffiTempSetBlockTimeStampOffsetError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempSetBlockTimeStampOffsetError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetBlockTimeStampOffsetError.Status401({})".format(str(self))
    _UniffiTempSetBlockTimeStampOffsetError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempSetBlockTimeStampOffsetError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetBlockTimeStampOffsetError.Status500({})".format(str(self))
    _UniffiTempSetBlockTimeStampOffsetError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempSetBlockTimeStampOffsetError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SetBlockTimeStampOffsetError.Statusdefault({})".format(str(self))
    _UniffiTempSetBlockTimeStampOffsetError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempSetBlockTimeStampOffsetError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SetBlockTimeStampOffsetError.DefaultResponse({})".format(str(self))
    _UniffiTempSetBlockTimeStampOffsetError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempSetBlockTimeStampOffsetError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetBlockTimeStampOffsetError.UnknownValue({})".format(str(self))
    _UniffiTempSetBlockTimeStampOffsetError.UnknownValue = UnknownValue # type: ignore

SetBlockTimeStampOffsetError = _UniffiTempSetBlockTimeStampOffsetError # type: ignore
del _UniffiTempSetBlockTimeStampOffsetError


class _UniffiConverterTypeSetBlockTimeStampOffsetError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SetBlockTimeStampOffsetError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return SetBlockTimeStampOffsetError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return SetBlockTimeStampOffsetError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return SetBlockTimeStampOffsetError.Statusdefault(
            )
        if variant == 5:
            return SetBlockTimeStampOffsetError.DefaultResponse(
            )
        if variant == 6:
            return SetBlockTimeStampOffsetError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SetBlockTimeStampOffsetError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetBlockTimeStampOffsetError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetBlockTimeStampOffsetError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetBlockTimeStampOffsetError.Statusdefault):
            return
        if isinstance(value, SetBlockTimeStampOffsetError.DefaultResponse):
            return
        if isinstance(value, SetBlockTimeStampOffsetError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SetBlockTimeStampOffsetError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetBlockTimeStampOffsetError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetBlockTimeStampOffsetError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetBlockTimeStampOffsetError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, SetBlockTimeStampOffsetError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, SetBlockTimeStampOffsetError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# SetSyncRoundError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SetSyncRoundError(Exception):
    """
    struct for typed errors of method [`set_sync_round`]
    """

    pass

_UniffiTempSetSyncRoundError = SetSyncRoundError

class SetSyncRoundError:  # type: ignore
    """
    struct for typed errors of method [`set_sync_round`]
    """

    class Status400(_UniffiTempSetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetSyncRoundError.Status400({})".format(str(self))
    _UniffiTempSetSyncRoundError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempSetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetSyncRoundError.Status401({})".format(str(self))
    _UniffiTempSetSyncRoundError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempSetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetSyncRoundError.Status500({})".format(str(self))
    _UniffiTempSetSyncRoundError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempSetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetSyncRoundError.Status503({})".format(str(self))
    _UniffiTempSetSyncRoundError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempSetSyncRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SetSyncRoundError.Statusdefault({})".format(str(self))
    _UniffiTempSetSyncRoundError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempSetSyncRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SetSyncRoundError.DefaultResponse({})".format(str(self))
    _UniffiTempSetSyncRoundError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempSetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SetSyncRoundError.UnknownValue({})".format(str(self))
    _UniffiTempSetSyncRoundError.UnknownValue = UnknownValue # type: ignore

SetSyncRoundError = _UniffiTempSetSyncRoundError # type: ignore
del _UniffiTempSetSyncRoundError


class _UniffiConverterTypeSetSyncRoundError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SetSyncRoundError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return SetSyncRoundError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return SetSyncRoundError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return SetSyncRoundError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return SetSyncRoundError.Statusdefault(
            )
        if variant == 6:
            return SetSyncRoundError.DefaultResponse(
            )
        if variant == 7:
            return SetSyncRoundError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SetSyncRoundError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetSyncRoundError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetSyncRoundError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetSyncRoundError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SetSyncRoundError.Statusdefault):
            return
        if isinstance(value, SetSyncRoundError.DefaultResponse):
            return
        if isinstance(value, SetSyncRoundError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SetSyncRoundError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetSyncRoundError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetSyncRoundError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetSyncRoundError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SetSyncRoundError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, SetSyncRoundError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, SetSyncRoundError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# ShutdownNodeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ShutdownNodeError(Exception):
    """
    struct for typed errors of method [`shutdown_node`]
    """

    pass

_UniffiTempShutdownNodeError = ShutdownNodeError

class ShutdownNodeError:  # type: ignore
    """
    struct for typed errors of method [`shutdown_node`]
    """

    class DefaultResponse(_UniffiTempShutdownNodeError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ShutdownNodeError.DefaultResponse({})".format(str(self))
    _UniffiTempShutdownNodeError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempShutdownNodeError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "ShutdownNodeError.UnknownValue({})".format(str(self))
    _UniffiTempShutdownNodeError.UnknownValue = UnknownValue # type: ignore

ShutdownNodeError = _UniffiTempShutdownNodeError # type: ignore
del _UniffiTempShutdownNodeError


class _UniffiConverterTypeShutdownNodeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ShutdownNodeError.DefaultResponse(
            )
        if variant == 2:
            return ShutdownNodeError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ShutdownNodeError.DefaultResponse):
            return
        if isinstance(value, ShutdownNodeError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ShutdownNodeError.DefaultResponse):
            buf.write_i32(1)
        if isinstance(value, ShutdownNodeError.UnknownValue):
            buf.write_i32(2)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# SimulateTransactionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SimulateTransactionError(Exception):
    """
    struct for typed errors of method [`simulate_transaction`]
    """

    pass

_UniffiTempSimulateTransactionError = SimulateTransactionError

class SimulateTransactionError:  # type: ignore
    """
    struct for typed errors of method [`simulate_transaction`]
    """

    class Status400(_UniffiTempSimulateTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SimulateTransactionError.Status400({})".format(str(self))
    _UniffiTempSimulateTransactionError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempSimulateTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SimulateTransactionError.Status401({})".format(str(self))
    _UniffiTempSimulateTransactionError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempSimulateTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SimulateTransactionError.Status500({})".format(str(self))
    _UniffiTempSimulateTransactionError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempSimulateTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SimulateTransactionError.Status503({})".format(str(self))
    _UniffiTempSimulateTransactionError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempSimulateTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SimulateTransactionError.Statusdefault({})".format(str(self))
    _UniffiTempSimulateTransactionError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempSimulateTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SimulateTransactionError.DefaultResponse({})".format(str(self))
    _UniffiTempSimulateTransactionError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempSimulateTransactionError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SimulateTransactionError.UnknownValue({})".format(str(self))
    _UniffiTempSimulateTransactionError.UnknownValue = UnknownValue # type: ignore

SimulateTransactionError = _UniffiTempSimulateTransactionError # type: ignore
del _UniffiTempSimulateTransactionError


class _UniffiConverterTypeSimulateTransactionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SimulateTransactionError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return SimulateTransactionError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return SimulateTransactionError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return SimulateTransactionError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return SimulateTransactionError.Statusdefault(
            )
        if variant == 6:
            return SimulateTransactionError.DefaultResponse(
            )
        if variant == 7:
            return SimulateTransactionError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SimulateTransactionError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SimulateTransactionError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SimulateTransactionError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SimulateTransactionError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, SimulateTransactionError.Statusdefault):
            return
        if isinstance(value, SimulateTransactionError.DefaultResponse):
            return
        if isinstance(value, SimulateTransactionError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SimulateTransactionError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SimulateTransactionError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SimulateTransactionError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SimulateTransactionError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, SimulateTransactionError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, SimulateTransactionError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, SimulateTransactionError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# StartCatchupError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class StartCatchupError(Exception):
    """
    struct for typed errors of method [`start_catchup`]
    """

    pass

_UniffiTempStartCatchupError = StartCatchupError

class StartCatchupError:  # type: ignore
    """
    struct for typed errors of method [`start_catchup`]
    """

    class Status400(_UniffiTempStartCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StartCatchupError.Status400({})".format(str(self))
    _UniffiTempStartCatchupError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempStartCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StartCatchupError.Status401({})".format(str(self))
    _UniffiTempStartCatchupError.Status401 = Status401 # type: ignore
    class Status408(_UniffiTempStartCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StartCatchupError.Status408({})".format(str(self))
    _UniffiTempStartCatchupError.Status408 = Status408 # type: ignore
    class Status500(_UniffiTempStartCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StartCatchupError.Status500({})".format(str(self))
    _UniffiTempStartCatchupError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempStartCatchupError):
        def __init__(self):
            pass

        def __repr__(self):
            return "StartCatchupError.Statusdefault({})".format(str(self))
    _UniffiTempStartCatchupError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempStartCatchupError):
        def __init__(self):
            pass

        def __repr__(self):
            return "StartCatchupError.DefaultResponse({})".format(str(self))
    _UniffiTempStartCatchupError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempStartCatchupError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "StartCatchupError.UnknownValue({})".format(str(self))
    _UniffiTempStartCatchupError.UnknownValue = UnknownValue # type: ignore

StartCatchupError = _UniffiTempStartCatchupError # type: ignore
del _UniffiTempStartCatchupError


class _UniffiConverterTypeStartCatchupError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return StartCatchupError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return StartCatchupError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return StartCatchupError.Status408(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return StartCatchupError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return StartCatchupError.Statusdefault(
            )
        if variant == 6:
            return StartCatchupError.DefaultResponse(
            )
        if variant == 7:
            return StartCatchupError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, StartCatchupError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, StartCatchupError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, StartCatchupError.Status408):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, StartCatchupError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, StartCatchupError.Statusdefault):
            return
        if isinstance(value, StartCatchupError.DefaultResponse):
            return
        if isinstance(value, StartCatchupError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, StartCatchupError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, StartCatchupError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, StartCatchupError.Status408):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, StartCatchupError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, StartCatchupError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, StartCatchupError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, StartCatchupError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# SwaggerJsonError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SwaggerJsonError(Exception):
    """
    struct for typed errors of method [`swagger_json`]
    """

    pass

_UniffiTempSwaggerJsonError = SwaggerJsonError

class SwaggerJsonError:  # type: ignore
    """
    struct for typed errors of method [`swagger_json`]
    """

    class Statusdefault(_UniffiTempSwaggerJsonError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SwaggerJsonError.Statusdefault({})".format(str(self))
    _UniffiTempSwaggerJsonError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempSwaggerJsonError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SwaggerJsonError.DefaultResponse({})".format(str(self))
    _UniffiTempSwaggerJsonError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempSwaggerJsonError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "SwaggerJsonError.UnknownValue({})".format(str(self))
    _UniffiTempSwaggerJsonError.UnknownValue = UnknownValue # type: ignore

SwaggerJsonError = _UniffiTempSwaggerJsonError # type: ignore
del _UniffiTempSwaggerJsonError


class _UniffiConverterTypeSwaggerJsonError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SwaggerJsonError.Statusdefault(
            )
        if variant == 2:
            return SwaggerJsonError.DefaultResponse(
            )
        if variant == 3:
            return SwaggerJsonError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SwaggerJsonError.Statusdefault):
            return
        if isinstance(value, SwaggerJsonError.DefaultResponse):
            return
        if isinstance(value, SwaggerJsonError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SwaggerJsonError.Statusdefault):
            buf.write_i32(1)
        if isinstance(value, SwaggerJsonError.DefaultResponse):
            buf.write_i32(2)
        if isinstance(value, SwaggerJsonError.UnknownValue):
            buf.write_i32(3)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# TealCompileError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TealCompileError(Exception):
    """
    struct for typed errors of method [`teal_compile`]
    """

    pass

_UniffiTempTealCompileError = TealCompileError

class TealCompileError:  # type: ignore
    """
    struct for typed errors of method [`teal_compile`]
    """

    class Status400(_UniffiTempTealCompileError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealCompileError.Status400({})".format(str(self))
    _UniffiTempTealCompileError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempTealCompileError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealCompileError.Status401({})".format(str(self))
    _UniffiTempTealCompileError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempTealCompileError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealCompileError.Status404({})".format(str(self))
    _UniffiTempTealCompileError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempTealCompileError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealCompileError.Status500({})".format(str(self))
    _UniffiTempTealCompileError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempTealCompileError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealCompileError.Statusdefault({})".format(str(self))
    _UniffiTempTealCompileError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempTealCompileError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealCompileError.DefaultResponse({})".format(str(self))
    _UniffiTempTealCompileError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempTealCompileError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealCompileError.UnknownValue({})".format(str(self))
    _UniffiTempTealCompileError.UnknownValue = UnknownValue # type: ignore

TealCompileError = _UniffiTempTealCompileError # type: ignore
del _UniffiTempTealCompileError


class _UniffiConverterTypeTealCompileError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TealCompileError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return TealCompileError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return TealCompileError.Status404(
            )
        if variant == 4:
            return TealCompileError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return TealCompileError.Statusdefault(
            )
        if variant == 6:
            return TealCompileError.DefaultResponse(
            )
        if variant == 7:
            return TealCompileError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TealCompileError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealCompileError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealCompileError.Status404):
            return
        if isinstance(value, TealCompileError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealCompileError.Statusdefault):
            return
        if isinstance(value, TealCompileError.DefaultResponse):
            return
        if isinstance(value, TealCompileError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TealCompileError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealCompileError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealCompileError.Status404):
            buf.write_i32(3)
        if isinstance(value, TealCompileError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealCompileError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, TealCompileError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, TealCompileError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# TealDisassembleError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TealDisassembleError(Exception):
    """
    struct for typed errors of method [`teal_disassemble`]
    """

    pass

_UniffiTempTealDisassembleError = TealDisassembleError

class TealDisassembleError:  # type: ignore
    """
    struct for typed errors of method [`teal_disassemble`]
    """

    class Status400(_UniffiTempTealDisassembleError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDisassembleError.Status400({})".format(str(self))
    _UniffiTempTealDisassembleError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempTealDisassembleError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDisassembleError.Status401({})".format(str(self))
    _UniffiTempTealDisassembleError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempTealDisassembleError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealDisassembleError.Status404({})".format(str(self))
    _UniffiTempTealDisassembleError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempTealDisassembleError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDisassembleError.Status500({})".format(str(self))
    _UniffiTempTealDisassembleError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempTealDisassembleError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealDisassembleError.Statusdefault({})".format(str(self))
    _UniffiTempTealDisassembleError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempTealDisassembleError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealDisassembleError.DefaultResponse({})".format(str(self))
    _UniffiTempTealDisassembleError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempTealDisassembleError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDisassembleError.UnknownValue({})".format(str(self))
    _UniffiTempTealDisassembleError.UnknownValue = UnknownValue # type: ignore

TealDisassembleError = _UniffiTempTealDisassembleError # type: ignore
del _UniffiTempTealDisassembleError


class _UniffiConverterTypeTealDisassembleError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TealDisassembleError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return TealDisassembleError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return TealDisassembleError.Status404(
            )
        if variant == 4:
            return TealDisassembleError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return TealDisassembleError.Statusdefault(
            )
        if variant == 6:
            return TealDisassembleError.DefaultResponse(
            )
        if variant == 7:
            return TealDisassembleError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TealDisassembleError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealDisassembleError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealDisassembleError.Status404):
            return
        if isinstance(value, TealDisassembleError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealDisassembleError.Statusdefault):
            return
        if isinstance(value, TealDisassembleError.DefaultResponse):
            return
        if isinstance(value, TealDisassembleError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TealDisassembleError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealDisassembleError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealDisassembleError.Status404):
            buf.write_i32(3)
        if isinstance(value, TealDisassembleError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealDisassembleError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, TealDisassembleError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, TealDisassembleError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# TealDryrunError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TealDryrunError(Exception):
    """
    struct for typed errors of method [`teal_dryrun`]
    """

    pass

_UniffiTempTealDryrunError = TealDryrunError

class TealDryrunError:  # type: ignore
    """
    struct for typed errors of method [`teal_dryrun`]
    """

    class Status400(_UniffiTempTealDryrunError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDryrunError.Status400({})".format(str(self))
    _UniffiTempTealDryrunError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempTealDryrunError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDryrunError.Status401({})".format(str(self))
    _UniffiTempTealDryrunError.Status401 = Status401 # type: ignore
    class Status404(_UniffiTempTealDryrunError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealDryrunError.Status404({})".format(str(self))
    _UniffiTempTealDryrunError.Status404 = Status404 # type: ignore
    class Status500(_UniffiTempTealDryrunError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDryrunError.Status500({})".format(str(self))
    _UniffiTempTealDryrunError.Status500 = Status500 # type: ignore
    class Statusdefault(_UniffiTempTealDryrunError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealDryrunError.Statusdefault({})".format(str(self))
    _UniffiTempTealDryrunError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempTealDryrunError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TealDryrunError.DefaultResponse({})".format(str(self))
    _UniffiTempTealDryrunError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempTealDryrunError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TealDryrunError.UnknownValue({})".format(str(self))
    _UniffiTempTealDryrunError.UnknownValue = UnknownValue # type: ignore

TealDryrunError = _UniffiTempTealDryrunError # type: ignore
del _UniffiTempTealDryrunError


class _UniffiConverterTypeTealDryrunError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TealDryrunError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return TealDryrunError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return TealDryrunError.Status404(
            )
        if variant == 4:
            return TealDryrunError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return TealDryrunError.Statusdefault(
            )
        if variant == 6:
            return TealDryrunError.DefaultResponse(
            )
        if variant == 7:
            return TealDryrunError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TealDryrunError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealDryrunError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealDryrunError.Status404):
            return
        if isinstance(value, TealDryrunError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TealDryrunError.Statusdefault):
            return
        if isinstance(value, TealDryrunError.DefaultResponse):
            return
        if isinstance(value, TealDryrunError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TealDryrunError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealDryrunError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealDryrunError.Status404):
            buf.write_i32(3)
        if isinstance(value, TealDryrunError.Status500):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TealDryrunError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, TealDryrunError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, TealDryrunError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# TransactionParamsError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TransactionParamsError(Exception):
    """
    struct for typed errors of method [`transaction_params`]
    """

    pass

_UniffiTempTransactionParamsError = TransactionParamsError

class TransactionParamsError:  # type: ignore
    """
    struct for typed errors of method [`transaction_params`]
    """

    class Status401(_UniffiTempTransactionParamsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TransactionParamsError.Status401({})".format(str(self))
    _UniffiTempTransactionParamsError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempTransactionParamsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TransactionParamsError.Status500({})".format(str(self))
    _UniffiTempTransactionParamsError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempTransactionParamsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TransactionParamsError.Status503({})".format(str(self))
    _UniffiTempTransactionParamsError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempTransactionParamsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionParamsError.Statusdefault({})".format(str(self))
    _UniffiTempTransactionParamsError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempTransactionParamsError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionParamsError.DefaultResponse({})".format(str(self))
    _UniffiTempTransactionParamsError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempTransactionParamsError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "TransactionParamsError.UnknownValue({})".format(str(self))
    _UniffiTempTransactionParamsError.UnknownValue = UnknownValue # type: ignore

TransactionParamsError = _UniffiTempTransactionParamsError # type: ignore
del _UniffiTempTransactionParamsError


class _UniffiConverterTypeTransactionParamsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionParamsError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return TransactionParamsError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return TransactionParamsError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return TransactionParamsError.Statusdefault(
            )
        if variant == 5:
            return TransactionParamsError.DefaultResponse(
            )
        if variant == 6:
            return TransactionParamsError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TransactionParamsError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TransactionParamsError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TransactionParamsError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, TransactionParamsError.Statusdefault):
            return
        if isinstance(value, TransactionParamsError.DefaultResponse):
            return
        if isinstance(value, TransactionParamsError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TransactionParamsError.Status401):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TransactionParamsError.Status500):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TransactionParamsError.Status503):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, TransactionParamsError.Statusdefault):
            buf.write_i32(4)
        if isinstance(value, TransactionParamsError.DefaultResponse):
            buf.write_i32(5)
        if isinstance(value, TransactionParamsError.UnknownValue):
            buf.write_i32(6)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# UnsetSyncRoundError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UnsetSyncRoundError(Exception):
    """
    struct for typed errors of method [`unset_sync_round`]
    """

    pass

_UniffiTempUnsetSyncRoundError = UnsetSyncRoundError

class UnsetSyncRoundError:  # type: ignore
    """
    struct for typed errors of method [`unset_sync_round`]
    """

    class Status400(_UniffiTempUnsetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UnsetSyncRoundError.Status400({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempUnsetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UnsetSyncRoundError.Status401({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempUnsetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UnsetSyncRoundError.Status500({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempUnsetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UnsetSyncRoundError.Status503({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempUnsetSyncRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "UnsetSyncRoundError.Statusdefault({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempUnsetSyncRoundError):
        def __init__(self):
            pass

        def __repr__(self):
            return "UnsetSyncRoundError.DefaultResponse({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempUnsetSyncRoundError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "UnsetSyncRoundError.UnknownValue({})".format(str(self))
    _UniffiTempUnsetSyncRoundError.UnknownValue = UnknownValue # type: ignore

UnsetSyncRoundError = _UniffiTempUnsetSyncRoundError # type: ignore
del _UniffiTempUnsetSyncRoundError


class _UniffiConverterTypeUnsetSyncRoundError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UnsetSyncRoundError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return UnsetSyncRoundError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return UnsetSyncRoundError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return UnsetSyncRoundError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return UnsetSyncRoundError.Statusdefault(
            )
        if variant == 6:
            return UnsetSyncRoundError.DefaultResponse(
            )
        if variant == 7:
            return UnsetSyncRoundError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, UnsetSyncRoundError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, UnsetSyncRoundError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, UnsetSyncRoundError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, UnsetSyncRoundError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, UnsetSyncRoundError.Statusdefault):
            return
        if isinstance(value, UnsetSyncRoundError.DefaultResponse):
            return
        if isinstance(value, UnsetSyncRoundError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, UnsetSyncRoundError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, UnsetSyncRoundError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, UnsetSyncRoundError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, UnsetSyncRoundError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, UnsetSyncRoundError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, UnsetSyncRoundError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, UnsetSyncRoundError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)


# WaitForBlockError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class WaitForBlockError(Exception):
    """
    struct for typed errors of method [`wait_for_block`]
    """

    pass

_UniffiTempWaitForBlockError = WaitForBlockError

class WaitForBlockError:  # type: ignore
    """
    struct for typed errors of method [`wait_for_block`]
    """

    class Status400(_UniffiTempWaitForBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "WaitForBlockError.Status400({})".format(str(self))
    _UniffiTempWaitForBlockError.Status400 = Status400 # type: ignore
    class Status401(_UniffiTempWaitForBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "WaitForBlockError.Status401({})".format(str(self))
    _UniffiTempWaitForBlockError.Status401 = Status401 # type: ignore
    class Status500(_UniffiTempWaitForBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "WaitForBlockError.Status500({})".format(str(self))
    _UniffiTempWaitForBlockError.Status500 = Status500 # type: ignore
    class Status503(_UniffiTempWaitForBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ErrorResponse):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ErrorResponse', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "WaitForBlockError.Status503({})".format(str(self))
    _UniffiTempWaitForBlockError.Status503 = Status503 # type: ignore
    class Statusdefault(_UniffiTempWaitForBlockError):
        def __init__(self):
            pass

        def __repr__(self):
            return "WaitForBlockError.Statusdefault({})".format(str(self))
    _UniffiTempWaitForBlockError.Statusdefault = Statusdefault # type: ignore
    class DefaultResponse(_UniffiTempWaitForBlockError):
        def __init__(self):
            pass

        def __repr__(self):
            return "WaitForBlockError.DefaultResponse({})".format(str(self))
    _UniffiTempWaitForBlockError.DefaultResponse = DefaultResponse # type: ignore
    class UnknownValue(_UniffiTempWaitForBlockError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], UnknownJsonValue):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'UnknownJsonValue', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "WaitForBlockError.UnknownValue({})".format(str(self))
    _UniffiTempWaitForBlockError.UnknownValue = UnknownValue # type: ignore

WaitForBlockError = _UniffiTempWaitForBlockError # type: ignore
del _UniffiTempWaitForBlockError


class _UniffiConverterTypeWaitForBlockError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WaitForBlockError.Status400(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 2:
            return WaitForBlockError.Status401(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 3:
            return WaitForBlockError.Status500(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 4:
            return WaitForBlockError.Status503(
                _UniffiConverterTypeErrorResponse.read(buf),
            )
        if variant == 5:
            return WaitForBlockError.Statusdefault(
            )
        if variant == 6:
            return WaitForBlockError.DefaultResponse(
            )
        if variant == 7:
            return WaitForBlockError.UnknownValue(
                _UniffiConverterTypeUnknownJsonValue.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, WaitForBlockError.Status400):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, WaitForBlockError.Status401):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, WaitForBlockError.Status500):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, WaitForBlockError.Status503):
            _UniffiConverterTypeErrorResponse.check_lower(value._values[0])
            return
        if isinstance(value, WaitForBlockError.Statusdefault):
            return
        if isinstance(value, WaitForBlockError.DefaultResponse):
            return
        if isinstance(value, WaitForBlockError.UnknownValue):
            _UniffiConverterTypeUnknownJsonValue.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, WaitForBlockError.Status400):
            buf.write_i32(1)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, WaitForBlockError.Status401):
            buf.write_i32(2)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, WaitForBlockError.Status500):
            buf.write_i32(3)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, WaitForBlockError.Status503):
            buf.write_i32(4)
            _UniffiConverterTypeErrorResponse.write(value._values[0], buf)
        if isinstance(value, WaitForBlockError.Statusdefault):
            buf.write_i32(5)
        if isinstance(value, WaitForBlockError.DefaultResponse):
            buf.write_i32(6)
        if isinstance(value, WaitForBlockError.UnknownValue):
            buf.write_i32(7)
            _UniffiConverterTypeUnknownJsonValue.write(value._values[0], buf)



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAccountParticipation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAccountParticipation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAccountParticipation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAccountParticipation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeApplicationKvStorage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeApplicationKvStorage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeApplicationKvStorage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeApplicationKvStorage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeApplicationLocalState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeApplicationLocalState.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeApplicationLocalState.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeApplicationLocalState.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeApplicationParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeApplicationParams.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeApplicationParams.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeApplicationParams.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeApplicationStateSchema(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeApplicationStateSchema.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeApplicationStateSchema.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeApplicationStateSchema.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAssetHolding(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAssetHolding.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAssetHolding.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAssetHolding.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAssetParams(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAssetParams.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAssetParams.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAssetParams.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAvmValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAvmValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAvmValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAvmValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDryrunRequest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDryrunRequest.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDryrunRequest.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDryrunRequest.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSimulateInitialStates(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSimulateInitialStates.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSimulateInitialStates.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSimulateInitialStates.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSimulateTraceConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSimulateTraceConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSimulateTraceConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSimulateTraceConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSimulateUnnamedResourcesAccessed(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSimulateUnnamedResourcesAccessed.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSimulateUnnamedResourcesAccessed.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSimulateUnnamedResourcesAccessed.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSimulationEvalOverrides(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSimulationEvalOverrides.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSimulationEvalOverrides.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSimulationEvalOverrides.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSimulationTransactionExecTrace(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSimulationTransactionExecTrace.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSimulationTransactionExecTrace.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSimulationTransactionExecTrace.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeExclude(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeExclude.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeExclude.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeExclude.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFormat(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFormat.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFormat.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFormat.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeHashtype(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeHashtype.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeHashtype.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeHashtype.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAccountAssetHolding(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeAccountAssetHolding.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAccountAssetHolding.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAccountAssetHolding.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAccountStateDelta(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeAccountStateDelta.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAccountStateDelta.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAccountStateDelta.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeApplication(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeApplication.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeApplication.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeApplication.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeApplicationInitialStates(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeApplicationInitialStates.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeApplicationInitialStates.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeApplicationInitialStates.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeApplicationKvStorage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeApplicationKvStorage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeApplicationKvStorage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeApplicationKvStorage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeApplicationLocalReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeApplicationLocalReference.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeApplicationLocalReference.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeApplicationLocalReference.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeApplicationLocalState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeApplicationLocalState.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeApplicationLocalState.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeApplicationLocalState.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeApplicationStateOperation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeApplicationStateOperation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeApplicationStateOperation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeApplicationStateOperation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAsset(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeAsset.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAsset.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAsset.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAssetHolding(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeAssetHolding.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAssetHolding.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAssetHolding.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAssetHoldingReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeAssetHoldingReference.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAssetHoldingReference.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAssetHoldingReference.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeAvmValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeAvmValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeAvmValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeAvmValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeBoxReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeBoxReference.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeBoxReference.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeBoxReference.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeDryrunState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeDryrunState.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeDryrunState.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeDryrunState.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypePendingTransactionResponse(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypePendingTransactionResponse.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypePendingTransactionResponse.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypePendingTransactionResponse.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeScratchChange(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeScratchChange.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeScratchChange.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeScratchChange.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeSimulationOpcodeTraceUnit(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeSimulationOpcodeTraceUnit.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeSimulationOpcodeTraceUnit.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeSimulationOpcodeTraceUnit.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeSimulationTransactionExecTrace(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeSimulationTransactionExecTrace.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeSimulationTransactionExecTrace.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeSimulationTransactionExecTrace.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeTealValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeTealValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeTealValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeTealValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeStateDelta(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeStateDelta.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeStateDelta.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeStateDelta.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTealKeyValueStore(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTealKeyValueStore.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTealKeyValueStore.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTealKeyValueStore.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeUnknownJsonValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeUnknownJsonValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeUnknownJsonValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeUnknownJsonValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBytes.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAccount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAccount.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAccount.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAccount.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAccountAssetHolding(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAccountAssetHolding.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAccountAssetHolding.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAccountAssetHolding.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAccountStateDelta(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAccountStateDelta.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAccountStateDelta.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAccountStateDelta.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAppCallLogs(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAppCallLogs.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAppCallLogs.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAppCallLogs.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeApplication(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeApplication.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeApplication.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeApplication.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeApplicationInitialStates(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeApplicationInitialStates.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeApplicationInitialStates.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeApplicationInitialStates.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeApplicationKvStorage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeApplicationKvStorage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeApplicationKvStorage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeApplicationKvStorage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeApplicationLocalReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeApplicationLocalReference.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeApplicationLocalReference.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeApplicationLocalReference.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeApplicationLocalState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeApplicationLocalState.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeApplicationLocalState.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeApplicationLocalState.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeApplicationStateOperation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeApplicationStateOperation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeApplicationStateOperation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeApplicationStateOperation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAsset(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAsset.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAsset.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAsset.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAssetHolding(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAssetHolding.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAssetHolding.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAssetHolding.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAssetHoldingReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAssetHoldingReference.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAssetHoldingReference.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAssetHoldingReference.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAvmKeyValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAvmKeyValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAvmKeyValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAvmKeyValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAvmValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAvmValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAvmValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAvmValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBoxDescriptor(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBoxDescriptor.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBoxDescriptor.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBoxDescriptor.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBoxReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBoxReference.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBoxReference.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBoxReference.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDryrunSource(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDryrunSource.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDryrunSource.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDryrunSource.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDryrunState(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDryrunState.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDryrunState.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDryrunState.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDryrunTxnResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDryrunTxnResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDryrunTxnResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDryrunTxnResult.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEvalDeltaKeyValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEvalDeltaKeyValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEvalDeltaKeyValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEvalDeltaKeyValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeGenesisAllocation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeGenesisAllocation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeGenesisAllocation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeGenesisAllocation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLedgerStateDeltaForTransactionGroup(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLedgerStateDeltaForTransactionGroup.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLedgerStateDeltaForTransactionGroup.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLedgerStateDeltaForTransactionGroup.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeParticipationKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeParticipationKey.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeParticipationKey.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeParticipationKey.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePendingTransactionResponse(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePendingTransactionResponse.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePendingTransactionResponse.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePendingTransactionResponse.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeScratchChange(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeScratchChange.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeScratchChange.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeScratchChange.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSimulateRequestTransactionGroup(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSimulateRequestTransactionGroup.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSimulateRequestTransactionGroup.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSimulateRequestTransactionGroup.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSimulateTransactionGroupResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSimulateTransactionGroupResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSimulateTransactionGroupResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSimulateTransactionGroupResult.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSimulateTransactionResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSimulateTransactionResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSimulateTransactionResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSimulateTransactionResult.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSimulationOpcodeTraceUnit(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSimulationOpcodeTraceUnit.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSimulationOpcodeTraceUnit.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSimulationOpcodeTraceUnit.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSimulationTransactionExecTrace(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSimulationTransactionExecTrace.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSimulationTransactionExecTrace.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSimulationTransactionExecTrace.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTealKeyValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTealKeyValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTealKeyValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTealKeyValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTealValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTealValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTealValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTealValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSignedTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSignedTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSignedTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSignedTransaction.read(buf) for i in range(count)
        ]


class _UniffiConverterTypeStateDelta:
    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeEvalDeltaKeyValue.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterSequenceTypeEvalDeltaKeyValue.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterSequenceTypeEvalDeltaKeyValue.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterSequenceTypeEvalDeltaKeyValue.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterSequenceTypeEvalDeltaKeyValue.lower(value)


class _UniffiConverterTypeTealKeyValueStore:
    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeTealKeyValue.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterSequenceTypeTealKeyValue.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterSequenceTypeTealKeyValue.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterSequenceTypeTealKeyValue.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterSequenceTypeTealKeyValue.lower(value)


class _UniffiConverterTypeUnknownJsonValue:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)

# objects.
class AlgodClientTraitProtocol(typing.Protocol):
    def health_check(self, ):
        """
        Returns OK if healthy.
        """

        raise NotImplementedError
    def get_ready(self, ):
        """
        Returns OK if healthy and fully caught up.
        """

        raise NotImplementedError
    def metrics(self, ):
        """
        Return metrics about algod functioning.
        """

        raise NotImplementedError
    def get_genesis(self, ):
        """
        Gets the genesis information.
        """

        raise NotImplementedError
    def swagger_json(self, ):
        """
        Gets the current swagger spec.
        """

        raise NotImplementedError
    def get_version(self, ):
        """
        Retrieves the supported API versions, binary build versions, and genesis information.
        """

        raise NotImplementedError
    def get_debug_settings_prof(self, ):
        """
        Retrieves the current settings for blocking and mutex profiles
        """

        raise NotImplementedError
    def put_debug_settings_prof(self, ):
        """
        Enables blocking and mutex profiles, and returns the old settings
        """

        raise NotImplementedError
    def get_config(self, ):
        """
        Gets the merged config file.
        """

        raise NotImplementedError
    def account_information(self, address: "str",exclude: "typing.Optional[Exclude]",format: "typing.Optional[Format]"):
        """
        Get account information.
        """

        raise NotImplementedError
    def account_asset_information(self, address: "str",asset_id: "int",format: "typing.Optional[Format]"):
        """
        Get account information about a given asset.
        """

        raise NotImplementedError
    def account_assets_information(self, address: "str",limit: "typing.Optional[int]",next: "typing.Optional[str]"):
        """
        Get a list of assets held by an account, inclusive of asset params.
        """

        raise NotImplementedError
    def account_application_information(self, address: "str",application_id: "int",format: "typing.Optional[Format]"):
        """
        Get account information about a given app.
        """

        raise NotImplementedError
    def get_pending_transactions_by_address(self, address: "str",max: "typing.Optional[int]",format: "typing.Optional[Format]"):
        """
        Get a list of unconfirmed transactions currently in the transaction pool by address.
        """

        raise NotImplementedError
    def get_block(self, round: "int",header_only: "typing.Optional[bool]",format: "typing.Optional[Format]"):
        """
        Get the block for the given round.
        """

        raise NotImplementedError
    def get_block_txids(self, round: "int"):
        """
        Get the top level transaction IDs for the block on the given round.
        """

        raise NotImplementedError
    def get_block_hash(self, round: "int"):
        """
        Get the block hash for the block on the given round.
        """

        raise NotImplementedError
    def get_transaction_proof(self, round: "int",txid: "str",hashtype: "typing.Optional[Hashtype]",format: "typing.Optional[Format]"):
        """
        Get a proof for a transaction in a block.
        """

        raise NotImplementedError
    def get_block_logs(self, round: "int"):
        """
        Get all of the logs from outer and inner app calls in the given round
        """

        raise NotImplementedError
    def get_supply(self, ):
        """
        Get the current supply reported by the ledger.
        """

        raise NotImplementedError
    def get_participation_keys(self, ):
        """
        Return a list of participation keys
        """

        raise NotImplementedError
    def add_participation_key(self, request: "bytes"):
        """
        Add a participation key to the node
        """

        raise NotImplementedError
    def generate_participation_keys(self, address: "str",dilution: "typing.Optional[int]",first: "int",last: "int"):
        """
        Generate and install participation keys to the node.
        """

        raise NotImplementedError
    def get_participation_key_by_id(self, participation_id: "str"):
        """
        Get participation key info given a participation ID
        """

        raise NotImplementedError
    def append_keys(self, request: "bytes",participation_id: "str"):
        """
        Append state proof keys to a participation key
        """

        raise NotImplementedError
    def delete_participation_key_by_id(self, participation_id: "str"):
        """
        Delete a given participation key by ID
        """

        raise NotImplementedError
    def shutdown_node(self, timeout: "typing.Optional[int]"):
        """
        Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
        """

        raise NotImplementedError
    def get_status(self, ):
        """
        Gets the current node status.
        """

        raise NotImplementedError
    def wait_for_block(self, round: "int"):
        """
        Gets the node status after waiting for a round after the given round.
        """

        raise NotImplementedError
    def raw_transaction(self, request: "bytes"):
        """
        Broadcasts a raw transaction or transaction group to the network.
        """

        raise NotImplementedError
    def raw_transaction_async(self, request: "bytes"):
        """
        Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
        """

        raise NotImplementedError
    def simulate_transaction(self, request: "SimulateRequest",format: "typing.Optional[Format]"):
        """
        Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        """

        raise NotImplementedError
    def transaction_params(self, ):
        """
        Get parameters for constructing a new transaction
        """

        raise NotImplementedError
    def get_pending_transactions(self, max: "typing.Optional[int]",format: "typing.Optional[Format]"):
        """
        Get a list of unconfirmed transactions currently in the transaction pool.
        """

        raise NotImplementedError
    def pending_transaction_information(self, txid: "str",format: "typing.Optional[Format]"):
        """
        Get a specific pending transaction.
        """

        raise NotImplementedError
    def get_ledger_state_delta(self, round: "int",format: "typing.Optional[Format]"):
        """
        Get a LedgerStateDelta object for a given round
        """

        raise NotImplementedError
    def get_transaction_group_ledger_state_deltas_for_round(self, round: "int",format: "typing.Optional[Format]"):
        """
        Get LedgerStateDelta objects for all transaction groups in a given round
        """

        raise NotImplementedError
    def get_ledger_state_delta_for_transaction_group(self, id: "str",format: "typing.Optional[Format]"):
        """
        Get a LedgerStateDelta object for a given transaction group
        """

        raise NotImplementedError
    def get_state_proof(self, round: "int"):
        """
        Get a state proof that covers a given round
        """

        raise NotImplementedError
    def get_light_block_header_proof(self, round: "int"):
        """
        Gets a proof for a given light block header inside a state proof commitment
        """

        raise NotImplementedError
    def get_application_by_id(self, application_id: "int"):
        """
        Get application information.
        """

        raise NotImplementedError
    def get_application_boxes(self, application_id: "int",max: "typing.Optional[int]"):
        """
        Get all box names for a given application.
        """

        raise NotImplementedError
    def get_application_box_by_name(self, application_id: "int",name: "str"):
        """
        Get box information for a given application.
        """

        raise NotImplementedError
    def get_asset_by_id(self, asset_id: "int"):
        """
        Get asset information.
        """

        raise NotImplementedError
    def get_sync_round(self, ):
        """
        Returns the minimum sync round the ledger is keeping in cache.
        """

        raise NotImplementedError
    def unset_sync_round(self, ):
        """
        Removes minimum sync round restriction from the ledger.
        """

        raise NotImplementedError
    def set_sync_round(self, round: "int"):
        """
        Given a round, tells the ledger to keep that round in its cache.
        """

        raise NotImplementedError
    def teal_compile(self, request: "bytes",sourcemap: "typing.Optional[bool]"):
        """
        Compile TEAL source code to binary, produce its hash
        """

        raise NotImplementedError
    def teal_disassemble(self, request: "str"):
        """
        Disassemble program bytes into the TEAL source code.
        """

        raise NotImplementedError
    def start_catchup(self, catchpoint: "str",min: "typing.Optional[int]"):
        """
        Starts a catchpoint catchup.
        """

        raise NotImplementedError
    def abort_catchup(self, catchpoint: "str"):
        """
        Aborts a catchpoint catchup.
        """

        raise NotImplementedError
    def teal_dryrun(self, request: "typing.Optional[DryrunRequest]"):
        """
        Provide debugging information for a transaction (or group).
        """

        raise NotImplementedError
    def experimental_check(self, ):
        """
        Returns OK if experimental API is enabled.
        """

        raise NotImplementedError
    def get_block_time_stamp_offset(self, ):
        """
        Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
        """

        raise NotImplementedError
    def set_block_time_stamp_offset(self, offset: "int"):
        """
        Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
        """

        raise NotImplementedError
# AlgodClientTrait is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class AlgodClientTrait():
    def health_check(self, ):
        """
        Returns OK if healthy.
        """

        raise NotImplementedError
    def get_ready(self, ):
        """
        Returns OK if healthy and fully caught up.
        """

        raise NotImplementedError
    def metrics(self, ):
        """
        Return metrics about algod functioning.
        """

        raise NotImplementedError
    def get_genesis(self, ):
        """
        Gets the genesis information.
        """

        raise NotImplementedError
    def swagger_json(self, ):
        """
        Gets the current swagger spec.
        """

        raise NotImplementedError
    def get_version(self, ):
        """
        Retrieves the supported API versions, binary build versions, and genesis information.
        """

        raise NotImplementedError
    def get_debug_settings_prof(self, ):
        """
        Retrieves the current settings for blocking and mutex profiles
        """

        raise NotImplementedError
    def put_debug_settings_prof(self, ):
        """
        Enables blocking and mutex profiles, and returns the old settings
        """

        raise NotImplementedError
    def get_config(self, ):
        """
        Gets the merged config file.
        """

        raise NotImplementedError
    def account_information(self, address: "str",exclude: "typing.Optional[Exclude]",format: "typing.Optional[Format]"):
        """
        Get account information.
        """

        raise NotImplementedError
    def account_asset_information(self, address: "str",asset_id: "int",format: "typing.Optional[Format]"):
        """
        Get account information about a given asset.
        """

        raise NotImplementedError
    def account_assets_information(self, address: "str",limit: "typing.Optional[int]",next: "typing.Optional[str]"):
        """
        Get a list of assets held by an account, inclusive of asset params.
        """

        raise NotImplementedError
    def account_application_information(self, address: "str",application_id: "int",format: "typing.Optional[Format]"):
        """
        Get account information about a given app.
        """

        raise NotImplementedError
    def get_pending_transactions_by_address(self, address: "str",max: "typing.Optional[int]",format: "typing.Optional[Format]"):
        """
        Get a list of unconfirmed transactions currently in the transaction pool by address.
        """

        raise NotImplementedError
    def get_block(self, round: "int",header_only: "typing.Optional[bool]",format: "typing.Optional[Format]"):
        """
        Get the block for the given round.
        """

        raise NotImplementedError
    def get_block_txids(self, round: "int"):
        """
        Get the top level transaction IDs for the block on the given round.
        """

        raise NotImplementedError
    def get_block_hash(self, round: "int"):
        """
        Get the block hash for the block on the given round.
        """

        raise NotImplementedError
    def get_transaction_proof(self, round: "int",txid: "str",hashtype: "typing.Optional[Hashtype]",format: "typing.Optional[Format]"):
        """
        Get a proof for a transaction in a block.
        """

        raise NotImplementedError
    def get_block_logs(self, round: "int"):
        """
        Get all of the logs from outer and inner app calls in the given round
        """

        raise NotImplementedError
    def get_supply(self, ):
        """
        Get the current supply reported by the ledger.
        """

        raise NotImplementedError
    def get_participation_keys(self, ):
        """
        Return a list of participation keys
        """

        raise NotImplementedError
    def add_participation_key(self, request: "bytes"):
        """
        Add a participation key to the node
        """

        raise NotImplementedError
    def generate_participation_keys(self, address: "str",dilution: "typing.Optional[int]",first: "int",last: "int"):
        """
        Generate and install participation keys to the node.
        """

        raise NotImplementedError
    def get_participation_key_by_id(self, participation_id: "str"):
        """
        Get participation key info given a participation ID
        """

        raise NotImplementedError
    def append_keys(self, request: "bytes",participation_id: "str"):
        """
        Append state proof keys to a participation key
        """

        raise NotImplementedError
    def delete_participation_key_by_id(self, participation_id: "str"):
        """
        Delete a given participation key by ID
        """

        raise NotImplementedError
    def shutdown_node(self, timeout: "typing.Optional[int]"):
        """
        Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
        """

        raise NotImplementedError
    def get_status(self, ):
        """
        Gets the current node status.
        """

        raise NotImplementedError
    def wait_for_block(self, round: "int"):
        """
        Gets the node status after waiting for a round after the given round.
        """

        raise NotImplementedError
    def raw_transaction(self, request: "bytes"):
        """
        Broadcasts a raw transaction or transaction group to the network.
        """

        raise NotImplementedError
    def raw_transaction_async(self, request: "bytes"):
        """
        Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
        """

        raise NotImplementedError
    def simulate_transaction(self, request: "SimulateRequest",format: "typing.Optional[Format]"):
        """
        Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        """

        raise NotImplementedError
    def transaction_params(self, ):
        """
        Get parameters for constructing a new transaction
        """

        raise NotImplementedError
    def get_pending_transactions(self, max: "typing.Optional[int]",format: "typing.Optional[Format]"):
        """
        Get a list of unconfirmed transactions currently in the transaction pool.
        """

        raise NotImplementedError
    def pending_transaction_information(self, txid: "str",format: "typing.Optional[Format]"):
        """
        Get a specific pending transaction.
        """

        raise NotImplementedError
    def get_ledger_state_delta(self, round: "int",format: "typing.Optional[Format]"):
        """
        Get a LedgerStateDelta object for a given round
        """

        raise NotImplementedError
    def get_transaction_group_ledger_state_deltas_for_round(self, round: "int",format: "typing.Optional[Format]"):
        """
        Get LedgerStateDelta objects for all transaction groups in a given round
        """

        raise NotImplementedError
    def get_ledger_state_delta_for_transaction_group(self, id: "str",format: "typing.Optional[Format]"):
        """
        Get a LedgerStateDelta object for a given transaction group
        """

        raise NotImplementedError
    def get_state_proof(self, round: "int"):
        """
        Get a state proof that covers a given round
        """

        raise NotImplementedError
    def get_light_block_header_proof(self, round: "int"):
        """
        Gets a proof for a given light block header inside a state proof commitment
        """

        raise NotImplementedError
    def get_application_by_id(self, application_id: "int"):
        """
        Get application information.
        """

        raise NotImplementedError
    def get_application_boxes(self, application_id: "int",max: "typing.Optional[int]"):
        """
        Get all box names for a given application.
        """

        raise NotImplementedError
    def get_application_box_by_name(self, application_id: "int",name: "str"):
        """
        Get box information for a given application.
        """

        raise NotImplementedError
    def get_asset_by_id(self, asset_id: "int"):
        """
        Get asset information.
        """

        raise NotImplementedError
    def get_sync_round(self, ):
        """
        Returns the minimum sync round the ledger is keeping in cache.
        """

        raise NotImplementedError
    def unset_sync_round(self, ):
        """
        Removes minimum sync round restriction from the ledger.
        """

        raise NotImplementedError
    def set_sync_round(self, round: "int"):
        """
        Given a round, tells the ledger to keep that round in its cache.
        """

        raise NotImplementedError
    def teal_compile(self, request: "bytes",sourcemap: "typing.Optional[bool]"):
        """
        Compile TEAL source code to binary, produce its hash
        """

        raise NotImplementedError
    def teal_disassemble(self, request: "str"):
        """
        Disassemble program bytes into the TEAL source code.
        """

        raise NotImplementedError
    def start_catchup(self, catchpoint: "str",min: "typing.Optional[int]"):
        """
        Starts a catchpoint catchup.
        """

        raise NotImplementedError
    def abort_catchup(self, catchpoint: "str"):
        """
        Aborts a catchpoint catchup.
        """

        raise NotImplementedError
    def teal_dryrun(self, request: "typing.Optional[DryrunRequest]"):
        """
        Provide debugging information for a transaction (or group).
        """

        raise NotImplementedError
    def experimental_check(self, ):
        """
        Returns OK if experimental API is enabled.
        """

        raise NotImplementedError
    def get_block_time_stamp_offset(self, ):
        """
        Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
        """

        raise NotImplementedError
    def set_block_time_stamp_offset(self, offset: "int"):
        """
        Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
        """

        raise NotImplementedError
# `AlgodClientTraitImpl` is the implementation for a Rust implemented version.
class AlgodClientTraitImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algod_client_ffi_fn_free_algodclienttrait, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algod_client_ffi_fn_clone_algodclienttrait, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def health_check(self, ) -> None:

        """
        Returns OK if healthy.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_health_check(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_ready(self, ) -> None:

        """
        Returns OK if healthy and fully caught up.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ready(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def metrics(self, ) -> None:

        """
        Return metrics about algod functioning.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_metrics(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_genesis(self, ) -> "Genesis":
        """
        Gets the genesis information.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_genesis(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGenesis.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def swagger_json(self, ) -> "str":
        """
        Gets the current swagger spec.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_swagger_json(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_version(self, ) -> "Version":
        """
        Retrieves the supported API versions, binary build versions, and genesis information.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_version(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVersion.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_debug_settings_prof(self, ) -> "DebugSettingsProf":
        """
        Retrieves the current settings for blocking and mutex profiles
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_debug_settings_prof(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDebugSettingsProf.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def put_debug_settings_prof(self, ) -> "DebugSettingsProf":
        """
        Enables blocking and mutex profiles, and returns the old settings
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_put_debug_settings_prof(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDebugSettingsProf.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_config(self, ) -> "str":
        """
        Gets the merged config file.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_config(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_information(self, address: "str",exclude: "typing.Optional[Exclude]",format: "typing.Optional[Format]") -> "Account":
        """
        Get account information.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalTypeExclude.check_lower(exclude)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalTypeExclude.lower(exclude),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccount.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_asset_information(self, address: "str",asset_id: "int",format: "typing.Optional[Format]") -> "AccountAssetInformation":
        """
        Get account information about a given asset.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(asset_id)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_asset_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterUInt64.lower(asset_id),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountAssetInformation.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_assets_information(self, address: "str",limit: "typing.Optional[int]",next: "typing.Optional[str]") -> "AccountAssetsInformation":
        """
        Get a list of assets held by an account, inclusive of asset params.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalUInt64.check_lower(limit)
        
        _UniffiConverterOptionalString.check_lower(next)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_assets_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalUInt64.lower(limit),
        _UniffiConverterOptionalString.lower(next)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountAssetsInformation.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_application_information(self, address: "str",application_id: "int",format: "typing.Optional[Format]") -> "AccountApplicationInformation":
        """
        Get account information about a given app.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(application_id)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_account_application_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterUInt64.lower(application_id),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountApplicationInformation.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_pending_transactions_by_address(self, address: "str",max: "typing.Optional[int]",format: "typing.Optional[Format]") -> "GetPendingTransactionsByAddress":
        """
        Get a list of unconfirmed transactions currently in the transaction pool by address.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalUInt64.check_lower(max)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_pending_transactions_by_address(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalUInt64.lower(max),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetPendingTransactionsByAddress.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block(self, round: "int",header_only: "typing.Optional[bool]",format: "typing.Optional[Format]") -> "GetBlock":
        """
        Get the block for the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalBool.check_lower(header_only)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalBool.lower(header_only),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlock.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_txids(self, round: "int") -> "GetBlockTxids":
        """
        Get the top level transaction IDs for the block on the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_txids(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockTxids.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_hash(self, round: "int") -> "GetBlockHash":
        """
        Get the block hash for the block on the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_hash(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockHash.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_transaction_proof(self, round: "int",txid: "str",hashtype: "typing.Optional[Hashtype]",format: "typing.Optional[Format]") -> "TransactionProof":
        """
        Get a proof for a transaction in a block.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterOptionalTypeHashtype.check_lower(hashtype)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_transaction_proof(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterString.lower(txid),
        _UniffiConverterOptionalTypeHashtype.lower(hashtype),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionProof.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_logs(self, round: "int") -> "GetBlockLogs":
        """
        Get all of the logs from outer and inner app calls in the given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_logs(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockLogs.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_supply(self, ) -> "GetSupply":
        """
        Get the current supply reported by the ledger.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_supply(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetSupply.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_participation_keys(self, ) -> "typing.List[ParticipationKey]":
        """
        Return a list of participation keys
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_participation_keys(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def add_participation_key(self, request: "bytes") -> "AddParticipationKey":
        """
        Add a participation key to the node
        """

        _UniffiConverterBytes.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_add_participation_key(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAddParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def generate_participation_keys(self, address: "str",dilution: "typing.Optional[int]",first: "int",last: "int") -> "str":
        """
        Generate and install participation keys to the node.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalUInt64.check_lower(dilution)
        
        _UniffiConverterUInt64.check_lower(first)
        
        _UniffiConverterUInt64.check_lower(last)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_generate_participation_keys(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalUInt64.lower(dilution),
        _UniffiConverterUInt64.lower(first),
        _UniffiConverterUInt64.lower(last)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_participation_key_by_id(self, participation_id: "str") -> "ParticipationKey":
        """
        Get participation key info given a participation ID
        """

        _UniffiConverterString.check_lower(participation_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_participation_key_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(participation_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def append_keys(self, request: "bytes",participation_id: "str") -> "ParticipationKey":
        """
        Append state proof keys to a participation key
        """

        _UniffiConverterBytes.check_lower(request)
        
        _UniffiConverterString.check_lower(participation_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_append_keys(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request),
        _UniffiConverterString.lower(participation_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def delete_participation_key_by_id(self, participation_id: "str") -> None:

        """
        Delete a given participation key by ID
        """

        _UniffiConverterString.check_lower(participation_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_delete_participation_key_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(participation_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def shutdown_node(self, timeout: "typing.Optional[int]") -> "UnknownJsonValue":
        """
        Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
        """

        _UniffiConverterOptionalUInt64.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_shutdown_node(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(timeout)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeUnknownJsonValue.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_status(self, ) -> "GetStatus":
        """
        Gets the current node status.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_status(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def wait_for_block(self, round: "int") -> "WaitForBlock":
        """
        Gets the node status after waiting for a round after the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_wait_for_block(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeWaitForBlock.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def raw_transaction(self, request: "bytes") -> "RawTransaction":
        """
        Broadcasts a raw transaction or transaction group to the network.
        """

        _UniffiConverterBytes.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_raw_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRawTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def raw_transaction_async(self, request: "bytes") -> None:

        """
        Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
        """

        _UniffiConverterBytes.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_raw_transaction_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def simulate_transaction(self, request: "SimulateRequest",format: "typing.Optional[Format]") -> "SimulateTransaction":
        """
        Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        """

        _UniffiConverterTypeSimulateRequest.check_lower(request)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_simulate_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSimulateRequest.lower(request),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSimulateTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def transaction_params(self, ) -> "TransactionParams":
        """
        Get parameters for constructing a new transaction
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_transaction_params(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionParams.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_pending_transactions(self, max: "typing.Optional[int]",format: "typing.Optional[Format]") -> "GetPendingTransactions":
        """
        Get a list of unconfirmed transactions currently in the transaction pool.
        """

        _UniffiConverterOptionalUInt64.check_lower(max)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_pending_transactions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(max),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetPendingTransactions.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def pending_transaction_information(self, txid: "str",format: "typing.Optional[Format]") -> "PendingTransactionResponse":
        """
        Get a specific pending transaction.
        """

        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_pending_transaction_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePendingTransactionResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_ledger_state_delta(self, round: "int",format: "typing.Optional[Format]") -> "LedgerStateDelta":
        """
        Get a LedgerStateDelta object for a given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ledger_state_delta(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLedgerStateDelta.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_transaction_group_ledger_state_deltas_for_round(self, round: "int",format: "typing.Optional[Format]") -> "GetTransactionGroupLedgerStateDeltasForRound":
        """
        Get LedgerStateDelta objects for all transaction groups in a given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_transaction_group_ledger_state_deltas_for_round(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRound.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_ledger_state_delta_for_transaction_group(self, id: "str",format: "typing.Optional[Format]") -> "LedgerStateDelta":
        """
        Get a LedgerStateDelta object for a given transaction group
        """

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_ledger_state_delta_for_transaction_group(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLedgerStateDelta.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_state_proof(self, round: "int") -> "StateProof":
        """
        Get a state proof that covers a given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_state_proof(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStateProof.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_light_block_header_proof(self, round: "int") -> "LightBlockHeaderProof":
        """
        Gets a proof for a given light block header inside a state proof commitment
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_light_block_header_proof(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLightBlockHeaderProof.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_application_by_id(self, application_id: "int") -> "Application":
        """
        Get application information.
        """

        _UniffiConverterUInt64.check_lower(application_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(application_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeApplication.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_application_boxes(self, application_id: "int",max: "typing.Optional[int]") -> "GetApplicationBoxes":
        """
        Get all box names for a given application.
        """

        _UniffiConverterUInt64.check_lower(application_id)
        
        _UniffiConverterOptionalUInt64.check_lower(max)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_boxes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(application_id),
        _UniffiConverterOptionalUInt64.lower(max)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetApplicationBoxes.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_application_box_by_name(self, application_id: "int",name: "str") -> "Box":
        """
        Get box information for a given application.
        """

        _UniffiConverterUInt64.check_lower(application_id)
        
        _UniffiConverterString.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_application_box_by_name(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(application_id),
        _UniffiConverterString.lower(name)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeBox.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_asset_by_id(self, asset_id: "int") -> "Asset":
        """
        Get asset information.
        """

        _UniffiConverterUInt64.check_lower(asset_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_asset_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(asset_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAsset.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_sync_round(self, ) -> "GetSyncRound":
        """
        Returns the minimum sync round the ledger is keeping in cache.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_sync_round(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetSyncRound.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def unset_sync_round(self, ) -> None:

        """
        Removes minimum sync round restriction from the ledger.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_unset_sync_round(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def set_sync_round(self, round: "int") -> None:

        """
        Given a round, tells the ledger to keep that round in its cache.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_set_sync_round(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def teal_compile(self, request: "bytes",sourcemap: "typing.Optional[bool]") -> "TealCompile":
        """
        Compile TEAL source code to binary, produce its hash
        """

        _UniffiConverterBytes.check_lower(request)
        
        _UniffiConverterOptionalBool.check_lower(sourcemap)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_compile(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request),
        _UniffiConverterOptionalBool.lower(sourcemap)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTealCompile.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def teal_disassemble(self, request: "str") -> "TealDisassemble":
        """
        Disassemble program bytes into the TEAL source code.
        """

        _UniffiConverterString.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_disassemble(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTealDisassemble.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def start_catchup(self, catchpoint: "str",min: "typing.Optional[int]") -> "StartCatchup":
        """
        Starts a catchpoint catchup.
        """

        _UniffiConverterString.check_lower(catchpoint)
        
        _UniffiConverterOptionalUInt64.check_lower(min)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_start_catchup(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(catchpoint),
        _UniffiConverterOptionalUInt64.lower(min)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStartCatchup.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def abort_catchup(self, catchpoint: "str") -> "AbortCatchup":
        """
        Aborts a catchpoint catchup.
        """

        _UniffiConverterString.check_lower(catchpoint)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_abort_catchup(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(catchpoint)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAbortCatchup.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def teal_dryrun(self, request: "typing.Optional[DryrunRequest]") -> "TealDryrun":
        """
        Provide debugging information for a transaction (or group).
        """

        _UniffiConverterOptionalTypeDryrunRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_teal_dryrun(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeDryrunRequest.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTealDryrun.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def experimental_check(self, ) -> None:

        """
        Returns OK if experimental API is enabled.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_experimental_check(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_time_stamp_offset(self, ) -> "GetBlockTimeStampOffset":
        """
        Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_get_block_time_stamp_offset(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockTimeStampOffset.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def set_block_time_stamp_offset(self, offset: "int") -> None:

        """
        Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
        """

        _UniffiConverterUInt64.check_lower(offset)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclienttrait_set_block_time_stamp_offset(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(offset)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplAlgodClientTrait:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD0
    def health_check(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.health_check
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD1
    def get_ready(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_ready
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD2
    def metrics(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.metrics
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD3
    def get_genesis(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_genesis
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGenesis.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD4
    def swagger_json(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.swagger_json
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD5
    def get_version(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_version
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeVersion.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD6
    def get_debug_settings_prof(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_debug_settings_prof
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeDebugSettingsProf.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD7
    def put_debug_settings_prof(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.put_debug_settings_prof
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeDebugSettingsProf.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD8
    def get_config(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_config
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD9
    def account_information(
            uniffi_handle,
            address,
            exclude,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterOptionalTypeExclude.lift(exclude), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.account_information
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAccount.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD10
    def account_asset_information(
            uniffi_handle,
            address,
            asset_id,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterUInt64.lift(asset_id), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.account_asset_information
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAccountAssetInformation.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD11
    def account_assets_information(
            uniffi_handle,
            address,
            limit,
            next,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterOptionalUInt64.lift(limit), _UniffiConverterOptionalString.lift(next), )
            method = uniffi_obj.account_assets_information
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAccountAssetsInformation.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD12
    def account_application_information(
            uniffi_handle,
            address,
            application_id,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterUInt64.lift(application_id), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.account_application_information
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAccountApplicationInformation.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD13
    def get_pending_transactions_by_address(
            uniffi_handle,
            address,
            max,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterOptionalUInt64.lift(max), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_pending_transactions_by_address
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetPendingTransactionsByAddress.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD14
    def get_block(
            uniffi_handle,
            round,
            header_only,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), _UniffiConverterOptionalBool.lift(header_only), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_block
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetBlock.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD15
    def get_block_txids(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.get_block_txids
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetBlockTxids.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD16
    def get_block_hash(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.get_block_hash
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetBlockHash.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD17
    def get_transaction_proof(
            uniffi_handle,
            round,
            txid,
            hashtype,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), _UniffiConverterString.lift(txid), _UniffiConverterOptionalTypeHashtype.lift(hashtype), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_transaction_proof
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTransactionProof.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD18
    def get_block_logs(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.get_block_logs
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetBlockLogs.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD19
    def get_supply(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_supply
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetSupply.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD20
    def get_participation_keys(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_participation_keys
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeParticipationKey.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD21
    def add_participation_key(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(request), )
            method = uniffi_obj.add_participation_key
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAddParticipationKey.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD22
    def generate_participation_keys(
            uniffi_handle,
            address,
            dilution,
            first,
            last,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterOptionalUInt64.lift(dilution), _UniffiConverterUInt64.lift(first), _UniffiConverterUInt64.lift(last), )
            method = uniffi_obj.generate_participation_keys
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD23
    def get_participation_key_by_id(
            uniffi_handle,
            participation_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(participation_id), )
            method = uniffi_obj.get_participation_key_by_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeParticipationKey.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD24
    def append_keys(
            uniffi_handle,
            request,
            participation_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(request), _UniffiConverterString.lift(participation_id), )
            method = uniffi_obj.append_keys
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeParticipationKey.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD25
    def delete_participation_key_by_id(
            uniffi_handle,
            participation_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(participation_id), )
            method = uniffi_obj.delete_participation_key_by_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD26
    def shutdown_node(
            uniffi_handle,
            timeout,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterOptionalUInt64.lift(timeout), )
            method = uniffi_obj.shutdown_node
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeUnknownJsonValue.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD27
    def get_status(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_status
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetStatus.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD28
    def wait_for_block(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.wait_for_block
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeWaitForBlock.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD29
    def raw_transaction(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(request), )
            method = uniffi_obj.raw_transaction
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeRawTransaction.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD30
    def raw_transaction_async(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(request), )
            method = uniffi_obj.raw_transaction_async
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD31
    def simulate_transaction(
            uniffi_handle,
            request,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeSimulateRequest.lift(request), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.simulate_transaction
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeSimulateTransaction.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD32
    def transaction_params(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.transaction_params
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTransactionParams.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD33
    def get_pending_transactions(
            uniffi_handle,
            max,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterOptionalUInt64.lift(max), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_pending_transactions
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetPendingTransactions.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD34
    def pending_transaction_information(
            uniffi_handle,
            txid,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(txid), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.pending_transaction_information
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypePendingTransactionResponse.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD35
    def get_ledger_state_delta(
            uniffi_handle,
            round,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_ledger_state_delta
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeLedgerStateDelta.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD36
    def get_transaction_group_ledger_state_deltas_for_round(
            uniffi_handle,
            round,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_transaction_group_ledger_state_deltas_for_round
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRound.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD37
    def get_ledger_state_delta_for_transaction_group(
            uniffi_handle,
            id,
            format,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(id), _UniffiConverterOptionalTypeFormat.lift(format), )
            method = uniffi_obj.get_ledger_state_delta_for_transaction_group
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeLedgerStateDelta.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD38
    def get_state_proof(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.get_state_proof
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeStateProof.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD39
    def get_light_block_header_proof(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.get_light_block_header_proof
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeLightBlockHeaderProof.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD40
    def get_application_by_id(
            uniffi_handle,
            application_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(application_id), )
            method = uniffi_obj.get_application_by_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeApplication.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD41
    def get_application_boxes(
            uniffi_handle,
            application_id,
            max,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(application_id), _UniffiConverterOptionalUInt64.lift(max), )
            method = uniffi_obj.get_application_boxes
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetApplicationBoxes.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD42
    def get_application_box_by_name(
            uniffi_handle,
            application_id,
            name,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(application_id), _UniffiConverterString.lift(name), )
            method = uniffi_obj.get_application_box_by_name
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeBox.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD43
    def get_asset_by_id(
            uniffi_handle,
            asset_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(asset_id), )
            method = uniffi_obj.get_asset_by_id
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAsset.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD44
    def get_sync_round(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_sync_round
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetSyncRound.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD45
    def unset_sync_round(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.unset_sync_round
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD46
    def set_sync_round(
            uniffi_handle,
            round,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(round), )
            method = uniffi_obj.set_sync_round
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD47
    def teal_compile(
            uniffi_handle,
            request,
            sourcemap,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(request), _UniffiConverterOptionalBool.lift(sourcemap), )
            method = uniffi_obj.teal_compile
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTealCompile.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD48
    def teal_disassemble(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(request), )
            method = uniffi_obj.teal_disassemble
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTealDisassemble.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD49
    def start_catchup(
            uniffi_handle,
            catchpoint,
            min,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(catchpoint), _UniffiConverterOptionalUInt64.lift(min), )
            method = uniffi_obj.start_catchup
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeStartCatchup.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD50
    def abort_catchup(
            uniffi_handle,
            catchpoint,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(catchpoint), )
            method = uniffi_obj.abort_catchup
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAbortCatchup.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD51
    def teal_dryrun(
            uniffi_handle,
            request,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterOptionalTypeDryrunRequest.lift(request), )
            method = uniffi_obj.teal_dryrun
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTealDryrun.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD52
    def experimental_check(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.experimental_check
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD53
    def get_block_time_stamp_offset(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_block_time_stamp_offset
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeGetBlockTimeStampOffset.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD54
    def set_block_time_stamp_offset(
            uniffi_handle,
            offset,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterUInt64.lift(offset), )
            method = uniffi_obj.set_block_time_stamp_offset
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, Error, _UniffiConverterTypeError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeAlgodClientTrait._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceAlgodClientTrait(
        health_check,
        get_ready,
        metrics,
        get_genesis,
        swagger_json,
        get_version,
        get_debug_settings_prof,
        put_debug_settings_prof,
        get_config,
        account_information,
        account_asset_information,
        account_assets_information,
        account_application_information,
        get_pending_transactions_by_address,
        get_block,
        get_block_txids,
        get_block_hash,
        get_transaction_proof,
        get_block_logs,
        get_supply,
        get_participation_keys,
        add_participation_key,
        generate_participation_keys,
        get_participation_key_by_id,
        append_keys,
        delete_participation_key_by_id,
        shutdown_node,
        get_status,
        wait_for_block,
        raw_transaction,
        raw_transaction_async,
        simulate_transaction,
        transaction_params,
        get_pending_transactions,
        pending_transaction_information,
        get_ledger_state_delta,
        get_transaction_group_ledger_state_deltas_for_round,
        get_ledger_state_delta_for_transaction_group,
        get_state_proof,
        get_light_block_header_proof,
        get_application_by_id,
        get_application_boxes,
        get_application_box_by_name,
        get_asset_by_id,
        get_sync_round,
        unset_sync_round,
        set_sync_round,
        teal_compile,
        teal_disassemble,
        start_catchup,
        abort_catchup,
        teal_dryrun,
        experimental_check,
        get_block_time_stamp_offset,
        set_block_time_stamp_offset,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_algod_client_ffi_fn_init_callback_vtable_algodclienttrait(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeAlgodClientTrait:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return AlgodClientTraitImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: AlgodClientTrait):
        pass

    @staticmethod
    def lower(value: AlgodClientTraitProtocol):
        return _UniffiConverterTypeAlgodClientTrait._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AlgodClientTraitProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class AlgodClientProtocol(typing.Protocol):
    """
    The main Algod API client.

    This client provides convenient access to all Algod API endpoints.
    It wraps the lower-level endpoint functions with a more ergonomic interface.
    All methods return a unified `Error` type that can represent any endpoint error.
    """

    def abort_catchup(self, catchpoint: "str"):
        """
        Aborts a catchpoint catchup.
        """

        raise NotImplementedError
    def account_application_information(self, address: "str",application_id: "int",format: "typing.Optional[Format]"):
        """
        Get account information about a given app.
        """

        raise NotImplementedError
    def account_asset_information(self, address: "str",asset_id: "int",format: "typing.Optional[Format]"):
        """
        Get account information about a given asset.
        """

        raise NotImplementedError
    def account_assets_information(self, address: "str",limit: "typing.Optional[int]",next: "typing.Optional[str]"):
        """
        Get a list of assets held by an account, inclusive of asset params.
        """

        raise NotImplementedError
    def account_information(self, address: "str",exclude: "typing.Optional[Exclude]",format: "typing.Optional[Format]"):
        """
        Get account information.
        """

        raise NotImplementedError
    def add_participation_key(self, request: "bytes"):
        """
        Add a participation key to the node
        """

        raise NotImplementedError
    def append_keys(self, request: "bytes",participation_id: "str"):
        """
        Append state proof keys to a participation key
        """

        raise NotImplementedError
    def delete_participation_key_by_id(self, participation_id: "str"):
        """
        Delete a given participation key by ID
        """

        raise NotImplementedError
    def experimental_check(self, ):
        """
        Returns OK if experimental API is enabled.
        """

        raise NotImplementedError
    def generate_participation_keys(self, address: "str",dilution: "typing.Optional[int]",first: "int",last: "int"):
        """
        Generate and install participation keys to the node.
        """

        raise NotImplementedError
    def get_application_box_by_name(self, application_id: "int",name: "str"):
        """
        Get box information for a given application.
        """

        raise NotImplementedError
    def get_application_boxes(self, application_id: "int",max: "typing.Optional[int]"):
        """
        Get all box names for a given application.
        """

        raise NotImplementedError
    def get_application_by_id(self, application_id: "int"):
        """
        Get application information.
        """

        raise NotImplementedError
    def get_asset_by_id(self, asset_id: "int"):
        """
        Get asset information.
        """

        raise NotImplementedError
    def get_block(self, round: "int",header_only: "typing.Optional[bool]",format: "typing.Optional[Format]"):
        """
        Get the block for the given round.
        """

        raise NotImplementedError
    def get_block_hash(self, round: "int"):
        """
        Get the block hash for the block on the given round.
        """

        raise NotImplementedError
    def get_block_logs(self, round: "int"):
        """
        Get all of the logs from outer and inner app calls in the given round
        """

        raise NotImplementedError
    def get_block_time_stamp_offset(self, ):
        """
        Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
        """

        raise NotImplementedError
    def get_block_txids(self, round: "int"):
        """
        Get the top level transaction IDs for the block on the given round.
        """

        raise NotImplementedError
    def get_config(self, ):
        """
        Gets the merged config file.
        """

        raise NotImplementedError
    def get_debug_settings_prof(self, ):
        """
        Retrieves the current settings for blocking and mutex profiles
        """

        raise NotImplementedError
    def get_genesis(self, ):
        """
        Gets the genesis information.
        """

        raise NotImplementedError
    def get_ledger_state_delta(self, round: "int",format: "typing.Optional[Format]"):
        """
        Get a LedgerStateDelta object for a given round
        """

        raise NotImplementedError
    def get_ledger_state_delta_for_transaction_group(self, id: "str",format: "typing.Optional[Format]"):
        """
        Get a LedgerStateDelta object for a given transaction group
        """

        raise NotImplementedError
    def get_light_block_header_proof(self, round: "int"):
        """
        Gets a proof for a given light block header inside a state proof commitment
        """

        raise NotImplementedError
    def get_participation_key_by_id(self, participation_id: "str"):
        """
        Get participation key info given a participation ID
        """

        raise NotImplementedError
    def get_participation_keys(self, ):
        """
        Return a list of participation keys
        """

        raise NotImplementedError
    def get_pending_transactions(self, max: "typing.Optional[int]",format: "typing.Optional[Format]"):
        """
        Get a list of unconfirmed transactions currently in the transaction pool.
        """

        raise NotImplementedError
    def get_pending_transactions_by_address(self, address: "str",max: "typing.Optional[int]",format: "typing.Optional[Format]"):
        """
        Get a list of unconfirmed transactions currently in the transaction pool by address.
        """

        raise NotImplementedError
    def get_ready(self, ):
        """
        Returns OK if healthy and fully caught up.
        """

        raise NotImplementedError
    def get_state_proof(self, round: "int"):
        """
        Get a state proof that covers a given round
        """

        raise NotImplementedError
    def get_status(self, ):
        """
        Gets the current node status.
        """

        raise NotImplementedError
    def get_supply(self, ):
        """
        Get the current supply reported by the ledger.
        """

        raise NotImplementedError
    def get_sync_round(self, ):
        """
        Returns the minimum sync round the ledger is keeping in cache.
        """

        raise NotImplementedError
    def get_transaction_group_ledger_state_deltas_for_round(self, round: "int",format: "typing.Optional[Format]"):
        """
        Get LedgerStateDelta objects for all transaction groups in a given round
        """

        raise NotImplementedError
    def get_transaction_proof(self, round: "int",txid: "str",hashtype: "typing.Optional[Hashtype]",format: "typing.Optional[Format]"):
        """
        Get a proof for a transaction in a block.
        """

        raise NotImplementedError
    def get_version(self, ):
        """
        Retrieves the supported API versions, binary build versions, and genesis information.
        """

        raise NotImplementedError
    def health_check(self, ):
        """
        Returns OK if healthy.
        """

        raise NotImplementedError
    def metrics(self, ):
        """
        Return metrics about algod functioning.
        """

        raise NotImplementedError
    def pending_transaction_information(self, txid: "str",format: "typing.Optional[Format]"):
        """
        Get a specific pending transaction.
        """

        raise NotImplementedError
    def put_debug_settings_prof(self, ):
        """
        Enables blocking and mutex profiles, and returns the old settings
        """

        raise NotImplementedError
    def raw_transaction(self, request: "bytes"):
        """
        Broadcasts a raw transaction or transaction group to the network.
        """

        raise NotImplementedError
    def raw_transaction_async(self, request: "bytes"):
        """
        Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
        """

        raise NotImplementedError
    def set_block_time_stamp_offset(self, offset: "int"):
        """
        Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
        """

        raise NotImplementedError
    def set_sync_round(self, round: "int"):
        """
        Given a round, tells the ledger to keep that round in its cache.
        """

        raise NotImplementedError
    def shutdown_node(self, timeout: "typing.Optional[int]"):
        """
        Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
        """

        raise NotImplementedError
    def simulate_transaction(self, request: "SimulateRequest",format: "typing.Optional[Format]"):
        """
        Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        """

        raise NotImplementedError
    def start_catchup(self, catchpoint: "str",min: "typing.Optional[int]"):
        """
        Starts a catchpoint catchup.
        """

        raise NotImplementedError
    def swagger_json(self, ):
        """
        Gets the current swagger spec.
        """

        raise NotImplementedError
    def teal_compile(self, request: "bytes",sourcemap: "typing.Optional[bool]"):
        """
        Compile TEAL source code to binary, produce its hash
        """

        raise NotImplementedError
    def teal_disassemble(self, request: "str"):
        """
        Disassemble program bytes into the TEAL source code.
        """

        raise NotImplementedError
    def teal_dryrun(self, request: "typing.Optional[DryrunRequest]"):
        """
        Provide debugging information for a transaction (or group).
        """

        raise NotImplementedError
    def transaction_params(self, ):
        """
        Get parameters for constructing a new transaction
        """

        raise NotImplementedError
    def unset_sync_round(self, ):
        """
        Removes minimum sync round restriction from the ledger.
        """

        raise NotImplementedError
    def wait_for_block(self, round: "int"):
        """
        Gets the node status after waiting for a round after the given round.
        """

        raise NotImplementedError
# AlgodClient is a Rust-only trait - it's a wrapper around a Rust implementation.
class AlgodClient(AlgodClientTrait,):
    """
    The main Algod API client.

    This client provides convenient access to all Algod API endpoints.
    It wraps the lower-level endpoint functions with a more ergonomic interface.
    All methods return a unified `Error` type that can represent any endpoint error.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, http_client: "HttpClient"):
        """
        Create a new AlgodClient with a custom http client.
        """

        _UniffiConverterTypeHttpClient.check_lower(http_client)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_algod_client_ffi_fn_constructor_algodclient_new,
        _UniffiConverterTypeHttpClient.lower(http_client))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algod_client_ffi_fn_free_algodclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algod_client_ffi_fn_clone_algodclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def abort_catchup(self, catchpoint: "str") -> "AbortCatchup":
        """
        Aborts a catchpoint catchup.
        """

        _UniffiConverterString.check_lower(catchpoint)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_abort_catchup(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(catchpoint)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAbortCatchup.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_application_information(self, address: "str",application_id: "int",format: "typing.Optional[Format]") -> "AccountApplicationInformation":
        """
        Get account information about a given app.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(application_id)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_application_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterUInt64.lower(application_id),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountApplicationInformation.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_asset_information(self, address: "str",asset_id: "int",format: "typing.Optional[Format]") -> "AccountAssetInformation":
        """
        Get account information about a given asset.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterUInt64.check_lower(asset_id)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_asset_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterUInt64.lower(asset_id),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountAssetInformation.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_assets_information(self, address: "str",limit: "typing.Optional[int]",next: "typing.Optional[str]") -> "AccountAssetsInformation":
        """
        Get a list of assets held by an account, inclusive of asset params.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalUInt64.check_lower(limit)
        
        _UniffiConverterOptionalString.check_lower(next)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_assets_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalUInt64.lower(limit),
        _UniffiConverterOptionalString.lower(next)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountAssetsInformation.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def account_information(self, address: "str",exclude: "typing.Optional[Exclude]",format: "typing.Optional[Format]") -> "Account":
        """
        Get account information.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalTypeExclude.check_lower(exclude)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_account_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalTypeExclude.lower(exclude),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccount.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def add_participation_key(self, request: "bytes") -> "AddParticipationKey":
        """
        Add a participation key to the node
        """

        _UniffiConverterBytes.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_add_participation_key(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAddParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def append_keys(self, request: "bytes",participation_id: "str") -> "ParticipationKey":
        """
        Append state proof keys to a participation key
        """

        _UniffiConverterBytes.check_lower(request)
        
        _UniffiConverterString.check_lower(participation_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_append_keys(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request),
        _UniffiConverterString.lower(participation_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def delete_participation_key_by_id(self, participation_id: "str") -> None:

        """
        Delete a given participation key by ID
        """

        _UniffiConverterString.check_lower(participation_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_delete_participation_key_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(participation_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def experimental_check(self, ) -> None:

        """
        Returns OK if experimental API is enabled.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_experimental_check(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def generate_participation_keys(self, address: "str",dilution: "typing.Optional[int]",first: "int",last: "int") -> "str":
        """
        Generate and install participation keys to the node.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalUInt64.check_lower(dilution)
        
        _UniffiConverterUInt64.check_lower(first)
        
        _UniffiConverterUInt64.check_lower(last)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_generate_participation_keys(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalUInt64.lower(dilution),
        _UniffiConverterUInt64.lower(first),
        _UniffiConverterUInt64.lower(last)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_application_box_by_name(self, application_id: "int",name: "str") -> "Box":
        """
        Get box information for a given application.
        """

        _UniffiConverterUInt64.check_lower(application_id)
        
        _UniffiConverterString.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_box_by_name(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(application_id),
        _UniffiConverterString.lower(name)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeBox.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_application_boxes(self, application_id: "int",max: "typing.Optional[int]") -> "GetApplicationBoxes":
        """
        Get all box names for a given application.
        """

        _UniffiConverterUInt64.check_lower(application_id)
        
        _UniffiConverterOptionalUInt64.check_lower(max)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_boxes(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(application_id),
        _UniffiConverterOptionalUInt64.lower(max)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetApplicationBoxes.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_application_by_id(self, application_id: "int") -> "Application":
        """
        Get application information.
        """

        _UniffiConverterUInt64.check_lower(application_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_application_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(application_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeApplication.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_asset_by_id(self, asset_id: "int") -> "Asset":
        """
        Get asset information.
        """

        _UniffiConverterUInt64.check_lower(asset_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_asset_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(asset_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAsset.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block(self, round: "int",header_only: "typing.Optional[bool]",format: "typing.Optional[Format]") -> "GetBlock":
        """
        Get the block for the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalBool.check_lower(header_only)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalBool.lower(header_only),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlock.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_hash(self, round: "int") -> "GetBlockHash":
        """
        Get the block hash for the block on the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_hash(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockHash.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_logs(self, round: "int") -> "GetBlockLogs":
        """
        Get all of the logs from outer and inner app calls in the given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_logs(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockLogs.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_time_stamp_offset(self, ) -> "GetBlockTimeStampOffset":
        """
        Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_time_stamp_offset(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockTimeStampOffset.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_block_txids(self, round: "int") -> "GetBlockTxids":
        """
        Get the top level transaction IDs for the block on the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_block_txids(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetBlockTxids.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_config(self, ) -> "str":
        """
        Gets the merged config file.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_config(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_debug_settings_prof(self, ) -> "DebugSettingsProf":
        """
        Retrieves the current settings for blocking and mutex profiles
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_debug_settings_prof(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDebugSettingsProf.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_genesis(self, ) -> "Genesis":
        """
        Gets the genesis information.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_genesis(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGenesis.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_ledger_state_delta(self, round: "int",format: "typing.Optional[Format]") -> "LedgerStateDelta":
        """
        Get a LedgerStateDelta object for a given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ledger_state_delta(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLedgerStateDelta.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_ledger_state_delta_for_transaction_group(self, id: "str",format: "typing.Optional[Format]") -> "LedgerStateDelta":
        """
        Get a LedgerStateDelta object for a given transaction group
        """

        _UniffiConverterString.check_lower(id)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ledger_state_delta_for_transaction_group(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLedgerStateDelta.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_light_block_header_proof(self, round: "int") -> "LightBlockHeaderProof":
        """
        Gets a proof for a given light block header inside a state proof commitment
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_light_block_header_proof(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeLightBlockHeaderProof.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_participation_key_by_id(self, participation_id: "str") -> "ParticipationKey":
        """
        Get participation key info given a participation ID
        """

        _UniffiConverterString.check_lower(participation_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_participation_key_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(participation_id)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_participation_keys(self, ) -> "typing.List[ParticipationKey]":
        """
        Return a list of participation keys
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_participation_keys(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeParticipationKey.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_pending_transactions(self, max: "typing.Optional[int]",format: "typing.Optional[Format]") -> "GetPendingTransactions":
        """
        Get a list of unconfirmed transactions currently in the transaction pool.
        """

        _UniffiConverterOptionalUInt64.check_lower(max)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_pending_transactions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(max),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetPendingTransactions.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_pending_transactions_by_address(self, address: "str",max: "typing.Optional[int]",format: "typing.Optional[Format]") -> "GetPendingTransactionsByAddress":
        """
        Get a list of unconfirmed transactions currently in the transaction pool by address.
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterOptionalUInt64.check_lower(max)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_pending_transactions_by_address(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address),
        _UniffiConverterOptionalUInt64.lower(max),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetPendingTransactionsByAddress.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_ready(self, ) -> None:

        """
        Returns OK if healthy and fully caught up.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_ready(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_state_proof(self, round: "int") -> "StateProof":
        """
        Get a state proof that covers a given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_state_proof(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStateProof.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_status(self, ) -> "GetStatus":
        """
        Gets the current node status.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_status(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_supply(self, ) -> "GetSupply":
        """
        Get the current supply reported by the ledger.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_supply(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetSupply.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_sync_round(self, ) -> "GetSyncRound":
        """
        Returns the minimum sync round the ledger is keeping in cache.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_sync_round(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetSyncRound.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_transaction_group_ledger_state_deltas_for_round(self, round: "int",format: "typing.Optional[Format]") -> "GetTransactionGroupLedgerStateDeltasForRound":
        """
        Get LedgerStateDelta objects for all transaction groups in a given round
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_transaction_group_ledger_state_deltas_for_round(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeGetTransactionGroupLedgerStateDeltasForRound.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_transaction_proof(self, round: "int",txid: "str",hashtype: "typing.Optional[Hashtype]",format: "typing.Optional[Format]") -> "TransactionProof":
        """
        Get a proof for a transaction in a block.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterOptionalTypeHashtype.check_lower(hashtype)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_transaction_proof(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterString.lower(txid),
        _UniffiConverterOptionalTypeHashtype.lower(hashtype),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionProof.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def get_version(self, ) -> "Version":
        """
        Retrieves the supported API versions, binary build versions, and genesis information.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_get_version(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeVersion.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def health_check(self, ) -> None:

        """
        Returns OK if healthy.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_health_check(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def metrics(self, ) -> None:

        """
        Return metrics about algod functioning.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_metrics(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def pending_transaction_information(self, txid: "str",format: "typing.Optional[Format]") -> "PendingTransactionResponse":
        """
        Get a specific pending transaction.
        """

        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_pending_transaction_information(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(txid),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypePendingTransactionResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def put_debug_settings_prof(self, ) -> "DebugSettingsProf":
        """
        Enables blocking and mutex profiles, and returns the old settings
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_put_debug_settings_prof(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDebugSettingsProf.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def raw_transaction(self, request: "bytes") -> "RawTransaction":
        """
        Broadcasts a raw transaction or transaction group to the network.
        """

        _UniffiConverterBytes.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_raw_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeRawTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def raw_transaction_async(self, request: "bytes") -> None:

        """
        Fast track for broadcasting a raw transaction or transaction group to the network through the tx handler without performing most of the checks and reporting detailed errors. Should be only used for development and performance testing.
        """

        _UniffiConverterBytes.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_raw_transaction_async(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def set_block_time_stamp_offset(self, offset: "int") -> None:

        """
        Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
        """

        _UniffiConverterUInt64.check_lower(offset)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_set_block_time_stamp_offset(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(offset)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def set_sync_round(self, round: "int") -> None:

        """
        Given a round, tells the ledger to keep that round in its cache.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_set_sync_round(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def shutdown_node(self, timeout: "typing.Optional[int]") -> "UnknownJsonValue":
        """
        Special management endpoint to shutdown the node. Optionally provide a timeout parameter to indicate that the node should begin shutting down after a number of seconds.
        """

        _UniffiConverterOptionalUInt64.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_shutdown_node(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(timeout)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeUnknownJsonValue.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def simulate_transaction(self, request: "SimulateRequest",format: "typing.Optional[Format]") -> "SimulateTransaction":
        """
        Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
        """

        _UniffiConverterTypeSimulateRequest.check_lower(request)
        
        _UniffiConverterOptionalTypeFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_simulate_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSimulateRequest.lower(request),
        _UniffiConverterOptionalTypeFormat.lower(format)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSimulateTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def start_catchup(self, catchpoint: "str",min: "typing.Optional[int]") -> "StartCatchup":
        """
        Starts a catchpoint catchup.
        """

        _UniffiConverterString.check_lower(catchpoint)
        
        _UniffiConverterOptionalUInt64.check_lower(min)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_start_catchup(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(catchpoint),
        _UniffiConverterOptionalUInt64.lower(min)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeStartCatchup.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def swagger_json(self, ) -> "str":
        """
        Gets the current swagger spec.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_swagger_json(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def teal_compile(self, request: "bytes",sourcemap: "typing.Optional[bool]") -> "TealCompile":
        """
        Compile TEAL source code to binary, produce its hash
        """

        _UniffiConverterBytes.check_lower(request)
        
        _UniffiConverterOptionalBool.check_lower(sourcemap)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_compile(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(request),
        _UniffiConverterOptionalBool.lower(sourcemap)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTealCompile.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def teal_disassemble(self, request: "str") -> "TealDisassemble":
        """
        Disassemble program bytes into the TEAL source code.
        """

        _UniffiConverterString.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_disassemble(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTealDisassemble.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def teal_dryrun(self, request: "typing.Optional[DryrunRequest]") -> "TealDryrun":
        """
        Provide debugging information for a transaction (or group).
        """

        _UniffiConverterOptionalTypeDryrunRequest.check_lower(request)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_teal_dryrun(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeDryrunRequest.lower(request)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTealDryrun.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def transaction_params(self, ) -> "TransactionParams":
        """
        Get parameters for constructing a new transaction
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_transaction_params(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionParams.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def unset_sync_round(self, ) -> None:

        """
        Removes minimum sync round restriction from the ledger.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_unset_sync_round(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeError,

        )



    async def wait_for_block(self, round: "int") -> "WaitForBlock":
        """
        Gets the node status after waiting for a round after the given round.
        """

        _UniffiConverterUInt64.check_lower(round)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algod_client_ffi_fn_method_algodclient_wait_for_block(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(round)
            ),
            _UniffiLib.ffi_algod_client_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algod_client_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeWaitForBlock.lift,
            
    # Error FFI converter
_UniffiConverterTypeError,

        )





class _UniffiConverterTypeAlgodClient:

    @staticmethod
    def lift(value: int):
        return AlgodClient._make_instance_(value)

    @staticmethod
    def check_lower(value: AlgodClient):
        if not isinstance(value, AlgodClient):
            raise TypeError("Expected AlgodClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AlgodClientProtocol):
        if not isinstance(value, AlgodClient):
            raise TypeError("Expected AlgodClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AlgodClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# External type HttpClient: `from .algokit_http_client import HttpClient`

# External type SignedTransaction: `from .algokit_transact_ffi import SignedTransaction`

# External type HttpError: `from .algokit_http_client import HttpError`
StateDelta = typing.List[EvalDeltaKeyValue]
TealKeyValueStore = typing.List[TealKeyValue]
UnknownJsonValue = str

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)
def _uniffi_trait_interface_call_async(make_call, handle_success, handle_error):
    async def make_call_and_call_callback():
        try:
            handle_success(await make_call())
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

def _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, error_type, lower_error):
    async def make_call_and_call_callback():
        try:
            try:
                handle_success(await make_call())
            except error_type as e:
                handle_error(
                    _UniffiRustCallStatus.CALL_ERROR,
                    lower_error(e),
                )
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

_UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = _UniffiHandleMap()

@_UNIFFI_FOREIGN_FUTURE_FREE
def _uniffi_foreign_future_free(handle):
    (eventloop, task) = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle)
    eventloop.call_soon(_uniffi_foreign_future_do_free, task)

def _uniffi_foreign_future_do_free(task):
    if not task.done():
        task.cancel()

__all__ = [
    "InternalError",
    "AbortCatchupError",
    "AccountApplicationInformationError",
    "AccountAssetInformationError",
    "AccountAssetsInformationError",
    "AccountInformationError",
    "AddParticipationKeyError",
    "AlgodApiError",
    "AppendKeysError",
    "DeleteParticipationKeyByIdError",
    "Error",
    "Exclude",
    "ExperimentalCheckError",
    "Format",
    "GenerateParticipationKeysError",
    "GetApplicationBoxByNameError",
    "GetApplicationBoxesError",
    "GetApplicationByIdError",
    "GetAssetByIdError",
    "GetBlockError",
    "GetBlockHashError",
    "GetBlockLogsError",
    "GetBlockTimeStampOffsetError",
    "GetBlockTxidsError",
    "GetConfigError",
    "GetDebugSettingsProfError",
    "GetGenesisError",
    "GetLedgerStateDeltaError",
    "GetLedgerStateDeltaForTransactionGroupError",
    "GetLightBlockHeaderProofError",
    "GetParticipationKeyByIdError",
    "GetParticipationKeysError",
    "GetPendingTransactionsByAddressError",
    "GetPendingTransactionsError",
    "GetReadyError",
    "GetStateProofError",
    "GetStatusError",
    "GetSupplyError",
    "GetSyncRoundError",
    "GetTransactionGroupLedgerStateDeltasForRoundError",
    "GetTransactionProofError",
    "GetVersionError",
    "Hashtype",
    "HealthCheckError",
    "MetricsError",
    "PendingTransactionInformationError",
    "PutDebugSettingsProfError",
    "RawTransactionAsyncError",
    "RawTransactionError",
    "SetBlockTimeStampOffsetError",
    "SetSyncRoundError",
    "ShutdownNodeError",
    "SimulateTransactionError",
    "StartCatchupError",
    "SwaggerJsonError",
    "TealCompileError",
    "TealDisassembleError",
    "TealDryrunError",
    "TransactionParamsError",
    "UnsetSyncRoundError",
    "WaitForBlockError",
    "AbortCatchup",
    "Account",
    "AccountApplicationInformation",
    "AccountAssetHolding",
    "AccountAssetInformation",
    "AccountAssetsInformation",
    "AccountParticipation",
    "AccountStateDelta",
    "AddParticipationKey",
    "AppCallLogs",
    "Application",
    "ApplicationInitialStates",
    "ApplicationKvStorage",
    "ApplicationLocalReference",
    "ApplicationLocalState",
    "ApplicationParams",
    "ApplicationStateOperation",
    "ApplicationStateSchema",
    "Asset",
    "AssetHolding",
    "AssetHoldingReference",
    "AssetParams",
    "AvmKeyValue",
    "AvmValue",
    "Box",
    "BoxDescriptor",
    "BoxReference",
    "BuildVersion",
    "DebugSettingsProf",
    "DryrunRequest",
    "DryrunSource",
    "DryrunState",
    "DryrunTxnResult",
    "ErrorResponse",
    "EvalDelta",
    "EvalDeltaKeyValue",
    "Genesis",
    "GenesisAllocation",
    "GetApplicationBoxes",
    "GetBlock",
    "GetBlockHash",
    "GetBlockLogs",
    "GetBlockTimeStampOffset",
    "GetBlockTxids",
    "GetPendingTransactions",
    "GetPendingTransactionsByAddress",
    "GetStatus",
    "GetSupply",
    "GetSyncRound",
    "GetTransactionGroupLedgerStateDeltasForRound",
    "LedgerStateDelta",
    "LedgerStateDeltaForTransactionGroup",
    "LightBlockHeaderProof",
    "ParticipationKey",
    "PendingTransactionResponse",
    "RawTransaction",
    "ScratchChange",
    "SimulateInitialStates",
    "SimulateRequest",
    "SimulateRequestTransactionGroup",
    "SimulateTraceConfig",
    "SimulateTransaction",
    "SimulateTransactionGroupResult",
    "SimulateTransactionResult",
    "SimulateUnnamedResourcesAccessed",
    "SimulationEvalOverrides",
    "SimulationOpcodeTraceUnit",
    "SimulationTransactionExecTrace",
    "StartCatchup",
    "StateProof",
    "StateProofMessage",
    "TealCompile",
    "TealDisassemble",
    "TealDryrun",
    "TealKeyValue",
    "TealValue",
    "TransactionParams",
    "TransactionProof",
    "Version",
    "WaitForBlock",
    "AlgodClient",
    "AlgodClientTrait",
]

