# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
from dataclasses import dataclass
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform


# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(f"junk data left in buffer at end of consume_with_stream {s.remaining()}")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError(f"junk data left in buffer at end of read_with_stream {s.remaining()}")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiFfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))
# Initial value and increment amount for handles. 
# These ensure that Python-generated handles always have the lowest bit set
_UNIFFI_HANDLEMAP_INITIAL = 1
_UNIFFI_HANDLEMAP_DELTA = 2

class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = _UNIFFI_HANDLEMAP_INITIAL

    def insert(self, obj):
        with self._lock:
            return self._insert(obj)

    """Low-level insert, this assumes `self._lock` is held."""
    def _insert(self, obj):
        handle = self._counter
        self._counter += _UNIFFI_HANDLEMAP_DELTA
        self._map[handle] = obj
        return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.get: Invalid handle {handle}")

    def clone(self, handle):
        try:
            with self._lock:
                obj = self._map[handle]
                return self._insert(obj)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.clone: Invalid handle {handle}")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.remove: Invalid handle: {handle}")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("algokit_utils_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 30
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_algokit_transact_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_algokit_transact_ffi_checksum_func_address_from_multisig_signature() != 51026:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_address_from_public_key() != 10716:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_apply_multisig_subsignature() != 42634:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_assign_fee() != 35003:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_calculate_fee() != 7537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transaction() != 43569:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transactions() != 62888:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_decode_transaction() != 56405:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_decode_transactions() != 26956:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transaction() != 47064:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transactions() != 1956:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction() != 11275:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction_raw() != 384:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_encode_transactions() != 59611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_estimate_transaction_size() != 60858:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_get_algorand_constant() != 49400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_get_encoded_transaction_type() != 42551:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id() != 10957:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id_raw() != 48975:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_group_transactions() != 18193:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_merge_multisignatures() != 58688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_new_multisig_signature() != 29314:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_participants_from_multisig_signature() != 25095:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_transact_ffi_checksum_func_public_key_from_address() != 58152:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFutureDroppedCallbackStruct(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK),
    ]
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_complete_void.restype = None
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_transact_ffi_rust_future_free_void.restype = None
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_address_from_multisig_signature.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_address_from_multisig_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_address_from_public_key.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_address_from_public_key.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_apply_multisig_subsignature.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_apply_multisig_subsignature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_assign_fee.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_assign_fee.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_calculate_fee.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_calculate_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_signed_transaction.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_signed_transaction.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_signed_transactions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_signed_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_transaction.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_transaction.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_transactions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_signed_transaction.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_signed_transaction.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_signed_transactions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_signed_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transaction.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transaction.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transaction_raw.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transaction_raw.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transactions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_estimate_transaction_size.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_estimate_transaction_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_algorand_constant.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_algorand_constant.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_encoded_transaction_type.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_encoded_transaction_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_transaction_id.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_transaction_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_transaction_id_raw.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_transaction_id_raw.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_group_transactions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_group_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_merge_multisignatures.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_merge_multisignatures.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_new_multisig_signature.argtypes = (
    ctypes.c_uint8,
    ctypes.c_uint8,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_new_multisig_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_participants_from_multisig_signature.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_participants_from_multisig_signature.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_public_key_from_address.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_transact_ffi_fn_func_public_key_from_address.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_transact_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_algokit_transact_ffi_uniffi_contract_version.restype = ctypes.c_uint32
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_address_from_multisig_signature.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_address_from_multisig_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_address_from_public_key.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_address_from_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_apply_multisig_subsignature.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_apply_multisig_subsignature.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_assign_fee.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_assign_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_calculate_fee.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_calculate_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transaction.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transactions.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_signed_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_transaction.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_transactions.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_decode_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transaction.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transactions.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_signed_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction_raw.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_transaction_raw.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_transactions.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_encode_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_estimate_transaction_size.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_estimate_transaction_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_algorand_constant.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_algorand_constant.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_encoded_transaction_type.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_encoded_transaction_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id_raw.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_get_transaction_id_raw.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_group_transactions.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_group_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_merge_multisignatures.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_merge_multisignatures.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_new_multisig_signature.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_new_multisig_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_participants_from_multisig_signature.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_participants_from_multisig_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_public_key_from_address.argtypes = (
)
_UniffiLib.uniffi_algokit_transact_ffi_checksum_func_public_key_from_address.restype = ctypes.c_uint16

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)



# Public interface members begin here.


class _UniffiFfiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)






class OnApplicationComplete(enum.Enum):
    """
    On-completion actions for app transactions.

    These values define what additional actions occur with the transaction.
"""
    
    NO_OP = 0
    """
    NoOp indicates that an app transaction will simply call its
    approval program without any additional action.
"""
    
    OPT_IN = 1
    """
    OptIn indicates that an app transaction will allocate some
    local state for the app in the sender's account.
"""
    
    CLOSE_OUT = 2
    """
    CloseOut indicates that an app transaction will deallocate
    some local state for the app from the user's account.
"""
    
    CLEAR_STATE = 3
    """
    ClearState is similar to CloseOut, but may never fail. This
    allows users to reclaim their minimum balance from an app
    they no longer wish to opt in to.
"""
    
    UPDATE_APPLICATION = 4
    """
    UpdateApplication indicates that an app transaction will
    update the approval program and clear state program for the app.
"""
    
    DELETE_APPLICATION = 5
    """
    DeleteApplication indicates that an app transaction will
    delete the app parameters for the app from the creator's
    balance record.
"""
    


class _UniffiFfiConverterTypeOnApplicationComplete(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OnApplicationComplete.NO_OP
        if variant == 2:
            return OnApplicationComplete.OPT_IN
        if variant == 3:
            return OnApplicationComplete.CLOSE_OUT
        if variant == 4:
            return OnApplicationComplete.CLEAR_STATE
        if variant == 5:
            return OnApplicationComplete.UPDATE_APPLICATION
        if variant == 6:
            return OnApplicationComplete.DELETE_APPLICATION
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == OnApplicationComplete.NO_OP:
            return
        if value == OnApplicationComplete.OPT_IN:
            return
        if value == OnApplicationComplete.CLOSE_OUT:
            return
        if value == OnApplicationComplete.CLEAR_STATE:
            return
        if value == OnApplicationComplete.UPDATE_APPLICATION:
            return
        if value == OnApplicationComplete.DELETE_APPLICATION:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == OnApplicationComplete.NO_OP:
            buf.write_i32(1)
        if value == OnApplicationComplete.OPT_IN:
            buf.write_i32(2)
        if value == OnApplicationComplete.CLOSE_OUT:
            buf.write_i32(3)
        if value == OnApplicationComplete.CLEAR_STATE:
            buf.write_i32(4)
        if value == OnApplicationComplete.UPDATE_APPLICATION:
            buf.write_i32(5)
        if value == OnApplicationComplete.DELETE_APPLICATION:
            buf.write_i32(6)



class _UniffiFfiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

class _UniffiFfiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

@dataclass
class StateSchema:
    """
    Schema for app state storage.

    Defines the maximum number of values that may be stored in app
    key/value storage for both global and local state.
"""
    def __init__(self, *, num_uints:int, num_byte_slices:int):
        self.num_uints = num_uints
        self.num_byte_slices = num_byte_slices
        
        

    
    def __str__(self):
        return "StateSchema(num_uints={}, num_byte_slices={})".format(self.num_uints, self.num_byte_slices)
    def __eq__(self, other):
        if self.num_uints != other.num_uints:
            return False
        if self.num_byte_slices != other.num_byte_slices:
            return False
        return True

class _UniffiFfiConverterTypeStateSchema(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateSchema(
            num_uints=_UniffiFfiConverterUInt32.read(buf),
            num_byte_slices=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt32.check_lower(value.num_uints)
        _UniffiFfiConverterUInt32.check_lower(value.num_byte_slices)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt32.write(value.num_uints, buf)
        _UniffiFfiConverterUInt32.write(value.num_byte_slices, buf)

class _UniffiFfiConverterOptionalTypeStateSchema(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeStateSchema.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeStateSchema.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeStateSchema.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterBytes.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiFfiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterString.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterUInt64.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class BoxReference:
    """
    Box reference for app call transactions.

    References a specific box that should be made available for the runtime
    of the program.
"""
    def __init__(self, *, app_id:int, name:bytes):
        self.app_id = app_id
        self.name = name
        
        

    
    def __str__(self):
        return "BoxReference(app_id={}, name={})".format(self.app_id, self.name)
    def __eq__(self, other):
        if self.app_id != other.app_id:
            return False
        if self.name != other.name:
            return False
        return True

class _UniffiFfiConverterTypeBoxReference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BoxReference(
            app_id=_UniffiFfiConverterUInt64.read(buf),
            name=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.app_id)
        _UniffiFfiConverterBytes.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.app_id, buf)
        _UniffiFfiConverterBytes.write(value.name, buf)

class _UniffiFfiConverterSequenceTypeBoxReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeBoxReference.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeBoxReference.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeBoxReference.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalSequenceTypeBoxReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceTypeBoxReference.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceTypeBoxReference.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceTypeBoxReference.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class AppCallTransactionFields:
    """
    Represents an app call transaction that interacts with Algorand Smart Contracts.

    App call transactions are used to create, update, delete, opt-in to,
    close out of, or clear state from Algorand applications (smart contracts).
"""
    def __init__(self, *, app_id:int, on_complete:OnApplicationComplete, approval_program:typing.Optional[bytes] = _DEFAULT, clear_state_program:typing.Optional[bytes] = _DEFAULT, global_state_schema:typing.Optional[StateSchema] = _DEFAULT, local_state_schema:typing.Optional[StateSchema] = _DEFAULT, extra_program_pages:typing.Optional[int] = _DEFAULT, args:typing.Optional[typing.List[bytes]] = _DEFAULT, account_references:typing.Optional[typing.List[str]] = _DEFAULT, app_references:typing.Optional[typing.List[int]] = _DEFAULT, asset_references:typing.Optional[typing.List[int]] = _DEFAULT, box_references:typing.Optional[typing.List[BoxReference]] = _DEFAULT):
        self.app_id = app_id
        self.on_complete = on_complete
        if approval_program is _DEFAULT:
            self.approval_program = None
        else:
            self.approval_program = approval_program
        if clear_state_program is _DEFAULT:
            self.clear_state_program = None
        else:
            self.clear_state_program = clear_state_program
        if global_state_schema is _DEFAULT:
            self.global_state_schema = None
        else:
            self.global_state_schema = global_state_schema
        if local_state_schema is _DEFAULT:
            self.local_state_schema = None
        else:
            self.local_state_schema = local_state_schema
        if extra_program_pages is _DEFAULT:
            self.extra_program_pages = None
        else:
            self.extra_program_pages = extra_program_pages
        if args is _DEFAULT:
            self.args = None
        else:
            self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references
        
        

    
    def __str__(self):
        return "AppCallTransactionFields(app_id={}, on_complete={}, approval_program={}, clear_state_program={}, global_state_schema={}, local_state_schema={}, extra_program_pages={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.app_id, self.on_complete, self.approval_program, self.clear_state_program, self.global_state_schema, self.local_state_schema, self.extra_program_pages, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)
    def __eq__(self, other):
        if self.app_id != other.app_id:
            return False
        if self.on_complete != other.on_complete:
            return False
        if self.approval_program != other.approval_program:
            return False
        if self.clear_state_program != other.clear_state_program:
            return False
        if self.global_state_schema != other.global_state_schema:
            return False
        if self.local_state_schema != other.local_state_schema:
            return False
        if self.extra_program_pages != other.extra_program_pages:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiFfiConverterTypeAppCallTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppCallTransactionFields(
            app_id=_UniffiFfiConverterUInt64.read(buf),
            on_complete=_UniffiFfiConverterTypeOnApplicationComplete.read(buf),
            approval_program=_UniffiFfiConverterOptionalBytes.read(buf),
            clear_state_program=_UniffiFfiConverterOptionalBytes.read(buf),
            global_state_schema=_UniffiFfiConverterOptionalTypeStateSchema.read(buf),
            local_state_schema=_UniffiFfiConverterOptionalTypeStateSchema.read(buf),
            extra_program_pages=_UniffiFfiConverterOptionalUInt32.read(buf),
            args=_UniffiFfiConverterOptionalSequenceBytes.read(buf),
            account_references=_UniffiFfiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiFfiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiFfiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiFfiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.app_id)
        _UniffiFfiConverterTypeOnApplicationComplete.check_lower(value.on_complete)
        _UniffiFfiConverterOptionalBytes.check_lower(value.approval_program)
        _UniffiFfiConverterOptionalBytes.check_lower(value.clear_state_program)
        _UniffiFfiConverterOptionalTypeStateSchema.check_lower(value.global_state_schema)
        _UniffiFfiConverterOptionalTypeStateSchema.check_lower(value.local_state_schema)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.extra_program_pages)
        _UniffiFfiConverterOptionalSequenceBytes.check_lower(value.args)
        _UniffiFfiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiFfiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiFfiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiFfiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.app_id, buf)
        _UniffiFfiConverterTypeOnApplicationComplete.write(value.on_complete, buf)
        _UniffiFfiConverterOptionalBytes.write(value.approval_program, buf)
        _UniffiFfiConverterOptionalBytes.write(value.clear_state_program, buf)
        _UniffiFfiConverterOptionalTypeStateSchema.write(value.global_state_schema, buf)
        _UniffiFfiConverterOptionalTypeStateSchema.write(value.local_state_schema, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.extra_program_pages, buf)
        _UniffiFfiConverterOptionalSequenceBytes.write(value.args, buf)
        _UniffiFfiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiFfiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiFfiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiFfiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)

class _UniffiFfiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterBoolean:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterOptionalBoolean(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBoolean.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBoolean.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBoolean.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class AssetConfigTransactionFields:
    """
    Parameters to define an asset config transaction.

    For asset creation, the asset ID field must be 0.
    For asset reconfiguration, the asset ID field must be set. Only fields manager, reserve, freeze, and clawback can be set.
    For asset destroy, the asset ID field must be set, all other fields must not be set.

    **Note:** The manager, reserve, freeze, and clawback addresses
    are immutably empty if they are not set. If manager is not set then
    all fields are immutable from that point forward.
"""
    def __init__(self, *, asset_id:int, total:typing.Optional[int] = _DEFAULT, decimals:typing.Optional[int] = _DEFAULT, default_frozen:typing.Optional[bool] = _DEFAULT, asset_name:typing.Optional[str] = _DEFAULT, unit_name:typing.Optional[str] = _DEFAULT, url:typing.Optional[str] = _DEFAULT, metadata_hash:typing.Optional[bytes] = _DEFAULT, manager:typing.Optional[str] = _DEFAULT, reserve:typing.Optional[str] = _DEFAULT, freeze:typing.Optional[str] = _DEFAULT, clawback:typing.Optional[str] = _DEFAULT):
        self.asset_id = asset_id
        if total is _DEFAULT:
            self.total = None
        else:
            self.total = total
        if decimals is _DEFAULT:
            self.decimals = None
        else:
            self.decimals = decimals
        if default_frozen is _DEFAULT:
            self.default_frozen = None
        else:
            self.default_frozen = default_frozen
        if asset_name is _DEFAULT:
            self.asset_name = None
        else:
            self.asset_name = asset_name
        if unit_name is _DEFAULT:
            self.unit_name = None
        else:
            self.unit_name = unit_name
        if url is _DEFAULT:
            self.url = None
        else:
            self.url = url
        if metadata_hash is _DEFAULT:
            self.metadata_hash = None
        else:
            self.metadata_hash = metadata_hash
        if manager is _DEFAULT:
            self.manager = None
        else:
            self.manager = manager
        if reserve is _DEFAULT:
            self.reserve = None
        else:
            self.reserve = reserve
        if freeze is _DEFAULT:
            self.freeze = None
        else:
            self.freeze = freeze
        if clawback is _DEFAULT:
            self.clawback = None
        else:
            self.clawback = clawback
        
        

    
    def __str__(self):
        return "AssetConfigTransactionFields(asset_id={}, total={}, decimals={}, default_frozen={}, asset_name={}, unit_name={}, url={}, metadata_hash={}, manager={}, reserve={}, freeze={}, clawback={})".format(self.asset_id, self.total, self.decimals, self.default_frozen, self.asset_name, self.unit_name, self.url, self.metadata_hash, self.manager, self.reserve, self.freeze, self.clawback)
    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.total != other.total:
            return False
        if self.decimals != other.decimals:
            return False
        if self.default_frozen != other.default_frozen:
            return False
        if self.asset_name != other.asset_name:
            return False
        if self.unit_name != other.unit_name:
            return False
        if self.url != other.url:
            return False
        if self.metadata_hash != other.metadata_hash:
            return False
        if self.manager != other.manager:
            return False
        if self.reserve != other.reserve:
            return False
        if self.freeze != other.freeze:
            return False
        if self.clawback != other.clawback:
            return False
        return True

class _UniffiFfiConverterTypeAssetConfigTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetConfigTransactionFields(
            asset_id=_UniffiFfiConverterUInt64.read(buf),
            total=_UniffiFfiConverterOptionalUInt64.read(buf),
            decimals=_UniffiFfiConverterOptionalUInt32.read(buf),
            default_frozen=_UniffiFfiConverterOptionalBoolean.read(buf),
            asset_name=_UniffiFfiConverterOptionalString.read(buf),
            unit_name=_UniffiFfiConverterOptionalString.read(buf),
            url=_UniffiFfiConverterOptionalString.read(buf),
            metadata_hash=_UniffiFfiConverterOptionalBytes.read(buf),
            manager=_UniffiFfiConverterOptionalString.read(buf),
            reserve=_UniffiFfiConverterOptionalString.read(buf),
            freeze=_UniffiFfiConverterOptionalString.read(buf),
            clawback=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.asset_id)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.total)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.decimals)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.default_frozen)
        _UniffiFfiConverterOptionalString.check_lower(value.asset_name)
        _UniffiFfiConverterOptionalString.check_lower(value.unit_name)
        _UniffiFfiConverterOptionalString.check_lower(value.url)
        _UniffiFfiConverterOptionalBytes.check_lower(value.metadata_hash)
        _UniffiFfiConverterOptionalString.check_lower(value.manager)
        _UniffiFfiConverterOptionalString.check_lower(value.reserve)
        _UniffiFfiConverterOptionalString.check_lower(value.freeze)
        _UniffiFfiConverterOptionalString.check_lower(value.clawback)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.asset_id, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.total, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.decimals, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.default_frozen, buf)
        _UniffiFfiConverterOptionalString.write(value.asset_name, buf)
        _UniffiFfiConverterOptionalString.write(value.unit_name, buf)
        _UniffiFfiConverterOptionalString.write(value.url, buf)
        _UniffiFfiConverterOptionalBytes.write(value.metadata_hash, buf)
        _UniffiFfiConverterOptionalString.write(value.manager, buf)
        _UniffiFfiConverterOptionalString.write(value.reserve, buf)
        _UniffiFfiConverterOptionalString.write(value.freeze, buf)
        _UniffiFfiConverterOptionalString.write(value.clawback, buf)

@dataclass
class AssetFreezeTransactionFields:
    """
    Represents an asset freeze transaction that freezes or unfreezes asset holdings.

    Asset freeze transactions are used by the asset freeze account to control
    whether a specific account can transfer a particular asset.
"""
    def __init__(self, *, asset_id:int, freeze_target:str, frozen:bool):
        self.asset_id = asset_id
        self.freeze_target = freeze_target
        self.frozen = frozen
        
        

    
    def __str__(self):
        return "AssetFreezeTransactionFields(asset_id={}, freeze_target={}, frozen={})".format(self.asset_id, self.freeze_target, self.frozen)
    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.freeze_target != other.freeze_target:
            return False
        if self.frozen != other.frozen:
            return False
        return True

class _UniffiFfiConverterTypeAssetFreezeTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetFreezeTransactionFields(
            asset_id=_UniffiFfiConverterUInt64.read(buf),
            freeze_target=_UniffiFfiConverterString.read(buf),
            frozen=_UniffiFfiConverterBoolean.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.asset_id)
        _UniffiFfiConverterString.check_lower(value.freeze_target)
        _UniffiFfiConverterBoolean.check_lower(value.frozen)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.asset_id, buf)
        _UniffiFfiConverterString.write(value.freeze_target, buf)
        _UniffiFfiConverterBoolean.write(value.frozen, buf)

@dataclass
class AssetTransferTransactionFields:
    def __init__(self, *, asset_id:int, amount:int, receiver:str, asset_sender:typing.Optional[str] = _DEFAULT, close_remainder_to:typing.Optional[str] = _DEFAULT):
        self.asset_id = asset_id
        self.amount = amount
        self.receiver = receiver
        if asset_sender is _DEFAULT:
            self.asset_sender = None
        else:
            self.asset_sender = asset_sender
        if close_remainder_to is _DEFAULT:
            self.close_remainder_to = None
        else:
            self.close_remainder_to = close_remainder_to
        
        

    
    def __str__(self):
        return "AssetTransferTransactionFields(asset_id={}, amount={}, receiver={}, asset_sender={}, close_remainder_to={})".format(self.asset_id, self.amount, self.receiver, self.asset_sender, self.close_remainder_to)
    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.amount != other.amount:
            return False
        if self.receiver != other.receiver:
            return False
        if self.asset_sender != other.asset_sender:
            return False
        if self.close_remainder_to != other.close_remainder_to:
            return False
        return True

class _UniffiFfiConverterTypeAssetTransferTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetTransferTransactionFields(
            asset_id=_UniffiFfiConverterUInt64.read(buf),
            amount=_UniffiFfiConverterUInt64.read(buf),
            receiver=_UniffiFfiConverterString.read(buf),
            asset_sender=_UniffiFfiConverterOptionalString.read(buf),
            close_remainder_to=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.asset_id)
        _UniffiFfiConverterUInt64.check_lower(value.amount)
        _UniffiFfiConverterString.check_lower(value.receiver)
        _UniffiFfiConverterOptionalString.check_lower(value.asset_sender)
        _UniffiFfiConverterOptionalString.check_lower(value.close_remainder_to)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.asset_id, buf)
        _UniffiFfiConverterUInt64.write(value.amount, buf)
        _UniffiFfiConverterString.write(value.receiver, buf)
        _UniffiFfiConverterOptionalString.write(value.asset_sender, buf)
        _UniffiFfiConverterOptionalString.write(value.close_remainder_to, buf)

@dataclass
class HashFactory:
    def __init__(self, *, hash_type:int):
        self.hash_type = hash_type
        
        

    
    def __str__(self):
        return "HashFactory(hash_type={})".format(self.hash_type)
    def __eq__(self, other):
        if self.hash_type != other.hash_type:
            return False
        return True

class _UniffiFfiConverterTypeHashFactory(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HashFactory(
            hash_type=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.hash_type)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.hash_type, buf)

@dataclass
class MerkleArrayProof:
    def __init__(self, *, path:typing.List[bytes], hash_factory:HashFactory, tree_depth:int):
        self.path = path
        self.hash_factory = hash_factory
        self.tree_depth = tree_depth
        
        

    
    def __str__(self):
        return "MerkleArrayProof(path={}, hash_factory={}, tree_depth={})".format(self.path, self.hash_factory, self.tree_depth)
    def __eq__(self, other):
        if self.path != other.path:
            return False
        if self.hash_factory != other.hash_factory:
            return False
        if self.tree_depth != other.tree_depth:
            return False
        return True

class _UniffiFfiConverterTypeMerkleArrayProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MerkleArrayProof(
            path=_UniffiFfiConverterSequenceBytes.read(buf),
            hash_factory=_UniffiFfiConverterTypeHashFactory.read(buf),
            tree_depth=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterSequenceBytes.check_lower(value.path)
        _UniffiFfiConverterTypeHashFactory.check_lower(value.hash_factory)
        _UniffiFfiConverterUInt64.check_lower(value.tree_depth)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterSequenceBytes.write(value.path, buf)
        _UniffiFfiConverterTypeHashFactory.write(value.hash_factory, buf)
        _UniffiFfiConverterUInt64.write(value.tree_depth, buf)

@dataclass
class FalconVerifier:
    def __init__(self, *, public_key:bytes):
        self.public_key = public_key
        
        

    
    def __str__(self):
        return "FalconVerifier(public_key={})".format(self.public_key)
    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        return True

class _UniffiFfiConverterTypeFalconVerifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FalconVerifier(
            public_key=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.public_key)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.public_key, buf)

@dataclass
class FalconSignatureStruct:
    """
    Represents a signature in the merkle signature scheme using falcon signatures
    as an underlying crypto scheme. It consists of an ephemeral public key, a signature, a merkle
    verification path and an index. The merkle signature considered valid only if the Signature is
    verified under the ephemeral public key and the Merkle verification path verifies that the
    ephemeral public key is located at the given index of the tree (for the root given in the
    long-term public key). More details can be found on Algorand's spec
"""
    def __init__(self, *, signature:bytes, vector_commitment_index:int, proof:MerkleArrayProof, verifying_key:FalconVerifier):
        self.signature = signature
        self.vector_commitment_index = vector_commitment_index
        self.proof = proof
        self.verifying_key = verifying_key
        
        

    
    def __str__(self):
        return "FalconSignatureStruct(signature={}, vector_commitment_index={}, proof={}, verifying_key={})".format(self.signature, self.vector_commitment_index, self.proof, self.verifying_key)
    def __eq__(self, other):
        if self.signature != other.signature:
            return False
        if self.vector_commitment_index != other.vector_commitment_index:
            return False
        if self.proof != other.proof:
            return False
        if self.verifying_key != other.verifying_key:
            return False
        return True

class _UniffiFfiConverterTypeFalconSignatureStruct(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FalconSignatureStruct(
            signature=_UniffiFfiConverterBytes.read(buf),
            vector_commitment_index=_UniffiFfiConverterUInt64.read(buf),
            proof=_UniffiFfiConverterTypeMerkleArrayProof.read(buf),
            verifying_key=_UniffiFfiConverterTypeFalconVerifier.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.signature)
        _UniffiFfiConverterUInt64.check_lower(value.vector_commitment_index)
        _UniffiFfiConverterTypeMerkleArrayProof.check_lower(value.proof)
        _UniffiFfiConverterTypeFalconVerifier.check_lower(value.verifying_key)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.signature, buf)
        _UniffiFfiConverterUInt64.write(value.vector_commitment_index, buf)
        _UniffiFfiConverterTypeMerkleArrayProof.write(value.proof, buf)
        _UniffiFfiConverterTypeFalconVerifier.write(value.verifying_key, buf)

@dataclass
class FeeParams:
    def __init__(self, *, fee_per_byte:int, min_fee:int, extra_fee:typing.Optional[int] = _DEFAULT, max_fee:typing.Optional[int] = _DEFAULT):
        self.fee_per_byte = fee_per_byte
        self.min_fee = min_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        
        

    
    def __str__(self):
        return "FeeParams(fee_per_byte={}, min_fee={}, extra_fee={}, max_fee={})".format(self.fee_per_byte, self.min_fee, self.extra_fee, self.max_fee)
    def __eq__(self, other):
        if self.fee_per_byte != other.fee_per_byte:
            return False
        if self.min_fee != other.min_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        return True

class _UniffiFfiConverterTypeFeeParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FeeParams(
            fee_per_byte=_UniffiFfiConverterUInt64.read(buf),
            min_fee=_UniffiFfiConverterUInt64.read(buf),
            extra_fee=_UniffiFfiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiFfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.fee_per_byte)
        _UniffiFfiConverterUInt64.check_lower(value.min_fee)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.max_fee)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.fee_per_byte, buf)
        _UniffiFfiConverterUInt64.write(value.min_fee, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.max_fee, buf)

@dataclass
class HeartbeatProof:
    """
    Parameters for a heartbeat transaction proof.
"""
    def __init__(self, *, sig:bytes, pk:bytes, pk2:bytes, pk1_sig:bytes, pk2_sig:bytes):
        self.sig = sig
        self.pk = pk
        self.pk2 = pk2
        self.pk1_sig = pk1_sig
        self.pk2_sig = pk2_sig
        
        

    
    def __str__(self):
        return "HeartbeatProof(sig={}, pk={}, pk2={}, pk1_sig={}, pk2_sig={})".format(self.sig, self.pk, self.pk2, self.pk1_sig, self.pk2_sig)
    def __eq__(self, other):
        if self.sig != other.sig:
            return False
        if self.pk != other.pk:
            return False
        if self.pk2 != other.pk2:
            return False
        if self.pk1_sig != other.pk1_sig:
            return False
        if self.pk2_sig != other.pk2_sig:
            return False
        return True

class _UniffiFfiConverterTypeHeartbeatProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HeartbeatProof(
            sig=_UniffiFfiConverterBytes.read(buf),
            pk=_UniffiFfiConverterBytes.read(buf),
            pk2=_UniffiFfiConverterBytes.read(buf),
            pk1_sig=_UniffiFfiConverterBytes.read(buf),
            pk2_sig=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.sig)
        _UniffiFfiConverterBytes.check_lower(value.pk)
        _UniffiFfiConverterBytes.check_lower(value.pk2)
        _UniffiFfiConverterBytes.check_lower(value.pk1_sig)
        _UniffiFfiConverterBytes.check_lower(value.pk2_sig)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.sig, buf)
        _UniffiFfiConverterBytes.write(value.pk, buf)
        _UniffiFfiConverterBytes.write(value.pk2, buf)
        _UniffiFfiConverterBytes.write(value.pk1_sig, buf)
        _UniffiFfiConverterBytes.write(value.pk2_sig, buf)

@dataclass
class HeartbeatTransactionFields:
    """
    Parameters to define a heartbeat transaction.

    Used to maintain participation in Algorand consensus.
"""
    def __init__(self, *, address:str, proof:HeartbeatProof, seed:bytes, vote_id:bytes, key_dilution:int):
        self.address = address
        self.proof = proof
        self.seed = seed
        self.vote_id = vote_id
        self.key_dilution = key_dilution
        
        

    
    def __str__(self):
        return "HeartbeatTransactionFields(address={}, proof={}, seed={}, vote_id={}, key_dilution={})".format(self.address, self.proof, self.seed, self.vote_id, self.key_dilution)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.proof != other.proof:
            return False
        if self.seed != other.seed:
            return False
        if self.vote_id != other.vote_id:
            return False
        if self.key_dilution != other.key_dilution:
            return False
        return True

class _UniffiFfiConverterTypeHeartbeatTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HeartbeatTransactionFields(
            address=_UniffiFfiConverterString.read(buf),
            proof=_UniffiFfiConverterTypeHeartbeatProof.read(buf),
            seed=_UniffiFfiConverterBytes.read(buf),
            vote_id=_UniffiFfiConverterBytes.read(buf),
            key_dilution=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.address)
        _UniffiFfiConverterTypeHeartbeatProof.check_lower(value.proof)
        _UniffiFfiConverterBytes.check_lower(value.seed)
        _UniffiFfiConverterBytes.check_lower(value.vote_id)
        _UniffiFfiConverterUInt64.check_lower(value.key_dilution)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.address, buf)
        _UniffiFfiConverterTypeHeartbeatProof.write(value.proof, buf)
        _UniffiFfiConverterBytes.write(value.seed, buf)
        _UniffiFfiConverterBytes.write(value.vote_id, buf)
        _UniffiFfiConverterUInt64.write(value.key_dilution, buf)

@dataclass
class KeyPairAccount:
    def __init__(self, *, pub_key:bytes):
        self.pub_key = pub_key
        
        

    
    def __str__(self):
        return "KeyPairAccount(pub_key={})".format(self.pub_key)
    def __eq__(self, other):
        if self.pub_key != other.pub_key:
            return False
        return True

class _UniffiFfiConverterTypeKeyPairAccount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeyPairAccount(
            pub_key=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.pub_key)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.pub_key, buf)

@dataclass
class KeyRegistrationTransactionFields:
    def __init__(self, *, vote_key:typing.Optional[bytes] = _DEFAULT, selection_key:typing.Optional[bytes] = _DEFAULT, state_proof_key:typing.Optional[bytes] = _DEFAULT, vote_first:typing.Optional[int] = _DEFAULT, vote_last:typing.Optional[int] = _DEFAULT, vote_key_dilution:typing.Optional[int] = _DEFAULT, non_participation:typing.Optional[bool] = _DEFAULT):
        if vote_key is _DEFAULT:
            self.vote_key = None
        else:
            self.vote_key = vote_key
        if selection_key is _DEFAULT:
            self.selection_key = None
        else:
            self.selection_key = selection_key
        if state_proof_key is _DEFAULT:
            self.state_proof_key = None
        else:
            self.state_proof_key = state_proof_key
        if vote_first is _DEFAULT:
            self.vote_first = None
        else:
            self.vote_first = vote_first
        if vote_last is _DEFAULT:
            self.vote_last = None
        else:
            self.vote_last = vote_last
        if vote_key_dilution is _DEFAULT:
            self.vote_key_dilution = None
        else:
            self.vote_key_dilution = vote_key_dilution
        if non_participation is _DEFAULT:
            self.non_participation = None
        else:
            self.non_participation = non_participation
        
        

    
    def __str__(self):
        return "KeyRegistrationTransactionFields(vote_key={}, selection_key={}, state_proof_key={}, vote_first={}, vote_last={}, vote_key_dilution={}, non_participation={})".format(self.vote_key, self.selection_key, self.state_proof_key, self.vote_first, self.vote_last, self.vote_key_dilution, self.non_participation)
    def __eq__(self, other):
        if self.vote_key != other.vote_key:
            return False
        if self.selection_key != other.selection_key:
            return False
        if self.state_proof_key != other.state_proof_key:
            return False
        if self.vote_first != other.vote_first:
            return False
        if self.vote_last != other.vote_last:
            return False
        if self.vote_key_dilution != other.vote_key_dilution:
            return False
        if self.non_participation != other.non_participation:
            return False
        return True

class _UniffiFfiConverterTypeKeyRegistrationTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeyRegistrationTransactionFields(
            vote_key=_UniffiFfiConverterOptionalBytes.read(buf),
            selection_key=_UniffiFfiConverterOptionalBytes.read(buf),
            state_proof_key=_UniffiFfiConverterOptionalBytes.read(buf),
            vote_first=_UniffiFfiConverterOptionalUInt64.read(buf),
            vote_last=_UniffiFfiConverterOptionalUInt64.read(buf),
            vote_key_dilution=_UniffiFfiConverterOptionalUInt64.read(buf),
            non_participation=_UniffiFfiConverterOptionalBoolean.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalBytes.check_lower(value.vote_key)
        _UniffiFfiConverterOptionalBytes.check_lower(value.selection_key)
        _UniffiFfiConverterOptionalBytes.check_lower(value.state_proof_key)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.vote_first)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.vote_last)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.vote_key_dilution)
        _UniffiFfiConverterOptionalBoolean.check_lower(value.non_participation)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalBytes.write(value.vote_key, buf)
        _UniffiFfiConverterOptionalBytes.write(value.selection_key, buf)
        _UniffiFfiConverterOptionalBytes.write(value.state_proof_key, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.vote_first, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.vote_last, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.vote_key_dilution, buf)
        _UniffiFfiConverterOptionalBoolean.write(value.non_participation, buf)

@dataclass
class MerkleSignatureVerifier:
    def __init__(self, *, commitment:bytes, key_lifetime:int):
        self.commitment = commitment
        self.key_lifetime = key_lifetime
        
        

    
    def __str__(self):
        return "MerkleSignatureVerifier(commitment={}, key_lifetime={})".format(self.commitment, self.key_lifetime)
    def __eq__(self, other):
        if self.commitment != other.commitment:
            return False
        if self.key_lifetime != other.key_lifetime:
            return False
        return True

class _UniffiFfiConverterTypeMerkleSignatureVerifier(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MerkleSignatureVerifier(
            commitment=_UniffiFfiConverterBytes.read(buf),
            key_lifetime=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.commitment)
        _UniffiFfiConverterUInt64.check_lower(value.key_lifetime)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.commitment, buf)
        _UniffiFfiConverterUInt64.write(value.key_lifetime, buf)

class _UniffiFfiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

@dataclass
class MultisigSubsignature:
    """
    Representation of a single subsignature in a multisignature transaction.

    Each subsignature contains the participant's address and an optional signature.
"""
    def __init__(self, *, address:str, signature:typing.Optional[bytes] = _DEFAULT):
        self.address = address
        if signature is _DEFAULT:
            self.signature = None
        else:
            self.signature = signature
        
        

    
    def __str__(self):
        return "MultisigSubsignature(address={}, signature={})".format(self.address, self.signature)
    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.signature != other.signature:
            return False
        return True

class _UniffiFfiConverterTypeMultisigSubsignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultisigSubsignature(
            address=_UniffiFfiConverterString.read(buf),
            signature=_UniffiFfiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.address)
        _UniffiFfiConverterOptionalBytes.check_lower(value.signature)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.address, buf)
        _UniffiFfiConverterOptionalBytes.write(value.signature, buf)

class _UniffiFfiConverterSequenceTypeMultisigSubsignature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeMultisigSubsignature.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeMultisigSubsignature.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeMultisigSubsignature.read(buf) for i in range(count)
        ]

@dataclass
class MultisigSignature:
    """
    Representation of an Algorand multisignature signature.
"""
    def __init__(self, *, version:int, threshold:int, subsignatures:typing.List[MultisigSubsignature]):
        self.version = version
        self.threshold = threshold
        self.subsignatures = subsignatures
        
        

    
    def __str__(self):
        return "MultisigSignature(version={}, threshold={}, subsignatures={})".format(self.version, self.threshold, self.subsignatures)
    def __eq__(self, other):
        if self.version != other.version:
            return False
        if self.threshold != other.threshold:
            return False
        if self.subsignatures != other.subsignatures:
            return False
        return True

class _UniffiFfiConverterTypeMultisigSignature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MultisigSignature(
            version=_UniffiFfiConverterUInt8.read(buf),
            threshold=_UniffiFfiConverterUInt8.read(buf),
            subsignatures=_UniffiFfiConverterSequenceTypeMultisigSubsignature.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt8.check_lower(value.version)
        _UniffiFfiConverterUInt8.check_lower(value.threshold)
        _UniffiFfiConverterSequenceTypeMultisigSubsignature.check_lower(value.subsignatures)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt8.write(value.version, buf)
        _UniffiFfiConverterUInt8.write(value.threshold, buf)
        _UniffiFfiConverterSequenceTypeMultisigSubsignature.write(value.subsignatures, buf)

@dataclass
class Participant:
    """
    A Participant corresponds to an account whose AccountData.Status is Online, and for which the
    expected sigRound satisfies AccountData.VoteFirstValid <= sigRound <= AccountData.VoteLastValid.

    In the Algorand ledger, it is possible for multiple accounts to have the same PK. Thus, the PK is
    not necessarily unique among Participants. However, each account will produce a unique Participant
    struct, to avoid potential DoS attacks where one account claims to have the same VoteID PK as
    another account.
"""
    def __init__(self, *, verifier:MerkleSignatureVerifier, weight:int):
        self.verifier = verifier
        self.weight = weight
        
        

    
    def __str__(self):
        return "Participant(verifier={}, weight={})".format(self.verifier, self.weight)
    def __eq__(self, other):
        if self.verifier != other.verifier:
            return False
        if self.weight != other.weight:
            return False
        return True

class _UniffiFfiConverterTypeParticipant(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Participant(
            verifier=_UniffiFfiConverterTypeMerkleSignatureVerifier.read(buf),
            weight=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeMerkleSignatureVerifier.check_lower(value.verifier)
        _UniffiFfiConverterUInt64.check_lower(value.weight)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeMerkleSignatureVerifier.write(value.verifier, buf)
        _UniffiFfiConverterUInt64.write(value.weight, buf)

@dataclass
class PaymentTransactionFields:
    def __init__(self, *, receiver:str, amount:int, close_remainder_to:typing.Optional[str] = _DEFAULT):
        self.receiver = receiver
        self.amount = amount
        if close_remainder_to is _DEFAULT:
            self.close_remainder_to = None
        else:
            self.close_remainder_to = close_remainder_to
        
        

    
    def __str__(self):
        return "PaymentTransactionFields(receiver={}, amount={}, close_remainder_to={})".format(self.receiver, self.amount, self.close_remainder_to)
    def __eq__(self, other):
        if self.receiver != other.receiver:
            return False
        if self.amount != other.amount:
            return False
        if self.close_remainder_to != other.close_remainder_to:
            return False
        return True

class _UniffiFfiConverterTypePaymentTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentTransactionFields(
            receiver=_UniffiFfiConverterString.read(buf),
            amount=_UniffiFfiConverterUInt64.read(buf),
            close_remainder_to=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.receiver)
        _UniffiFfiConverterUInt64.check_lower(value.amount)
        _UniffiFfiConverterOptionalString.check_lower(value.close_remainder_to)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.receiver, buf)
        _UniffiFfiConverterUInt64.write(value.amount, buf)
        _UniffiFfiConverterOptionalString.write(value.close_remainder_to, buf)

@dataclass
class SigslotCommit:
    def __init__(self, *, sig:FalconSignatureStruct, lower_sig_weight:int):
        self.sig = sig
        self.lower_sig_weight = lower_sig_weight
        
        

    
    def __str__(self):
        return "SigslotCommit(sig={}, lower_sig_weight={})".format(self.sig, self.lower_sig_weight)
    def __eq__(self, other):
        if self.sig != other.sig:
            return False
        if self.lower_sig_weight != other.lower_sig_weight:
            return False
        return True

class _UniffiFfiConverterTypeSigslotCommit(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SigslotCommit(
            sig=_UniffiFfiConverterTypeFalconSignatureStruct.read(buf),
            lower_sig_weight=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeFalconSignatureStruct.check_lower(value.sig)
        _UniffiFfiConverterUInt64.check_lower(value.lower_sig_weight)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeFalconSignatureStruct.write(value.sig, buf)
        _UniffiFfiConverterUInt64.write(value.lower_sig_weight, buf)

@dataclass
class Reveal:
    """
    A single array position revealed as part of a state proof. It reveals an element of the
    signature array and the corresponding element of the participants array.
"""
    def __init__(self, *, position:int, sigslot:SigslotCommit, participant:Participant):
        self.position = position
        self.sigslot = sigslot
        self.participant = participant
        
        

    
    def __str__(self):
        return "Reveal(position={}, sigslot={}, participant={})".format(self.position, self.sigslot, self.participant)
    def __eq__(self, other):
        if self.position != other.position:
            return False
        if self.sigslot != other.sigslot:
            return False
        if self.participant != other.participant:
            return False
        return True

class _UniffiFfiConverterTypeReveal(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Reveal(
            position=_UniffiFfiConverterUInt64.read(buf),
            sigslot=_UniffiFfiConverterTypeSigslotCommit.read(buf),
            participant=_UniffiFfiConverterTypeParticipant.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt64.check_lower(value.position)
        _UniffiFfiConverterTypeSigslotCommit.check_lower(value.sigslot)
        _UniffiFfiConverterTypeParticipant.check_lower(value.participant)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt64.write(value.position, buf)
        _UniffiFfiConverterTypeSigslotCommit.write(value.sigslot, buf)
        _UniffiFfiConverterTypeParticipant.write(value.participant, buf)






class TransactionType(enum.Enum):
    
    PAYMENT = 0
    
    ASSET_TRANSFER = 1
    
    ASSET_FREEZE = 2
    
    ASSET_CONFIG = 3
    
    KEY_REGISTRATION = 4
    
    APP_CALL = 5
    
    HEARTBEAT = 6
    
    STATE_PROOF = 7
    


class _UniffiFfiConverterTypeTransactionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionType.PAYMENT
        if variant == 2:
            return TransactionType.ASSET_TRANSFER
        if variant == 3:
            return TransactionType.ASSET_FREEZE
        if variant == 4:
            return TransactionType.ASSET_CONFIG
        if variant == 5:
            return TransactionType.KEY_REGISTRATION
        if variant == 6:
            return TransactionType.APP_CALL
        if variant == 7:
            return TransactionType.HEARTBEAT
        if variant == 8:
            return TransactionType.STATE_PROOF
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TransactionType.PAYMENT:
            return
        if value == TransactionType.ASSET_TRANSFER:
            return
        if value == TransactionType.ASSET_FREEZE:
            return
        if value == TransactionType.ASSET_CONFIG:
            return
        if value == TransactionType.KEY_REGISTRATION:
            return
        if value == TransactionType.APP_CALL:
            return
        if value == TransactionType.HEARTBEAT:
            return
        if value == TransactionType.STATE_PROOF:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TransactionType.PAYMENT:
            buf.write_i32(1)
        if value == TransactionType.ASSET_TRANSFER:
            buf.write_i32(2)
        if value == TransactionType.ASSET_FREEZE:
            buf.write_i32(3)
        if value == TransactionType.ASSET_CONFIG:
            buf.write_i32(4)
        if value == TransactionType.KEY_REGISTRATION:
            buf.write_i32(5)
        if value == TransactionType.APP_CALL:
            buf.write_i32(6)
        if value == TransactionType.HEARTBEAT:
            buf.write_i32(7)
        if value == TransactionType.STATE_PROOF:
            buf.write_i32(8)



class _UniffiFfiConverterOptionalTypePaymentTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypePaymentTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypePaymentTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypePaymentTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeAssetTransferTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeAssetTransferTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeAssetTransferTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeAssetTransferTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeAssetConfigTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeAssetConfigTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeAssetConfigTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeAssetConfigTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeAppCallTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeAppCallTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeAppCallTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeAppCallTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeKeyRegistrationTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeKeyRegistrationTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeKeyRegistrationTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeKeyRegistrationTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeAssetFreezeTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeAssetFreezeTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeAssetFreezeTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeAssetFreezeTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeHeartbeatTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeHeartbeatTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeHeartbeatTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeHeartbeatTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceTypeReveal(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeReveal.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeReveal.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeReveal.read(buf) for i in range(count)
        ]

@dataclass
class StateProof:
    def __init__(self, *, sig_commit:bytes, signed_weight:int, sig_proofs:MerkleArrayProof, part_proofs:MerkleArrayProof, merkle_signature_salt_version:int, reveals:typing.List[Reveal], positions_to_reveal:typing.List[int]):
        self.sig_commit = sig_commit
        self.signed_weight = signed_weight
        self.sig_proofs = sig_proofs
        self.part_proofs = part_proofs
        self.merkle_signature_salt_version = merkle_signature_salt_version
        self.reveals = reveals
        self.positions_to_reveal = positions_to_reveal
        
        

    
    def __str__(self):
        return "StateProof(sig_commit={}, signed_weight={}, sig_proofs={}, part_proofs={}, merkle_signature_salt_version={}, reveals={}, positions_to_reveal={})".format(self.sig_commit, self.signed_weight, self.sig_proofs, self.part_proofs, self.merkle_signature_salt_version, self.reveals, self.positions_to_reveal)
    def __eq__(self, other):
        if self.sig_commit != other.sig_commit:
            return False
        if self.signed_weight != other.signed_weight:
            return False
        if self.sig_proofs != other.sig_proofs:
            return False
        if self.part_proofs != other.part_proofs:
            return False
        if self.merkle_signature_salt_version != other.merkle_signature_salt_version:
            return False
        if self.reveals != other.reveals:
            return False
        if self.positions_to_reveal != other.positions_to_reveal:
            return False
        return True

class _UniffiFfiConverterTypeStateProof(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateProof(
            sig_commit=_UniffiFfiConverterBytes.read(buf),
            signed_weight=_UniffiFfiConverterUInt64.read(buf),
            sig_proofs=_UniffiFfiConverterTypeMerkleArrayProof.read(buf),
            part_proofs=_UniffiFfiConverterTypeMerkleArrayProof.read(buf),
            merkle_signature_salt_version=_UniffiFfiConverterUInt64.read(buf),
            reveals=_UniffiFfiConverterSequenceTypeReveal.read(buf),
            positions_to_reveal=_UniffiFfiConverterSequenceUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.sig_commit)
        _UniffiFfiConverterUInt64.check_lower(value.signed_weight)
        _UniffiFfiConverterTypeMerkleArrayProof.check_lower(value.sig_proofs)
        _UniffiFfiConverterTypeMerkleArrayProof.check_lower(value.part_proofs)
        _UniffiFfiConverterUInt64.check_lower(value.merkle_signature_salt_version)
        _UniffiFfiConverterSequenceTypeReveal.check_lower(value.reveals)
        _UniffiFfiConverterSequenceUInt64.check_lower(value.positions_to_reveal)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.sig_commit, buf)
        _UniffiFfiConverterUInt64.write(value.signed_weight, buf)
        _UniffiFfiConverterTypeMerkleArrayProof.write(value.sig_proofs, buf)
        _UniffiFfiConverterTypeMerkleArrayProof.write(value.part_proofs, buf)
        _UniffiFfiConverterUInt64.write(value.merkle_signature_salt_version, buf)
        _UniffiFfiConverterSequenceTypeReveal.write(value.reveals, buf)
        _UniffiFfiConverterSequenceUInt64.write(value.positions_to_reveal, buf)

class _UniffiFfiConverterOptionalTypeStateProof(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeStateProof.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeStateProof.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeStateProof.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class StateProofMessage:
    def __init__(self, *, block_headers_commitment:bytes, voters_commitment:bytes, ln_proven_weight:int, first_attested_round:int, last_attested_round:int):
        self.block_headers_commitment = block_headers_commitment
        self.voters_commitment = voters_commitment
        self.ln_proven_weight = ln_proven_weight
        self.first_attested_round = first_attested_round
        self.last_attested_round = last_attested_round
        
        

    
    def __str__(self):
        return "StateProofMessage(block_headers_commitment={}, voters_commitment={}, ln_proven_weight={}, first_attested_round={}, last_attested_round={})".format(self.block_headers_commitment, self.voters_commitment, self.ln_proven_weight, self.first_attested_round, self.last_attested_round)
    def __eq__(self, other):
        if self.block_headers_commitment != other.block_headers_commitment:
            return False
        if self.voters_commitment != other.voters_commitment:
            return False
        if self.ln_proven_weight != other.ln_proven_weight:
            return False
        if self.first_attested_round != other.first_attested_round:
            return False
        if self.last_attested_round != other.last_attested_round:
            return False
        return True

class _UniffiFfiConverterTypeStateProofMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateProofMessage(
            block_headers_commitment=_UniffiFfiConverterBytes.read(buf),
            voters_commitment=_UniffiFfiConverterBytes.read(buf),
            ln_proven_weight=_UniffiFfiConverterUInt64.read(buf),
            first_attested_round=_UniffiFfiConverterUInt64.read(buf),
            last_attested_round=_UniffiFfiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.block_headers_commitment)
        _UniffiFfiConverterBytes.check_lower(value.voters_commitment)
        _UniffiFfiConverterUInt64.check_lower(value.ln_proven_weight)
        _UniffiFfiConverterUInt64.check_lower(value.first_attested_round)
        _UniffiFfiConverterUInt64.check_lower(value.last_attested_round)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.block_headers_commitment, buf)
        _UniffiFfiConverterBytes.write(value.voters_commitment, buf)
        _UniffiFfiConverterUInt64.write(value.ln_proven_weight, buf)
        _UniffiFfiConverterUInt64.write(value.first_attested_round, buf)
        _UniffiFfiConverterUInt64.write(value.last_attested_round, buf)

class _UniffiFfiConverterOptionalTypeStateProofMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeStateProofMessage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeStateProofMessage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeStateProofMessage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class StateProofTransactionFields:
    def __init__(self, *, state_proof_type:typing.Optional[int] = _DEFAULT, state_proof:typing.Optional[StateProof] = _DEFAULT, message:typing.Optional[StateProofMessage] = _DEFAULT):
        if state_proof_type is _DEFAULT:
            self.state_proof_type = None
        else:
            self.state_proof_type = state_proof_type
        if state_proof is _DEFAULT:
            self.state_proof = None
        else:
            self.state_proof = state_proof
        if message is _DEFAULT:
            self.message = None
        else:
            self.message = message
        
        

    
    def __str__(self):
        return "StateProofTransactionFields(state_proof_type={}, state_proof={}, message={})".format(self.state_proof_type, self.state_proof, self.message)
    def __eq__(self, other):
        if self.state_proof_type != other.state_proof_type:
            return False
        if self.state_proof != other.state_proof:
            return False
        if self.message != other.message:
            return False
        return True

class _UniffiFfiConverterTypeStateProofTransactionFields(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return StateProofTransactionFields(
            state_proof_type=_UniffiFfiConverterOptionalUInt64.read(buf),
            state_proof=_UniffiFfiConverterOptionalTypeStateProof.read(buf),
            message=_UniffiFfiConverterOptionalTypeStateProofMessage.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalUInt64.check_lower(value.state_proof_type)
        _UniffiFfiConverterOptionalTypeStateProof.check_lower(value.state_proof)
        _UniffiFfiConverterOptionalTypeStateProofMessage.check_lower(value.message)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalUInt64.write(value.state_proof_type, buf)
        _UniffiFfiConverterOptionalTypeStateProof.write(value.state_proof, buf)
        _UniffiFfiConverterOptionalTypeStateProofMessage.write(value.message, buf)

class _UniffiFfiConverterOptionalTypeStateProofTransactionFields(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeStateProofTransactionFields.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeStateProofTransactionFields.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeStateProofTransactionFields.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Transaction:
    def __init__(self, *, transaction_type:TransactionType, sender:str, fee:typing.Optional[int] = _DEFAULT, first_valid:int, last_valid:int, genesis_hash:typing.Optional[bytes], genesis_id:typing.Optional[str], note:typing.Optional[bytes] = _DEFAULT, rekey_to:typing.Optional[str] = _DEFAULT, lease:typing.Optional[bytes] = _DEFAULT, group:typing.Optional[bytes] = _DEFAULT, payment:typing.Optional[PaymentTransactionFields] = _DEFAULT, asset_transfer:typing.Optional[AssetTransferTransactionFields] = _DEFAULT, asset_config:typing.Optional[AssetConfigTransactionFields] = _DEFAULT, app_call:typing.Optional[AppCallTransactionFields] = _DEFAULT, key_registration:typing.Optional[KeyRegistrationTransactionFields] = _DEFAULT, asset_freeze:typing.Optional[AssetFreezeTransactionFields] = _DEFAULT, heartbeat:typing.Optional[HeartbeatTransactionFields] = _DEFAULT, state_proof:typing.Optional[StateProofTransactionFields] = _DEFAULT):
        self.transaction_type = transaction_type
        self.sender = sender
        if fee is _DEFAULT:
            self.fee = None
        else:
            self.fee = fee
        self.first_valid = first_valid
        self.last_valid = last_valid
        self.genesis_hash = genesis_hash
        self.genesis_id = genesis_id
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if group is _DEFAULT:
            self.group = None
        else:
            self.group = group
        if payment is _DEFAULT:
            self.payment = None
        else:
            self.payment = payment
        if asset_transfer is _DEFAULT:
            self.asset_transfer = None
        else:
            self.asset_transfer = asset_transfer
        if asset_config is _DEFAULT:
            self.asset_config = None
        else:
            self.asset_config = asset_config
        if app_call is _DEFAULT:
            self.app_call = None
        else:
            self.app_call = app_call
        if key_registration is _DEFAULT:
            self.key_registration = None
        else:
            self.key_registration = key_registration
        if asset_freeze is _DEFAULT:
            self.asset_freeze = None
        else:
            self.asset_freeze = asset_freeze
        if heartbeat is _DEFAULT:
            self.heartbeat = None
        else:
            self.heartbeat = heartbeat
        if state_proof is _DEFAULT:
            self.state_proof = None
        else:
            self.state_proof = state_proof
        
        

    
    def __str__(self):
        return "Transaction(transaction_type={}, sender={}, fee={}, first_valid={}, last_valid={}, genesis_hash={}, genesis_id={}, note={}, rekey_to={}, lease={}, group={}, payment={}, asset_transfer={}, asset_config={}, app_call={}, key_registration={}, asset_freeze={}, heartbeat={}, state_proof={})".format(self.transaction_type, self.sender, self.fee, self.first_valid, self.last_valid, self.genesis_hash, self.genesis_id, self.note, self.rekey_to, self.lease, self.group, self.payment, self.asset_transfer, self.asset_config, self.app_call, self.key_registration, self.asset_freeze, self.heartbeat, self.state_proof)
    def __eq__(self, other):
        if self.transaction_type != other.transaction_type:
            return False
        if self.sender != other.sender:
            return False
        if self.fee != other.fee:
            return False
        if self.first_valid != other.first_valid:
            return False
        if self.last_valid != other.last_valid:
            return False
        if self.genesis_hash != other.genesis_hash:
            return False
        if self.genesis_id != other.genesis_id:
            return False
        if self.note != other.note:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.lease != other.lease:
            return False
        if self.group != other.group:
            return False
        if self.payment != other.payment:
            return False
        if self.asset_transfer != other.asset_transfer:
            return False
        if self.asset_config != other.asset_config:
            return False
        if self.app_call != other.app_call:
            return False
        if self.key_registration != other.key_registration:
            return False
        if self.asset_freeze != other.asset_freeze:
            return False
        if self.heartbeat != other.heartbeat:
            return False
        if self.state_proof != other.state_proof:
            return False
        return True

class _UniffiFfiConverterTypeTransaction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Transaction(
            transaction_type=_UniffiFfiConverterTypeTransactionType.read(buf),
            sender=_UniffiFfiConverterString.read(buf),
            fee=_UniffiFfiConverterOptionalUInt64.read(buf),
            first_valid=_UniffiFfiConverterUInt64.read(buf),
            last_valid=_UniffiFfiConverterUInt64.read(buf),
            genesis_hash=_UniffiFfiConverterOptionalBytes.read(buf),
            genesis_id=_UniffiFfiConverterOptionalString.read(buf),
            note=_UniffiFfiConverterOptionalBytes.read(buf),
            rekey_to=_UniffiFfiConverterOptionalString.read(buf),
            lease=_UniffiFfiConverterOptionalBytes.read(buf),
            group=_UniffiFfiConverterOptionalBytes.read(buf),
            payment=_UniffiFfiConverterOptionalTypePaymentTransactionFields.read(buf),
            asset_transfer=_UniffiFfiConverterOptionalTypeAssetTransferTransactionFields.read(buf),
            asset_config=_UniffiFfiConverterOptionalTypeAssetConfigTransactionFields.read(buf),
            app_call=_UniffiFfiConverterOptionalTypeAppCallTransactionFields.read(buf),
            key_registration=_UniffiFfiConverterOptionalTypeKeyRegistrationTransactionFields.read(buf),
            asset_freeze=_UniffiFfiConverterOptionalTypeAssetFreezeTransactionFields.read(buf),
            heartbeat=_UniffiFfiConverterOptionalTypeHeartbeatTransactionFields.read(buf),
            state_proof=_UniffiFfiConverterOptionalTypeStateProofTransactionFields.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeTransactionType.check_lower(value.transaction_type)
        _UniffiFfiConverterString.check_lower(value.sender)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.fee)
        _UniffiFfiConverterUInt64.check_lower(value.first_valid)
        _UniffiFfiConverterUInt64.check_lower(value.last_valid)
        _UniffiFfiConverterOptionalBytes.check_lower(value.genesis_hash)
        _UniffiFfiConverterOptionalString.check_lower(value.genesis_id)
        _UniffiFfiConverterOptionalBytes.check_lower(value.note)
        _UniffiFfiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiFfiConverterOptionalBytes.check_lower(value.lease)
        _UniffiFfiConverterOptionalBytes.check_lower(value.group)
        _UniffiFfiConverterOptionalTypePaymentTransactionFields.check_lower(value.payment)
        _UniffiFfiConverterOptionalTypeAssetTransferTransactionFields.check_lower(value.asset_transfer)
        _UniffiFfiConverterOptionalTypeAssetConfigTransactionFields.check_lower(value.asset_config)
        _UniffiFfiConverterOptionalTypeAppCallTransactionFields.check_lower(value.app_call)
        _UniffiFfiConverterOptionalTypeKeyRegistrationTransactionFields.check_lower(value.key_registration)
        _UniffiFfiConverterOptionalTypeAssetFreezeTransactionFields.check_lower(value.asset_freeze)
        _UniffiFfiConverterOptionalTypeHeartbeatTransactionFields.check_lower(value.heartbeat)
        _UniffiFfiConverterOptionalTypeStateProofTransactionFields.check_lower(value.state_proof)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeTransactionType.write(value.transaction_type, buf)
        _UniffiFfiConverterString.write(value.sender, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.fee, buf)
        _UniffiFfiConverterUInt64.write(value.first_valid, buf)
        _UniffiFfiConverterUInt64.write(value.last_valid, buf)
        _UniffiFfiConverterOptionalBytes.write(value.genesis_hash, buf)
        _UniffiFfiConverterOptionalString.write(value.genesis_id, buf)
        _UniffiFfiConverterOptionalBytes.write(value.note, buf)
        _UniffiFfiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiFfiConverterOptionalBytes.write(value.lease, buf)
        _UniffiFfiConverterOptionalBytes.write(value.group, buf)
        _UniffiFfiConverterOptionalTypePaymentTransactionFields.write(value.payment, buf)
        _UniffiFfiConverterOptionalTypeAssetTransferTransactionFields.write(value.asset_transfer, buf)
        _UniffiFfiConverterOptionalTypeAssetConfigTransactionFields.write(value.asset_config, buf)
        _UniffiFfiConverterOptionalTypeAppCallTransactionFields.write(value.app_call, buf)
        _UniffiFfiConverterOptionalTypeKeyRegistrationTransactionFields.write(value.key_registration, buf)
        _UniffiFfiConverterOptionalTypeAssetFreezeTransactionFields.write(value.asset_freeze, buf)
        _UniffiFfiConverterOptionalTypeHeartbeatTransactionFields.write(value.heartbeat, buf)
        _UniffiFfiConverterOptionalTypeStateProofTransactionFields.write(value.state_proof, buf)

class _UniffiFfiConverterOptionalTypeMultisigSignature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeMultisigSignature.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeMultisigSignature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeMultisigSignature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class SignedTransaction:
    def __init__(self, *, transaction:Transaction, signature:typing.Optional[bytes] = _DEFAULT, auth_address:typing.Optional[str] = _DEFAULT, multisignature:typing.Optional[MultisigSignature] = _DEFAULT):
        self.transaction = transaction
        if signature is _DEFAULT:
            self.signature = None
        else:
            self.signature = signature
        if auth_address is _DEFAULT:
            self.auth_address = None
        else:
            self.auth_address = auth_address
        if multisignature is _DEFAULT:
            self.multisignature = None
        else:
            self.multisignature = multisignature
        
        

    
    def __str__(self):
        return "SignedTransaction(transaction={}, signature={}, auth_address={}, multisignature={})".format(self.transaction, self.signature, self.auth_address, self.multisignature)
    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.signature != other.signature:
            return False
        if self.auth_address != other.auth_address:
            return False
        if self.multisignature != other.multisignature:
            return False
        return True

class _UniffiFfiConverterTypeSignedTransaction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignedTransaction(
            transaction=_UniffiFfiConverterTypeTransaction.read(buf),
            signature=_UniffiFfiConverterOptionalBytes.read(buf),
            auth_address=_UniffiFfiConverterOptionalString.read(buf),
            multisignature=_UniffiFfiConverterOptionalTypeMultisigSignature.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeTransaction.check_lower(value.transaction)
        _UniffiFfiConverterOptionalBytes.check_lower(value.signature)
        _UniffiFfiConverterOptionalString.check_lower(value.auth_address)
        _UniffiFfiConverterOptionalTypeMultisigSignature.check_lower(value.multisignature)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeTransaction.write(value.transaction, buf)
        _UniffiFfiConverterOptionalBytes.write(value.signature, buf)
        _UniffiFfiConverterOptionalString.write(value.auth_address, buf)
        _UniffiFfiConverterOptionalTypeMultisigSignature.write(value.multisignature, buf)



# AlgoKitTransactError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AlgoKitTransactError(Exception):
    pass

_UniffiTempAlgoKitTransactError = AlgoKitTransactError

class AlgoKitTransactError:  # type: ignore
    
    class EncodingError(_UniffiTempAlgoKitTransactError):
        
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "AlgoKitTransactError.EncodingError({})".format(str(self))
    _UniffiTempAlgoKitTransactError.EncodingError = EncodingError # type: ignore
    class DecodingError(_UniffiTempAlgoKitTransactError):
        
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "AlgoKitTransactError.DecodingError({})".format(str(self))
    _UniffiTempAlgoKitTransactError.DecodingError = DecodingError # type: ignore
    class InputError(_UniffiTempAlgoKitTransactError):
        
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "AlgoKitTransactError.InputError({})".format(str(self))
    _UniffiTempAlgoKitTransactError.InputError = InputError # type: ignore
    class MsgPackError(_UniffiTempAlgoKitTransactError):
        
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "AlgoKitTransactError.MsgPackError({})".format(str(self))
    _UniffiTempAlgoKitTransactError.MsgPackError = MsgPackError # type: ignore

AlgoKitTransactError = _UniffiTempAlgoKitTransactError # type: ignore
del _UniffiTempAlgoKitTransactError


class _UniffiFfiConverterTypeAlgoKitTransactError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AlgoKitTransactError.EncodingError(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return AlgoKitTransactError.DecodingError(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return AlgoKitTransactError.InputError(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 4:
            return AlgoKitTransactError.MsgPackError(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AlgoKitTransactError.EncodingError):
            _UniffiFfiConverterString.check_lower(value.message)
            return
        if isinstance(value, AlgoKitTransactError.DecodingError):
            _UniffiFfiConverterString.check_lower(value.message)
            return
        if isinstance(value, AlgoKitTransactError.InputError):
            _UniffiFfiConverterString.check_lower(value.message)
            return
        if isinstance(value, AlgoKitTransactError.MsgPackError):
            _UniffiFfiConverterString.check_lower(value.message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AlgoKitTransactError.EncodingError):
            buf.write_i32(1)
            _UniffiFfiConverterString.write(value.message, buf)
        if isinstance(value, AlgoKitTransactError.DecodingError):
            buf.write_i32(2)
            _UniffiFfiConverterString.write(value.message, buf)
        if isinstance(value, AlgoKitTransactError.InputError):
            buf.write_i32(3)
            _UniffiFfiConverterString.write(value.message, buf)
        if isinstance(value, AlgoKitTransactError.MsgPackError):
            buf.write_i32(4)
            _UniffiFfiConverterString.write(value.message, buf)






class AlgorandConstant(enum.Enum):
    """
    Enum containing all constants used in this crate.
"""
    
    HASH_LENGTH = 0
    """
    Length of hash digests (32)
"""
    
    CHECKSUM_LENGTH = 1
    """
    Length of the checksum used in Algorand addresses (4)
"""
    
    ADDRESS_LENGTH = 2
    """
    Length of a base32-encoded Algorand address (58)
"""
    
    PUBLIC_KEY_LENGTH = 3
    """
    Length of an Algorand public key in bytes (32)
"""
    
    SECRET_KEY_LENGTH = 4
    """
    Length of an Algorand secret key in bytes (32)
"""
    
    SIGNATURE_LENGTH = 5
    """
    Length of an Algorand signature in bytes (64)
"""
    
    SIGNATURE_ENCODING_INCR_LENGTH = 6
    """
    Increment in the encoded byte size when a signature is attached to a transaction (75)
"""
    
    MAX_TX_GROUP_SIZE = 7
    """
    The maximum number of transactions in a group (16)
"""
    


class _UniffiFfiConverterTypeAlgorandConstant(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AlgorandConstant.HASH_LENGTH
        if variant == 2:
            return AlgorandConstant.CHECKSUM_LENGTH
        if variant == 3:
            return AlgorandConstant.ADDRESS_LENGTH
        if variant == 4:
            return AlgorandConstant.PUBLIC_KEY_LENGTH
        if variant == 5:
            return AlgorandConstant.SECRET_KEY_LENGTH
        if variant == 6:
            return AlgorandConstant.SIGNATURE_LENGTH
        if variant == 7:
            return AlgorandConstant.SIGNATURE_ENCODING_INCR_LENGTH
        if variant == 8:
            return AlgorandConstant.MAX_TX_GROUP_SIZE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AlgorandConstant.HASH_LENGTH:
            return
        if value == AlgorandConstant.CHECKSUM_LENGTH:
            return
        if value == AlgorandConstant.ADDRESS_LENGTH:
            return
        if value == AlgorandConstant.PUBLIC_KEY_LENGTH:
            return
        if value == AlgorandConstant.SECRET_KEY_LENGTH:
            return
        if value == AlgorandConstant.SIGNATURE_LENGTH:
            return
        if value == AlgorandConstant.SIGNATURE_ENCODING_INCR_LENGTH:
            return
        if value == AlgorandConstant.MAX_TX_GROUP_SIZE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AlgorandConstant.HASH_LENGTH:
            buf.write_i32(1)
        if value == AlgorandConstant.CHECKSUM_LENGTH:
            buf.write_i32(2)
        if value == AlgorandConstant.ADDRESS_LENGTH:
            buf.write_i32(3)
        if value == AlgorandConstant.PUBLIC_KEY_LENGTH:
            buf.write_i32(4)
        if value == AlgorandConstant.SECRET_KEY_LENGTH:
            buf.write_i32(5)
        if value == AlgorandConstant.SIGNATURE_LENGTH:
            buf.write_i32(6)
        if value == AlgorandConstant.SIGNATURE_ENCODING_INCR_LENGTH:
            buf.write_i32(7)
        if value == AlgorandConstant.MAX_TX_GROUP_SIZE:
            buf.write_i32(8)



class _UniffiFfiConverterSequenceTypeSignedTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeSignedTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeSignedTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeSignedTransaction.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeTransaction.read(buf) for i in range(count)
        ]
def address_from_multisig_signature(multisig_signature: MultisigSignature) -> str:
    """
    Returns the address of the multisignature account.

    # Errors
    /// Returns [`AlgoKitTransactError`] if the multisignature signature is invalid or the address cannot be derived.
"""
    
    _UniffiFfiConverterTypeMultisigSignature.check_lower(multisig_signature)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeMultisigSignature.lower(multisig_signature),
    )
    _uniffi_lift_return = _UniffiFfiConverterString.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_address_from_multisig_signature,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def address_from_public_key(public_key: bytes) -> str:
    
    _UniffiFfiConverterBytes.check_lower(public_key)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(public_key),
    )
    _uniffi_lift_return = _UniffiFfiConverterString.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_address_from_public_key,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def apply_multisig_subsignature(multisig_signature: MultisigSignature,participant: str,subsignature: bytes) -> MultisigSignature:
    """
    Applies a subsignature for a participant to a multisignature signature, replacing any existing signature.

    # Errors

    Returns [`AlgoKitTransactError`] if the participant address is invalid or not found, or if the signature bytes are invalid.
"""
    
    _UniffiFfiConverterTypeMultisigSignature.check_lower(multisig_signature)
    
    _UniffiFfiConverterString.check_lower(participant)
    
    _UniffiFfiConverterBytes.check_lower(subsignature)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeMultisigSignature.lower(multisig_signature),
        _UniffiFfiConverterString.lower(participant),
        _UniffiFfiConverterBytes.lower(subsignature),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeMultisigSignature.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_apply_multisig_subsignature,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def assign_fee(transaction: Transaction,fee_params: FeeParams) -> Transaction:
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    
    _UniffiFfiConverterTypeFeeParams.check_lower(fee_params)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
        _UniffiFfiConverterTypeFeeParams.lower(fee_params),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeTransaction.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_assign_fee,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def calculate_fee(transaction: Transaction,fee_params: FeeParams) -> int:
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    
    _UniffiFfiConverterTypeFeeParams.check_lower(fee_params)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
        _UniffiFfiConverterTypeFeeParams.lower(fee_params),
    )
    _uniffi_lift_return = _UniffiFfiConverterUInt64.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_calculate_fee,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def decode_signed_transaction(encoded_signed_transaction: bytes) -> SignedTransaction:
    """
    Decodes a signed transaction.

    # Parameters
    * `encoded_signed_transaction` - The MsgPack encoded signed transaction bytes

    # Returns
    The decoded SignedTransaction or an error if decoding fails.
"""
    
    _UniffiFfiConverterBytes.check_lower(encoded_signed_transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(encoded_signed_transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeSignedTransaction.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_signed_transaction,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def decode_signed_transactions(encoded_signed_transactions: typing.List[bytes]) -> typing.List[SignedTransaction]:
    """
    Decodes a collection of MsgPack bytes into a signed transaction collection.

    # Parameters
    * `encoded_signed_transactions` - A collection of MsgPack encoded bytes, each representing a signed transaction.

    # Returns
    A collection of decoded signed transactions or an error if decoding fails.
"""
    
    _UniffiFfiConverterSequenceBytes.check_lower(encoded_signed_transactions)
    _uniffi_lowered_args = (
        _UniffiFfiConverterSequenceBytes.lower(encoded_signed_transactions),
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceTypeSignedTransaction.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_signed_transactions,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def decode_transaction(encoded_tx: bytes) -> Transaction:
    """
    Decodes MsgPack bytes into a transaction.

    # Parameters
    * `encoded_tx` - MsgPack encoded bytes representing a transaction.

    # Returns
    A decoded transaction or an error if decoding fails.
"""
    
    _UniffiFfiConverterBytes.check_lower(encoded_tx)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(encoded_tx),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeTransaction.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_transaction,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def decode_transactions(encoded_txs: typing.List[bytes]) -> typing.List[Transaction]:
    """
    Decodes a collection of MsgPack bytes into a transaction collection.

    # Parameters
    * `encoded_txs` - A collection of MsgPack encoded bytes, each representing a transaction.

    # Returns
    A collection of decoded transactions or an error if decoding fails.
"""
    
    _UniffiFfiConverterSequenceBytes.check_lower(encoded_txs)
    _uniffi_lowered_args = (
        _UniffiFfiConverterSequenceBytes.lower(encoded_txs),
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceTypeTransaction.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_decode_transactions,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def encode_signed_transaction(signed_transaction: SignedTransaction) -> bytes:
    """
    Encode a signed transaction to MsgPack for sending on the network.

    This method performs canonical encoding. No domain separation prefix is applicable.

    # Parameters
    * `signed_transaction` - The signed transaction to encode

    # Returns
    The MsgPack encoded bytes or an error if encoding fails.
"""
    
    _UniffiFfiConverterTypeSignedTransaction.check_lower(signed_transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeSignedTransaction.lower(signed_transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_signed_transaction,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def encode_signed_transactions(signed_transactions: typing.List[SignedTransaction]) -> typing.List[bytes]:
    """
    Encode signed transactions to MsgPack for sending on the network.

    This method performs canonical encoding. No domain separation prefix is applicable.

    # Parameters
    * `signed_transactions` - A collection of signed transactions to encode

    # Returns
    A collection of MsgPack encoded bytes or an error if encoding fails.
"""
    
    _UniffiFfiConverterSequenceTypeSignedTransaction.check_lower(signed_transactions)
    _uniffi_lowered_args = (
        _UniffiFfiConverterSequenceTypeSignedTransaction.lower(signed_transactions),
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_signed_transactions,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def encode_transaction(transaction: Transaction) -> bytes:
    """
    Encode the transaction with the domain separation (e.g. "TX") prefix
"""
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transaction,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def encode_transaction_raw(transaction: Transaction) -> bytes:
    """
    Encode the transaction without the domain separation (e.g. "TX") prefix
    This is useful for encoding the transaction for signing with tools that automatically add "TX" prefix to the transaction bytes.
"""
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transaction_raw,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def encode_transactions(transactions: typing.List[Transaction]) -> typing.List[bytes]:
    """
    Encode transactions to MsgPack with the domain separation (e.g. "TX") prefix.

    # Parameters
    * `transactions` - A collection of transactions to encode

    # Returns
    A collection of MsgPack encoded bytes or an error if encoding fails.
"""
    
    _UniffiFfiConverterSequenceTypeTransaction.check_lower(transactions)
    _uniffi_lowered_args = (
        _UniffiFfiConverterSequenceTypeTransaction.lower(transactions),
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_encode_transactions,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def estimate_transaction_size(transaction: Transaction) -> int:
    """
    Return the size of the transaction in bytes as if it was already signed and encoded.
    This is useful for estimating the fee for the transaction.
"""
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterUInt64.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_estimate_transaction_size,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def get_algorand_constant(constant: AlgorandConstant) -> int:
    
    _UniffiFfiConverterTypeAlgorandConstant.check_lower(constant)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeAlgorandConstant.lower(constant),
    )
    _uniffi_lift_return = _UniffiFfiConverterUInt64.lift
    _uniffi_error_converter = None
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_algorand_constant,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def get_encoded_transaction_type(encoded_transaction: bytes) -> TransactionType:
    """
    Get the transaction type from the encoded transaction.
    This is particularly useful when decoding a transaction that has an unknown type
"""
    
    _UniffiFfiConverterBytes.check_lower(encoded_transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(encoded_transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeTransactionType.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_encoded_transaction_type,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def get_transaction_id(transaction: Transaction) -> str:
    """
    Get the base32 transaction ID string for a transaction.
"""
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterString.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_transaction_id,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def get_transaction_id_raw(transaction: Transaction) -> bytes:
    """
    Get the raw 32-byte transaction ID for a transaction.
"""
    
    _UniffiFfiConverterTypeTransaction.check_lower(transaction)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeTransaction.lower(transaction),
    )
    _uniffi_lift_return = _UniffiFfiConverterBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_get_transaction_id_raw,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def group_transactions(transactions: typing.List[Transaction]) -> typing.List[Transaction]:
    """
    Groups a collection of transactions by calculating and assigning the group to each transaction.
"""
    
    _UniffiFfiConverterSequenceTypeTransaction.check_lower(transactions)
    _uniffi_lowered_args = (
        _UniffiFfiConverterSequenceTypeTransaction.lower(transactions),
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceTypeTransaction.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_group_transactions,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def merge_multisignatures(multisig_signature_a: MultisigSignature,multisig_signature_b: MultisigSignature) -> MultisigSignature:
    """
    Merges two multisignature signatures, replacing signatures in the first with those from the second where present.

    # Errors

    Returns [`AlgoKitTransactError`] if the multisignature parameters or participants do not match.
"""
    
    _UniffiFfiConverterTypeMultisigSignature.check_lower(multisig_signature_a)
    
    _UniffiFfiConverterTypeMultisigSignature.check_lower(multisig_signature_b)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeMultisigSignature.lower(multisig_signature_a),
        _UniffiFfiConverterTypeMultisigSignature.lower(multisig_signature_b),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeMultisigSignature.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_merge_multisignatures,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def new_multisig_signature(version: int,threshold: int,participants: typing.List[str]) -> MultisigSignature:
    """
    Creates an empty multisignature signature from a list of participant addresses.

    # Errors

    Returns [`AlgoKitTransactError`] if any address is invalid or the multisignature parameters are invalid.
"""
    
    _UniffiFfiConverterUInt8.check_lower(version)
    
    _UniffiFfiConverterUInt8.check_lower(threshold)
    
    _UniffiFfiConverterSequenceString.check_lower(participants)
    _uniffi_lowered_args = (
        _UniffiFfiConverterUInt8.lower(version),
        _UniffiFfiConverterUInt8.lower(threshold),
        _UniffiFfiConverterSequenceString.lower(participants),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeMultisigSignature.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_new_multisig_signature,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def participants_from_multisig_signature(multisig_signature: MultisigSignature) -> typing.List[str]:
    """
    Returns the list of participant addresses from a multisignature signature.

    # Errors
    Returns [`AlgoKitTransactError`] if the multisignature is invalid.
"""
    
    _UniffiFfiConverterTypeMultisigSignature.check_lower(multisig_signature)
    _uniffi_lowered_args = (
        _UniffiFfiConverterTypeMultisigSignature.lower(multisig_signature),
    )
    _uniffi_lift_return = _UniffiFfiConverterSequenceString.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_participants_from_multisig_signature,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def public_key_from_address(address: str) -> bytes:
    
    _UniffiFfiConverterString.check_lower(address)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(address),
    )
    _uniffi_lift_return = _UniffiFfiConverterBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeAlgoKitTransactError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_algokit_transact_ffi_fn_func_public_key_from_address,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)

__all__ = [
    "InternalError",
    "OnApplicationComplete",
    "TransactionType",
    "AlgoKitTransactError",
    "AlgorandConstant",
    "StateSchema",
    "BoxReference",
    "AppCallTransactionFields",
    "AssetConfigTransactionFields",
    "AssetFreezeTransactionFields",
    "AssetTransferTransactionFields",
    "HashFactory",
    "MerkleArrayProof",
    "FalconVerifier",
    "FalconSignatureStruct",
    "FeeParams",
    "HeartbeatProof",
    "HeartbeatTransactionFields",
    "KeyPairAccount",
    "KeyRegistrationTransactionFields",
    "MerkleSignatureVerifier",
    "MultisigSubsignature",
    "MultisigSignature",
    "Participant",
    "PaymentTransactionFields",
    "SigslotCommit",
    "Reveal",
    "StateProof",
    "StateProofMessage",
    "StateProofTransactionFields",
    "Transaction",
    "SignedTransaction",
    "address_from_multisig_signature",
    "address_from_public_key",
    "apply_multisig_subsignature",
    "assign_fee",
    "calculate_fee",
    "decode_signed_transaction",
    "decode_signed_transactions",
    "decode_transaction",
    "decode_transactions",
    "encode_signed_transaction",
    "encode_signed_transactions",
    "encode_transaction",
    "encode_transaction_raw",
    "encode_transactions",
    "estimate_transaction_size",
    "get_algorand_constant",
    "get_encoded_transaction_type",
    "get_transaction_id",
    "get_transaction_id_raw",
    "group_transactions",
    "merge_multisignatures",
    "new_multisig_signature",
    "participants_from_multisig_signature",
    "public_key_from_address",
]