

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform
from .algod_client_ffi import AlgodClient
from .algod_client_ffi import _UniffiConverterTypeAlgodClient
from algokit_transact.algokit_transact_ffi import BoxReference
from algokit_transact.algokit_transact_ffi import OnApplicationComplete
from algokit_transact.algokit_transact_ffi import SignedTransaction
from algokit_transact.algokit_transact_ffi import StateSchema
from algokit_transact.algokit_transact_ffi import Transaction
from algokit_transact.algokit_transact_ffi import _UniffiConverterTypeBoxReference
from algokit_transact.algokit_transact_ffi import _UniffiConverterTypeOnApplicationComplete
from algokit_transact.algokit_transact_ffi import _UniffiConverterTypeSignedTransaction
from algokit_transact.algokit_transact_ffi import _UniffiConverterTypeStateSchema
from algokit_transact.algokit_transact_ffi import _UniffiConverterTypeTransaction
from .algod_client_ffi import _UniffiRustBuffer as _UniffiRustBufferAlgodClient
from algokit_transact.algokit_transact_ffi import _UniffiRustBuffer as _UniffiRustBufferBoxReference
from algokit_transact.algokit_transact_ffi import _UniffiRustBuffer as _UniffiRustBufferOnApplicationComplete
from algokit_transact.algokit_transact_ffi import _UniffiRustBuffer as _UniffiRustBufferSignedTransaction
from algokit_transact.algokit_transact_ffi import _UniffiRustBuffer as _UniffiRustBufferStateSchema
from algokit_transact.algokit_transact_ffi import _UniffiRustBuffer as _UniffiRustBufferTransaction

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("algokit_utils_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_algokit_utils_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_algokit_utils_ffi_checksum_func_run_asset_freeze_test_suite() != 41910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abitype_decode() != 43112:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abitype_encode() != 29884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abitype_to_string() != 26503:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_address() != 53833:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_array() != 62046:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_big_uint() != 28498:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_bool() != 17399:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_byte() != 8517:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_bytes() != 15468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_string() != 50389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_struct_fields() != 24818:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_uint() != 7369:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_send_transaction() != 64461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_account_info() != 63910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_transaction_info() != 27499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_wait_for_confirmation() != 52081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_suggested_params() != 64343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_call() != 51911:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_call_method_call() != 36668:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_create() != 56716:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_create_method_call() != 50609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_delete() != 23969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_delete_method_call() != 27392:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_update() != 38920:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_update_method_call() != 19710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_clawback() != 59332:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_config() != 31176:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_create() != 42067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_destroy() != 61779:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_freeze() != 44087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_opt_in() != 47319:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_opt_out() != 20451:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_transfer() != 45589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_unfreeze() != 12930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_add_payment() != 9188:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_build() != 13184:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composer_send() != 25144:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composerfactory_create_composer() != 54297:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_build() != 44731:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_send() != 55817:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_payment() != 9728:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_create() != 16612:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_reconfigure() != 38593:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_destroy() != 54412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_freeze() != 48063:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_unfreeze() != 22454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_transfer() != 62360:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_opt_in() != 58817:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_opt_out() != 58837:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_clawback() != 13804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_create() != 54450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_call() != 18831:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_update() != 228:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_delete() != 6934:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_call_method_call() != 37092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_create_method_call() != 59763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_update_method_call() != 734:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_delete_method_call() != 51613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_testfixture_create_test_asset() != 14898:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_testfixture_dispenser_account() != 40996:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_testfixture_fund_account() != 22253:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_testfixture_generate_account() != 52762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_transactionsigner_sign_transactions() != 55831:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_transactionsigner_sign_transaction() != 13641:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_transactionsignergetter_get_signer() != 32889:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_method_transactionsignergetter_register_account() != 12126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_address() != 44199:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_bytes() != 1923:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_string() != 18520:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_uint64() != 50769:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_bool() != 39758:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_byte() != 733:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_dynamic_array() != 19770:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_from_string() != 23247:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_static_array() != 25281:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_string() != 37013:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_struct_fields() != 18128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_tuple() != 31991:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_ufixed() != 24385:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_uint() != 8781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_address() != 33806:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_array() != 46650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_biguint() != 27203:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_bool() != 48288:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_byte() != 47270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_bytes() != 39637:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_string() != 16860:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_struct_fields() != 65262:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_uint() != 11616:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_composer_new() != 54325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_defaultcomposerfactory_new() != 5145:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_structfield_new() != 45077:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_algokit_utils_ffi_checksum_constructor_testfixture_new() != 47088:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_FACTORY_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.POINTER(ctypes.c_void_p),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD2 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD3 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD4 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD5 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD6 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD7 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD9 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD10 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD11 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD12 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD13 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD14 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD15 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD17 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD18 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD19 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBufferTransaction,_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER,ctypes.c_uint64,ctypes.POINTER(_UniffiForeignFuture),
)
_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_GETTER_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.POINTER(ctypes.c_void_p),
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_GETTER_METHOD1 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,_UniffiRustBuffer,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
class _UniffiVTableCallbackInterfaceAlgodClientTrait(ctypes.Structure):
    _fields_ = [
        ("send_transaction", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD0),
        ("get_account_info", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD1),
        ("get_transaction_info", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD2),
        ("wait_for_confirmation", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD3),
        ("get_suggested_params", _UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD4),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceComposerFactory(ctypes.Structure):
    _fields_ = [
        ("create_composer", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_FACTORY_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceComposerTrait(ctypes.Structure):
    _fields_ = [
        ("build", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD0),
        ("send", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD1),
        ("add_payment", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD2),
        ("add_asset_create", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD3),
        ("add_asset_reconfigure", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD4),
        ("add_asset_destroy", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD5),
        ("add_asset_freeze", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD6),
        ("add_asset_unfreeze", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD7),
        ("add_asset_transfer", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD8),
        ("add_asset_opt_in", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD9),
        ("add_asset_opt_out", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD10),
        ("add_asset_clawback", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD11),
        ("add_app_create", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD12),
        ("add_app_call", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD13),
        ("add_app_update", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD14),
        ("add_app_delete", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD15),
        ("add_app_call_method_call", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD16),
        ("add_app_create_method_call", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD17),
        ("add_app_update_method_call", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD18),
        ("add_app_delete_method_call", _UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD19),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceTransactionSigner(ctypes.Structure):
    _fields_ = [
        ("sign_transactions", _UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_METHOD0),
        ("sign_transaction", _UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceTransactionSignerGetter(ctypes.Structure):
    _fields_ = [
        ("get_signer", _UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_GETTER_METHOD0),
        ("register_account", _UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_GETTER_METHOD1),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abistruct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abistruct.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abistruct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abistruct.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abitype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abitype.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abitype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abitype.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_address.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_bytes.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_string.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_uint64.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_uint64.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_bool.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_bool.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_byte.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_byte.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_dynamic_array.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_dynamic_array.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_static_array.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_static_array.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_string.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_struct_fields.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_struct_fields.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_tuple.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_tuple.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_ufixed.argtypes = (
    ctypes.c_uint16,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_ufixed.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_uint.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_uint.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_decode.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_decode.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_encode.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_encode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_to_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_to_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abivalue.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abivalue.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abivalue.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abivalue.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_address.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_array.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_array.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_biguint.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_biguint.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_bool.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_bool.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_byte.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_byte.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_struct_fields.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_struct_fields.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_uint.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_uint.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_array.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_array.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_big_uint.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_big_uint.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_bool.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_bool.restype = ctypes.c_int8
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_byte.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_byte.restype = ctypes.c_uint8
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_struct_fields.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_struct_fields.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_uint.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_uint.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_algodclienttrait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_algodclienttrait.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_algodclienttrait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_algodclienttrait.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_algodclienttrait.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceAlgodClientTrait),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_algodclienttrait.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_send_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_send_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_account_info.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_account_info.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_transaction_info.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_transaction_info.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_wait_for_confirmation.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_wait_for_confirmation.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_suggested_params.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_suggested_params.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composer.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composer.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_composer_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_composer_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_call.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_call_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_call_method_call.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_create.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_create.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_create_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_create_method_call.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_delete.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_delete.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_delete_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_delete_method_call.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_update.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_update.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_update_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_update_method_call.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_clawback.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_clawback.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_config.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_config.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_create.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_create.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_destroy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_destroy.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_freeze.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_freeze.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_opt_in.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_opt_in.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_opt_out.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_opt_out.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_transfer.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_transfer.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_unfreeze.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_unfreeze.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_payment.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_build.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_build.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_send.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_send.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composerfactory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composerfactory.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composerfactory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composerfactory.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_composerfactory.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceComposerFactory),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_composerfactory.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composerfactory_create_composer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composerfactory_create_composer.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composertrait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composertrait.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composertrait.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composertrait.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_composertrait.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceComposerTrait),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_composertrait.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_build.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_build.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_send.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_send.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_payment.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_payment.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_create.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_create.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_reconfigure.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_reconfigure.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_destroy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_destroy.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_freeze.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_freeze.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_unfreeze.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_unfreeze.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_transfer.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_transfer.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_opt_in.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_opt_in.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_opt_out.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_opt_out.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_clawback.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_clawback.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_create.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_create.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_call.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_update.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_update.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_delete.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_delete.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_call_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_call_method_call.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_create_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_create_method_call.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_update_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_update_method_call.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_delete_method_call.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_delete_method_call.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_defaultcomposerfactory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_defaultcomposerfactory.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_defaultcomposerfactory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_defaultcomposerfactory.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_defaultcomposerfactory_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_defaultcomposerfactory_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_structfield.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_structfield.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_structfield.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_structfield.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_structfield_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_structfield_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_testfixture.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_testfixture.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_testfixture.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_testfixture.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_testfixture_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_testfixture_new.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_create_test_asset.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_create_test_asset.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_dispenser_account.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_dispenser_account.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_fund_account.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_fund_account.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_generate_account.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_generate_account.restype = _UniffiRustBuffer
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_transactionsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_transactionsigner.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_transactionsigner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_transactionsigner.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_transactionsigner.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceTransactionSigner),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_transactionsigner.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsigner_sign_transactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsigner_sign_transactions.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsigner_sign_transaction.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferTransaction,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsigner_sign_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_transactionsignergetter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_transactionsignergetter.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_transactionsignergetter.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_free_transactionsignergetter.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_transactionsignergetter.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceTransactionSignerGetter),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_transactionsignergetter.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsignergetter_get_signer.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsignergetter_get_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsignergetter_register_account.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsignergetter_register_account.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_fn_func_run_asset_freeze_test_suite.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_algokit_utils_ffi_fn_func_run_asset_freeze_test_suite.restype = ctypes.c_uint64
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_algokit_utils_ffi_checksum_func_run_asset_freeze_test_suite.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_func_run_asset_freeze_test_suite.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abitype_decode.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abitype_decode.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abitype_encode.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abitype_encode.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abitype_to_string.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abitype_to_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_address.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_array.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_array.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_big_uint.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_big_uint.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_bool.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_byte.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_byte.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_bytes.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_string.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_struct_fields.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_struct_fields.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_uint.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_abivalue_get_uint.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_send_transaction.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_send_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_account_info.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_account_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_transaction_info.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_transaction_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_wait_for_confirmation.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_wait_for_confirmation.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_suggested_params.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_algodclienttrait_get_suggested_params.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_call_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_call_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_create.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_create_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_create_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_delete.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_delete_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_delete_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_update.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_update_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_app_update_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_clawback.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_clawback.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_config.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_create.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_destroy.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_destroy.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_freeze.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_freeze.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_opt_in.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_opt_in.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_opt_out.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_opt_out.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_transfer.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_transfer.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_unfreeze.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_asset_unfreeze.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_payment.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_add_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_build.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_send.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composer_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composerfactory_create_composer.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composerfactory_create_composer.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_build.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_send.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_payment.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_create.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_reconfigure.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_reconfigure.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_destroy.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_destroy.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_freeze.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_freeze.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_unfreeze.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_unfreeze.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_transfer.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_transfer.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_opt_in.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_opt_in.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_opt_out.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_opt_out.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_clawback.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_asset_clawback.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_create.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_update.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_delete.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_delete.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_call_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_call_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_create_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_create_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_update_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_update_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_delete_method_call.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_composertrait_add_app_delete_method_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_create_test_asset.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_create_test_asset.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_dispenser_account.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_dispenser_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_fund_account.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_fund_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_generate_account.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_testfixture_generate_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsigner_sign_transactions.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsigner_sign_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsigner_sign_transaction.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsigner_sign_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsignergetter_get_signer.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsignergetter_get_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsignergetter_register_account.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_method_transactionsignergetter_register_account.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_address.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_bytes.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_string.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_uint64.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_avm_uint64.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_bool.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_byte.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_byte.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_dynamic_array.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_dynamic_array.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_from_string.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_static_array.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_static_array.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_string.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_struct_fields.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_struct_fields.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_tuple.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_tuple.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_ufixed.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_ufixed.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_uint.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abitype_uint.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_address.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_array.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_array.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_biguint.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_biguint.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_bool.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_byte.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_byte.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_bytes.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_string.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_struct_fields.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_struct_fields.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_uint.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_abivalue_uint.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_composer_new.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_composer_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_defaultcomposerfactory_new.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_defaultcomposerfactory_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_structfield_new.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_structfield_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_testfixture_new.argtypes = (
)
_UniffiLib.uniffi_algokit_utils_ffi_checksum_constructor_testfixture_new.restype = ctypes.c_uint16
_UniffiLib.ffi_algokit_utils_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_algokit_utils_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.
# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)


























class AbiMethod:
    name: "str"
    """
    The name of the method.
    """

    args: "typing.List[AbiMethodArg]"
    """
    A list of the method's arguments.
    """

    returns: "typing.Optional[AbiType]"
    """
    The return type of the method, or `None` if the method does not return a value.
    """

    description: "typing.Optional[str]"
    """
    An optional description of the method.
    """

    def __init__(self, *, name: "str", args: "typing.List[AbiMethodArg]", returns: "typing.Optional[AbiType]", description: "typing.Optional[str]"):
        self.name = name
        self.args = args
        self.returns = returns
        self.description = description

    def __str__(self):
        return "AbiMethod(name={}, args={}, returns={}, description={})".format(self.name, self.args, self.returns, self.description)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.args != other.args:
            return False
        if self.returns != other.returns:
            return False
        if self.description != other.description:
            return False
        return True

class _UniffiConverterTypeAbiMethod(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AbiMethod(
            name=_UniffiConverterString.read(buf),
            args=_UniffiConverterSequenceTypeAbiMethodArg.read(buf),
            returns=_UniffiConverterOptionalTypeAbiType.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterSequenceTypeAbiMethodArg.check_lower(value.args)
        _UniffiConverterOptionalTypeAbiType.check_lower(value.returns)
        _UniffiConverterOptionalString.check_lower(value.description)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterSequenceTypeAbiMethodArg.write(value.args, buf)
        _UniffiConverterOptionalTypeAbiType.write(value.returns, buf)
        _UniffiConverterOptionalString.write(value.description, buf)


class AbiMethodArg:
    arg_type: "AbiMethodArgType"
    """
    The type of the argument.
    """

    name: "typing.Optional[str]"
    """
    An optional name for the argument.
    """

    description: "typing.Optional[str]"
    """
    An optional description of the argument.
    """

    def __init__(self, *, arg_type: "AbiMethodArgType", name: "typing.Optional[str]", description: "typing.Optional[str]"):
        self.arg_type = arg_type
        self.name = name
        self.description = description

    def __str__(self):
        return "AbiMethodArg(arg_type={}, name={}, description={})".format(self.arg_type, self.name, self.description)

    def __eq__(self, other):
        if self.arg_type != other.arg_type:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        return True

class _UniffiConverterTypeAbiMethodArg(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AbiMethodArg(
            arg_type=_UniffiConverterTypeAbiMethodArgType.read(buf),
            name=_UniffiConverterOptionalString.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAbiMethodArgType.check_lower(value.arg_type)
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.description)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAbiMethodArgType.write(value.arg_type, buf)
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.description, buf)


class AccountCloseParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    close_remainder_to: "str"
    """
    Close the sender account and send the remaining balance to this address

    *Warning:* Be careful this can lead to loss of funds if not used correctly.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, close_remainder_to: "str"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.close_remainder_to = close_remainder_to

    def __str__(self):
        return "AccountCloseParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, close_remainder_to={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.close_remainder_to)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.close_remainder_to != other.close_remainder_to:
            return False
        return True

class _UniffiConverterTypeAccountCloseParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountCloseParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            close_remainder_to=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterString.check_lower(value.close_remainder_to)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterString.write(value.close_remainder_to, buf)


class AccountInfo:
    balance: "int"
    min_balance: "int"
    created_apps: "typing.List[int]"
    created_assets: "typing.List[int]"
    def __init__(self, *, balance: "int", min_balance: "int", created_apps: "typing.List[int]", created_assets: "typing.List[int]"):
        self.balance = balance
        self.min_balance = min_balance
        self.created_apps = created_apps
        self.created_assets = created_assets

    def __str__(self):
        return "AccountInfo(balance={}, min_balance={}, created_apps={}, created_assets={})".format(self.balance, self.min_balance, self.created_apps, self.created_assets)

    def __eq__(self, other):
        if self.balance != other.balance:
            return False
        if self.min_balance != other.min_balance:
            return False
        if self.created_apps != other.created_apps:
            return False
        if self.created_assets != other.created_assets:
            return False
        return True

class _UniffiConverterTypeAccountInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccountInfo(
            balance=_UniffiConverterUInt64.read(buf),
            min_balance=_UniffiConverterUInt64.read(buf),
            created_apps=_UniffiConverterSequenceUInt64.read(buf),
            created_assets=_UniffiConverterSequenceUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.balance)
        _UniffiConverterUInt64.check_lower(value.min_balance)
        _UniffiConverterSequenceUInt64.check_lower(value.created_apps)
        _UniffiConverterSequenceUInt64.check_lower(value.created_assets)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.balance, buf)
        _UniffiConverterUInt64.write(value.min_balance, buf)
        _UniffiConverterSequenceUInt64.write(value.created_apps, buf)
        _UniffiConverterSequenceUInt64.write(value.created_assets, buf)


class AppCallMethodCallParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    app_id: "int"
    """
    ID of the app being called.
    """

    method: "AbiMethod"
    """
    The ABI method to call.
    """

    args: "typing.List[AppMethodCallArg]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    on_complete: "OnApplicationComplete"
    """
    Defines what additional actions occur with the transaction.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, app_id: "int", method: "AbiMethod", args: "typing.List[AppMethodCallArg]", account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT, on_complete: "OnApplicationComplete"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.app_id = app_id
        self.method = method
        self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references
        self.on_complete = on_complete

    def __str__(self):
        return "AppCallMethodCallParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, app_id={}, method={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={}, on_complete={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.app_id, self.method, self.args, self.account_references, self.app_references, self.asset_references, self.box_references, self.on_complete)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.app_id != other.app_id:
            return False
        if self.method != other.method:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        if self.on_complete != other.on_complete:
            return False
        return True

class _UniffiConverterTypeAppCallMethodCallParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppCallMethodCallParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            method=_UniffiConverterTypeAbiMethod.read(buf),
            args=_UniffiConverterSequenceTypeAppMethodCallArg.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
            on_complete=_UniffiConverterTypeOnApplicationComplete.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterTypeAbiMethod.check_lower(value.method)
        _UniffiConverterSequenceTypeAppMethodCallArg.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)
        _UniffiConverterTypeOnApplicationComplete.check_lower(value.on_complete)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterTypeAbiMethod.write(value.method, buf)
        _UniffiConverterSequenceTypeAppMethodCallArg.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)
        _UniffiConverterTypeOnApplicationComplete.write(value.on_complete, buf)


class AppCallParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    app_id: "int"
    """
    ID of the app being called.
    """

    on_complete: "OnApplicationComplete"
    """
    Defines what additional actions occur with the transaction.
    """

    args: "typing.Optional[typing.List[bytes]]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, app_id: "int", on_complete: "OnApplicationComplete", args: "typing.Optional[typing.List[bytes]]" = _DEFAULT, account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.app_id = app_id
        self.on_complete = on_complete
        if args is _DEFAULT:
            self.args = None
        else:
            self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppCallParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, app_id={}, on_complete={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.app_id, self.on_complete, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.app_id != other.app_id:
            return False
        if self.on_complete != other.on_complete:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppCallParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppCallParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            on_complete=_UniffiConverterTypeOnApplicationComplete.read(buf),
            args=_UniffiConverterOptionalSequenceBytes.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterTypeOnApplicationComplete.check_lower(value.on_complete)
        _UniffiConverterOptionalSequenceBytes.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterTypeOnApplicationComplete.write(value.on_complete, buf)
        _UniffiConverterOptionalSequenceBytes.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AppCreateMethodCallParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    on_complete: "OnApplicationComplete"
    """
    Defines what additional actions occur with the transaction.
    """

    approval_program: "bytes"
    """
    Logic executed for every app call transaction, except when
    on-completion is set to "clear".

    Approval programs may reject the transaction.
    """

    clear_state_program: "bytes"
    """
    Logic executed for app call transactions with on-completion set to "clear".

    Clear state programs cannot reject the transaction.
    """

    global_state_schema: "typing.Optional[StateSchema]"
    """
    Holds the maximum number of global state values.

    This cannot be changed after creation.
    """

    local_state_schema: "typing.Optional[StateSchema]"
    """
    Holds the maximum number of local state values.

    This cannot be changed after creation.
    """

    extra_program_pages: "typing.Optional[int]"
    """
    Number of additional pages allocated to the app's approval
    and clear state programs.

    Each extra program page is 2048 bytes. The sum of approval program
    and clear state program may not exceed 2048*(1+extra_program_pages) bytes.
    Currently, the maximum value is 3.
    This cannot be changed after creation.
    """

    method: "AbiMethod"
    """
    The ABI method to call.
    """

    args: "typing.List[AppMethodCallArg]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, on_complete: "OnApplicationComplete", approval_program: "bytes", clear_state_program: "bytes", global_state_schema: "typing.Optional[StateSchema]" = _DEFAULT, local_state_schema: "typing.Optional[StateSchema]" = _DEFAULT, extra_program_pages: "typing.Optional[int]" = _DEFAULT, method: "AbiMethod", args: "typing.List[AppMethodCallArg]", account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.on_complete = on_complete
        self.approval_program = approval_program
        self.clear_state_program = clear_state_program
        if global_state_schema is _DEFAULT:
            self.global_state_schema = None
        else:
            self.global_state_schema = global_state_schema
        if local_state_schema is _DEFAULT:
            self.local_state_schema = None
        else:
            self.local_state_schema = local_state_schema
        if extra_program_pages is _DEFAULT:
            self.extra_program_pages = None
        else:
            self.extra_program_pages = extra_program_pages
        self.method = method
        self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppCreateMethodCallParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, on_complete={}, approval_program={}, clear_state_program={}, global_state_schema={}, local_state_schema={}, extra_program_pages={}, method={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.on_complete, self.approval_program, self.clear_state_program, self.global_state_schema, self.local_state_schema, self.extra_program_pages, self.method, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.on_complete != other.on_complete:
            return False
        if self.approval_program != other.approval_program:
            return False
        if self.clear_state_program != other.clear_state_program:
            return False
        if self.global_state_schema != other.global_state_schema:
            return False
        if self.local_state_schema != other.local_state_schema:
            return False
        if self.extra_program_pages != other.extra_program_pages:
            return False
        if self.method != other.method:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppCreateMethodCallParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppCreateMethodCallParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            on_complete=_UniffiConverterTypeOnApplicationComplete.read(buf),
            approval_program=_UniffiConverterBytes.read(buf),
            clear_state_program=_UniffiConverterBytes.read(buf),
            global_state_schema=_UniffiConverterOptionalTypeStateSchema.read(buf),
            local_state_schema=_UniffiConverterOptionalTypeStateSchema.read(buf),
            extra_program_pages=_UniffiConverterOptionalUInt64.read(buf),
            method=_UniffiConverterTypeAbiMethod.read(buf),
            args=_UniffiConverterSequenceTypeAppMethodCallArg.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterTypeOnApplicationComplete.check_lower(value.on_complete)
        _UniffiConverterBytes.check_lower(value.approval_program)
        _UniffiConverterBytes.check_lower(value.clear_state_program)
        _UniffiConverterOptionalTypeStateSchema.check_lower(value.global_state_schema)
        _UniffiConverterOptionalTypeStateSchema.check_lower(value.local_state_schema)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_program_pages)
        _UniffiConverterTypeAbiMethod.check_lower(value.method)
        _UniffiConverterSequenceTypeAppMethodCallArg.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterTypeOnApplicationComplete.write(value.on_complete, buf)
        _UniffiConverterBytes.write(value.approval_program, buf)
        _UniffiConverterBytes.write(value.clear_state_program, buf)
        _UniffiConverterOptionalTypeStateSchema.write(value.global_state_schema, buf)
        _UniffiConverterOptionalTypeStateSchema.write(value.local_state_schema, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_program_pages, buf)
        _UniffiConverterTypeAbiMethod.write(value.method, buf)
        _UniffiConverterSequenceTypeAppMethodCallArg.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AppCreateParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    on_complete: "OnApplicationComplete"
    """
    Defines what additional actions occur with the transaction.
    """

    approval_program: "bytes"
    """
    Logic executed for every app call transaction, except when
    on-completion is set to "clear".

    Approval programs may reject the transaction.
    """

    clear_state_program: "bytes"
    """
    Logic executed for app call transactions with on-completion set to "clear".

    Clear state programs cannot reject the transaction.
    """

    global_state_schema: "typing.Optional[StateSchema]"
    """
    Holds the maximum number of global state values.

    This cannot be changed after creation.
    """

    local_state_schema: "typing.Optional[StateSchema]"
    """
    Holds the maximum number of local state values.

    This cannot be changed after creation.
    """

    extra_program_pages: "typing.Optional[int]"
    """
    Number of additional pages allocated to the app's approval
    and clear state programs.

    Each extra program page is 2048 bytes. The sum of approval program
    and clear state program may not exceed 2048*(1+extra_program_pages) bytes.
    Currently, the maximum value is 3.
    This cannot be changed after creation.
    """

    args: "typing.Optional[typing.List[bytes]]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, on_complete: "OnApplicationComplete", approval_program: "bytes", clear_state_program: "bytes", global_state_schema: "typing.Optional[StateSchema]" = _DEFAULT, local_state_schema: "typing.Optional[StateSchema]" = _DEFAULT, extra_program_pages: "typing.Optional[int]" = _DEFAULT, args: "typing.Optional[typing.List[bytes]]" = _DEFAULT, account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.on_complete = on_complete
        self.approval_program = approval_program
        self.clear_state_program = clear_state_program
        if global_state_schema is _DEFAULT:
            self.global_state_schema = None
        else:
            self.global_state_schema = global_state_schema
        if local_state_schema is _DEFAULT:
            self.local_state_schema = None
        else:
            self.local_state_schema = local_state_schema
        if extra_program_pages is _DEFAULT:
            self.extra_program_pages = None
        else:
            self.extra_program_pages = extra_program_pages
        if args is _DEFAULT:
            self.args = None
        else:
            self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppCreateParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, on_complete={}, approval_program={}, clear_state_program={}, global_state_schema={}, local_state_schema={}, extra_program_pages={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.on_complete, self.approval_program, self.clear_state_program, self.global_state_schema, self.local_state_schema, self.extra_program_pages, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.on_complete != other.on_complete:
            return False
        if self.approval_program != other.approval_program:
            return False
        if self.clear_state_program != other.clear_state_program:
            return False
        if self.global_state_schema != other.global_state_schema:
            return False
        if self.local_state_schema != other.local_state_schema:
            return False
        if self.extra_program_pages != other.extra_program_pages:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppCreateParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppCreateParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            on_complete=_UniffiConverterTypeOnApplicationComplete.read(buf),
            approval_program=_UniffiConverterBytes.read(buf),
            clear_state_program=_UniffiConverterBytes.read(buf),
            global_state_schema=_UniffiConverterOptionalTypeStateSchema.read(buf),
            local_state_schema=_UniffiConverterOptionalTypeStateSchema.read(buf),
            extra_program_pages=_UniffiConverterOptionalUInt64.read(buf),
            args=_UniffiConverterOptionalSequenceBytes.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterTypeOnApplicationComplete.check_lower(value.on_complete)
        _UniffiConverterBytes.check_lower(value.approval_program)
        _UniffiConverterBytes.check_lower(value.clear_state_program)
        _UniffiConverterOptionalTypeStateSchema.check_lower(value.global_state_schema)
        _UniffiConverterOptionalTypeStateSchema.check_lower(value.local_state_schema)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_program_pages)
        _UniffiConverterOptionalSequenceBytes.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterTypeOnApplicationComplete.write(value.on_complete, buf)
        _UniffiConverterBytes.write(value.approval_program, buf)
        _UniffiConverterBytes.write(value.clear_state_program, buf)
        _UniffiConverterOptionalTypeStateSchema.write(value.global_state_schema, buf)
        _UniffiConverterOptionalTypeStateSchema.write(value.local_state_schema, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_program_pages, buf)
        _UniffiConverterOptionalSequenceBytes.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AppDeleteMethodCallParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    app_id: "int"
    """
    ID of the app being deleted.
    """

    method: "AbiMethod"
    """
    The ABI method to call.
    """

    args: "typing.List[AppMethodCallArg]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, app_id: "int", method: "AbiMethod", args: "typing.List[AppMethodCallArg]", account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.app_id = app_id
        self.method = method
        self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppDeleteMethodCallParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, app_id={}, method={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.app_id, self.method, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.app_id != other.app_id:
            return False
        if self.method != other.method:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppDeleteMethodCallParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppDeleteMethodCallParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            method=_UniffiConverterTypeAbiMethod.read(buf),
            args=_UniffiConverterSequenceTypeAppMethodCallArg.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterTypeAbiMethod.check_lower(value.method)
        _UniffiConverterSequenceTypeAppMethodCallArg.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterTypeAbiMethod.write(value.method, buf)
        _UniffiConverterSequenceTypeAppMethodCallArg.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AppDeleteParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    app_id: "int"
    """
    ID of the app being deleted.
    """

    args: "typing.Optional[typing.List[bytes]]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, app_id: "int", args: "typing.Optional[typing.List[bytes]]" = _DEFAULT, account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.app_id = app_id
        if args is _DEFAULT:
            self.args = None
        else:
            self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppDeleteParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, app_id={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.app_id, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.app_id != other.app_id:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppDeleteParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppDeleteParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            args=_UniffiConverterOptionalSequenceBytes.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterOptionalSequenceBytes.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterOptionalSequenceBytes.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AppUpdateMethodCallParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    app_id: "int"
    """
    ID of the app being updated.
    """

    approval_program: "bytes"
    """
    Logic executed for every app call transaction, except when
    on-completion is set to "clear".

    Approval programs may reject the transaction.
    """

    clear_state_program: "bytes"
    """
    Logic executed for app call transactions with on-completion set to "clear".

    Clear state programs cannot reject the transaction.
    """

    method: "AbiMethod"
    """
    The ABI method to call.
    """

    args: "typing.List[AppMethodCallArg]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, app_id: "int", approval_program: "bytes", clear_state_program: "bytes", method: "AbiMethod", args: "typing.List[AppMethodCallArg]", account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.app_id = app_id
        self.approval_program = approval_program
        self.clear_state_program = clear_state_program
        self.method = method
        self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppUpdateMethodCallParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, app_id={}, approval_program={}, clear_state_program={}, method={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.app_id, self.approval_program, self.clear_state_program, self.method, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.app_id != other.app_id:
            return False
        if self.approval_program != other.approval_program:
            return False
        if self.clear_state_program != other.clear_state_program:
            return False
        if self.method != other.method:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppUpdateMethodCallParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppUpdateMethodCallParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            approval_program=_UniffiConverterBytes.read(buf),
            clear_state_program=_UniffiConverterBytes.read(buf),
            method=_UniffiConverterTypeAbiMethod.read(buf),
            args=_UniffiConverterSequenceTypeAppMethodCallArg.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterBytes.check_lower(value.approval_program)
        _UniffiConverterBytes.check_lower(value.clear_state_program)
        _UniffiConverterTypeAbiMethod.check_lower(value.method)
        _UniffiConverterSequenceTypeAppMethodCallArg.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterBytes.write(value.approval_program, buf)
        _UniffiConverterBytes.write(value.clear_state_program, buf)
        _UniffiConverterTypeAbiMethod.write(value.method, buf)
        _UniffiConverterSequenceTypeAppMethodCallArg.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AppUpdateParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    app_id: "int"
    """
    ID of the app being updated.
    """

    approval_program: "bytes"
    """
    Logic executed for every app call transaction, except when
    on-completion is set to "clear".

    Approval programs may reject the transaction.
    """

    clear_state_program: "bytes"
    """
    Logic executed for app call transactions with on-completion set to "clear".

    Clear state programs cannot reject the transaction.
    """

    args: "typing.Optional[typing.List[bytes]]"
    """
    Transaction specific arguments available in the app's
    approval program and clear state program.
    """

    account_references: "typing.Optional[typing.List[str]]"
    """
    List of accounts in addition to the sender that may be accessed
    from the app's approval program and clear state program.
    """

    app_references: "typing.Optional[typing.List[int]]"
    """
    List of apps in addition to the current app that may be called
    from the app's approval program and clear state program.
    """

    asset_references: "typing.Optional[typing.List[int]]"
    """
    Lists the assets whose parameters may be accessed by this app's
    approval program and clear state program.

    The access is read-only.
    """

    box_references: "typing.Optional[typing.List[BoxReference]]"
    """
    The boxes that should be made available for the runtime of the program.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, app_id: "int", approval_program: "bytes", clear_state_program: "bytes", args: "typing.Optional[typing.List[bytes]]" = _DEFAULT, account_references: "typing.Optional[typing.List[str]]" = _DEFAULT, app_references: "typing.Optional[typing.List[int]]" = _DEFAULT, asset_references: "typing.Optional[typing.List[int]]" = _DEFAULT, box_references: "typing.Optional[typing.List[BoxReference]]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.app_id = app_id
        self.approval_program = approval_program
        self.clear_state_program = clear_state_program
        if args is _DEFAULT:
            self.args = None
        else:
            self.args = args
        if account_references is _DEFAULT:
            self.account_references = None
        else:
            self.account_references = account_references
        if app_references is _DEFAULT:
            self.app_references = None
        else:
            self.app_references = app_references
        if asset_references is _DEFAULT:
            self.asset_references = None
        else:
            self.asset_references = asset_references
        if box_references is _DEFAULT:
            self.box_references = None
        else:
            self.box_references = box_references

    def __str__(self):
        return "AppUpdateParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, app_id={}, approval_program={}, clear_state_program={}, args={}, account_references={}, app_references={}, asset_references={}, box_references={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.app_id, self.approval_program, self.clear_state_program, self.args, self.account_references, self.app_references, self.asset_references, self.box_references)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.app_id != other.app_id:
            return False
        if self.approval_program != other.approval_program:
            return False
        if self.clear_state_program != other.clear_state_program:
            return False
        if self.args != other.args:
            return False
        if self.account_references != other.account_references:
            return False
        if self.app_references != other.app_references:
            return False
        if self.asset_references != other.asset_references:
            return False
        if self.box_references != other.box_references:
            return False
        return True

class _UniffiConverterTypeAppUpdateParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppUpdateParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterUInt64.read(buf),
            approval_program=_UniffiConverterBytes.read(buf),
            clear_state_program=_UniffiConverterBytes.read(buf),
            args=_UniffiConverterOptionalSequenceBytes.read(buf),
            account_references=_UniffiConverterOptionalSequenceString.read(buf),
            app_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            asset_references=_UniffiConverterOptionalSequenceUInt64.read(buf),
            box_references=_UniffiConverterOptionalSequenceTypeBoxReference.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.app_id)
        _UniffiConverterBytes.check_lower(value.approval_program)
        _UniffiConverterBytes.check_lower(value.clear_state_program)
        _UniffiConverterOptionalSequenceBytes.check_lower(value.args)
        _UniffiConverterOptionalSequenceString.check_lower(value.account_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.app_references)
        _UniffiConverterOptionalSequenceUInt64.check_lower(value.asset_references)
        _UniffiConverterOptionalSequenceTypeBoxReference.check_lower(value.box_references)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.app_id, buf)
        _UniffiConverterBytes.write(value.approval_program, buf)
        _UniffiConverterBytes.write(value.clear_state_program, buf)
        _UniffiConverterOptionalSequenceBytes.write(value.args, buf)
        _UniffiConverterOptionalSequenceString.write(value.account_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.app_references, buf)
        _UniffiConverterOptionalSequenceUInt64.write(value.asset_references, buf)
        _UniffiConverterOptionalSequenceTypeBoxReference.write(value.box_references, buf)


class AssetClawbackParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    The ID of the asset being clawed back.
    """

    amount: "int"
    """
    The amount of the asset to clawback.
    """

    receiver: "str"
    """
    The address that will receive the clawed back asset.
    """

    clawback_target: "str"
    """
    The address from which assets are taken.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int", amount: "int", receiver: "str", clawback_target: "str"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id
        self.amount = amount
        self.receiver = receiver
        self.clawback_target = clawback_target

    def __str__(self):
        return "AssetClawbackParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={}, amount={}, receiver={}, clawback_target={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id, self.amount, self.receiver, self.clawback_target)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.amount != other.amount:
            return False
        if self.receiver != other.receiver:
            return False
        if self.clawback_target != other.clawback_target:
            return False
        return True

class _UniffiConverterTypeAssetClawbackParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetClawbackParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            receiver=_UniffiConverterString.read(buf),
            clawback_target=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.receiver)
        _UniffiConverterString.check_lower(value.clawback_target)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterString.write(value.receiver, buf)
        _UniffiConverterString.write(value.clawback_target, buf)


class AssetConfigParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    ID of the existing asset to be reconfigured.
    """

    manager: "typing.Optional[str]"
    """
    The address of the optional account that can manage the configuration.
    """

    reserve: "typing.Optional[str]"
    """
    The address of the optional account that holds the reserve units.
    """

    freeze: "typing.Optional[str]"
    """
    The address of the optional account that can freeze/unfreeze holdings.
    """

    clawback: "typing.Optional[str]"
    """
    The address of the optional account that can clawback holdings.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int", manager: "typing.Optional[str]" = _DEFAULT, reserve: "typing.Optional[str]" = _DEFAULT, freeze: "typing.Optional[str]" = _DEFAULT, clawback: "typing.Optional[str]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id
        if manager is _DEFAULT:
            self.manager = None
        else:
            self.manager = manager
        if reserve is _DEFAULT:
            self.reserve = None
        else:
            self.reserve = reserve
        if freeze is _DEFAULT:
            self.freeze = None
        else:
            self.freeze = freeze
        if clawback is _DEFAULT:
            self.clawback = None
        else:
            self.clawback = clawback

    def __str__(self):
        return "AssetConfigParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={}, manager={}, reserve={}, freeze={}, clawback={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id, self.manager, self.reserve, self.freeze, self.clawback)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.manager != other.manager:
            return False
        if self.reserve != other.reserve:
            return False
        if self.freeze != other.freeze:
            return False
        if self.clawback != other.clawback:
            return False
        return True

class _UniffiConverterTypeAssetConfigParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetConfigParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            manager=_UniffiConverterOptionalString.read(buf),
            reserve=_UniffiConverterOptionalString.read(buf),
            freeze=_UniffiConverterOptionalString.read(buf),
            clawback=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterOptionalString.check_lower(value.manager)
        _UniffiConverterOptionalString.check_lower(value.reserve)
        _UniffiConverterOptionalString.check_lower(value.freeze)
        _UniffiConverterOptionalString.check_lower(value.clawback)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterOptionalString.write(value.manager, buf)
        _UniffiConverterOptionalString.write(value.reserve, buf)
        _UniffiConverterOptionalString.write(value.freeze, buf)
        _UniffiConverterOptionalString.write(value.clawback, buf)


class AssetCreateParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    total: "int"
    """
    The total amount of the smallest divisible (decimal) unit to create.
    """

    decimals: "typing.Optional[int]"
    """
    The amount of decimal places the asset should have.
    """

    default_frozen: "typing.Optional[bool]"
    """
    Whether the asset is frozen by default for all accounts.
    """

    asset_name: "typing.Optional[str]"
    """
    The optional name of the asset.
    """

    unit_name: "typing.Optional[str]"
    """
    The optional name of the unit of this asset.
    """

    url: "typing.Optional[str]"
    """
    Specifies an optional URL where more information about the asset can be retrieved.
    """

    metadata_hash: "typing.Optional[bytes]"
    """
    32-byte hash of some metadata that is relevant to your asset.
    """

    manager: "typing.Optional[str]"
    """
    The address of the optional account that can manage the configuration.
    """

    reserve: "typing.Optional[str]"
    """
    The address of the optional account that holds the reserve units.
    """

    freeze: "typing.Optional[str]"
    """
    The address of the optional account that can freeze/unfreeze holdings.
    """

    clawback: "typing.Optional[str]"
    """
    The address of the optional account that can clawback holdings.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, total: "int", decimals: "typing.Optional[int]" = _DEFAULT, default_frozen: "typing.Optional[bool]" = _DEFAULT, asset_name: "typing.Optional[str]" = _DEFAULT, unit_name: "typing.Optional[str]" = _DEFAULT, url: "typing.Optional[str]" = _DEFAULT, metadata_hash: "typing.Optional[bytes]" = _DEFAULT, manager: "typing.Optional[str]" = _DEFAULT, reserve: "typing.Optional[str]" = _DEFAULT, freeze: "typing.Optional[str]" = _DEFAULT, clawback: "typing.Optional[str]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.total = total
        if decimals is _DEFAULT:
            self.decimals = None
        else:
            self.decimals = decimals
        if default_frozen is _DEFAULT:
            self.default_frozen = None
        else:
            self.default_frozen = default_frozen
        if asset_name is _DEFAULT:
            self.asset_name = None
        else:
            self.asset_name = asset_name
        if unit_name is _DEFAULT:
            self.unit_name = None
        else:
            self.unit_name = unit_name
        if url is _DEFAULT:
            self.url = None
        else:
            self.url = url
        if metadata_hash is _DEFAULT:
            self.metadata_hash = None
        else:
            self.metadata_hash = metadata_hash
        if manager is _DEFAULT:
            self.manager = None
        else:
            self.manager = manager
        if reserve is _DEFAULT:
            self.reserve = None
        else:
            self.reserve = reserve
        if freeze is _DEFAULT:
            self.freeze = None
        else:
            self.freeze = freeze
        if clawback is _DEFAULT:
            self.clawback = None
        else:
            self.clawback = clawback

    def __str__(self):
        return "AssetCreateParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, total={}, decimals={}, default_frozen={}, asset_name={}, unit_name={}, url={}, metadata_hash={}, manager={}, reserve={}, freeze={}, clawback={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.total, self.decimals, self.default_frozen, self.asset_name, self.unit_name, self.url, self.metadata_hash, self.manager, self.reserve, self.freeze, self.clawback)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.total != other.total:
            return False
        if self.decimals != other.decimals:
            return False
        if self.default_frozen != other.default_frozen:
            return False
        if self.asset_name != other.asset_name:
            return False
        if self.unit_name != other.unit_name:
            return False
        if self.url != other.url:
            return False
        if self.metadata_hash != other.metadata_hash:
            return False
        if self.manager != other.manager:
            return False
        if self.reserve != other.reserve:
            return False
        if self.freeze != other.freeze:
            return False
        if self.clawback != other.clawback:
            return False
        return True

class _UniffiConverterTypeAssetCreateParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetCreateParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            total=_UniffiConverterUInt64.read(buf),
            decimals=_UniffiConverterOptionalUInt32.read(buf),
            default_frozen=_UniffiConverterOptionalBool.read(buf),
            asset_name=_UniffiConverterOptionalString.read(buf),
            unit_name=_UniffiConverterOptionalString.read(buf),
            url=_UniffiConverterOptionalString.read(buf),
            metadata_hash=_UniffiConverterOptionalBytes.read(buf),
            manager=_UniffiConverterOptionalString.read(buf),
            reserve=_UniffiConverterOptionalString.read(buf),
            freeze=_UniffiConverterOptionalString.read(buf),
            clawback=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.total)
        _UniffiConverterOptionalUInt32.check_lower(value.decimals)
        _UniffiConverterOptionalBool.check_lower(value.default_frozen)
        _UniffiConverterOptionalString.check_lower(value.asset_name)
        _UniffiConverterOptionalString.check_lower(value.unit_name)
        _UniffiConverterOptionalString.check_lower(value.url)
        _UniffiConverterOptionalBytes.check_lower(value.metadata_hash)
        _UniffiConverterOptionalString.check_lower(value.manager)
        _UniffiConverterOptionalString.check_lower(value.reserve)
        _UniffiConverterOptionalString.check_lower(value.freeze)
        _UniffiConverterOptionalString.check_lower(value.clawback)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.total, buf)
        _UniffiConverterOptionalUInt32.write(value.decimals, buf)
        _UniffiConverterOptionalBool.write(value.default_frozen, buf)
        _UniffiConverterOptionalString.write(value.asset_name, buf)
        _UniffiConverterOptionalString.write(value.unit_name, buf)
        _UniffiConverterOptionalString.write(value.url, buf)
        _UniffiConverterOptionalBytes.write(value.metadata_hash, buf)
        _UniffiConverterOptionalString.write(value.manager, buf)
        _UniffiConverterOptionalString.write(value.reserve, buf)
        _UniffiConverterOptionalString.write(value.freeze, buf)
        _UniffiConverterOptionalString.write(value.clawback, buf)


class AssetDestroyParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    ID of the existing asset to be destroyed.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id

    def __str__(self):
        return "AssetDestroyParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        return True

class _UniffiConverterTypeAssetDestroyParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetDestroyParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)


class AssetFreezeParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    The ID of the asset being frozen.
    """

    target_address: "str"
    """
    The target account whose asset holdings will be frozen.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int", target_address: "str"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id
        self.target_address = target_address

    def __str__(self):
        return "AssetFreezeParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={}, target_address={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id, self.target_address)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.target_address != other.target_address:
            return False
        return True

class _UniffiConverterTypeAssetFreezeParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetFreezeParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            target_address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterString.check_lower(value.target_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterString.write(value.target_address, buf)


class AssetOptInParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    The ID of the asset to opt into.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id

    def __str__(self):
        return "AssetOptInParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        return True

class _UniffiConverterTypeAssetOptInParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetOptInParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)


class AssetOptOutParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    The ID of the asset to opt out of.
    """

    close_remainder_to: "typing.Optional[str]"
    """
    The address to close the remainder to. If None, defaults to the asset creator.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int", close_remainder_to: "typing.Optional[str]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id
        if close_remainder_to is _DEFAULT:
            self.close_remainder_to = None
        else:
            self.close_remainder_to = close_remainder_to

    def __str__(self):
        return "AssetOptOutParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={}, close_remainder_to={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id, self.close_remainder_to)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.close_remainder_to != other.close_remainder_to:
            return False
        return True

class _UniffiConverterTypeAssetOptOutParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetOptOutParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            close_remainder_to=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterOptionalString.check_lower(value.close_remainder_to)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterOptionalString.write(value.close_remainder_to, buf)


class AssetTransferParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    The ID of the asset being transferred.
    """

    amount: "int"
    """
    The amount of the asset to transfer.
    """

    receiver: "str"
    """
    The address that will receive the asset.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int", amount: "int", receiver: "str"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id
        self.amount = amount
        self.receiver = receiver

    def __str__(self):
        return "AssetTransferParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={}, amount={}, receiver={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id, self.amount, self.receiver)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.amount != other.amount:
            return False
        if self.receiver != other.receiver:
            return False
        return True

class _UniffiConverterTypeAssetTransferParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetTransferParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
            receiver=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterString.check_lower(value.receiver)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterString.write(value.receiver, buf)


class AssetUnfreezeParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    asset_id: "int"
    """
    The ID of the asset being unfrozen.
    """

    target_address: "str"
    """
    The target account whose asset holdings will be unfrozen.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, asset_id: "int", target_address: "str"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.asset_id = asset_id
        self.target_address = target_address

    def __str__(self):
        return "AssetUnfreezeParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, asset_id={}, target_address={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.asset_id, self.target_address)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.target_address != other.target_address:
            return False
        return True

class _UniffiConverterTypeAssetUnfreezeParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetUnfreezeParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterUInt64.read(buf),
            target_address=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterUInt64.check_lower(value.asset_id)
        _UniffiConverterString.check_lower(value.target_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterUInt64.write(value.asset_id, buf)
        _UniffiConverterString.write(value.target_address, buf)


class CommonParams:
    sender: "str"
    signer: "typing.Optional[TransactionSigner]"
    rekey_to: "typing.Optional[str]"
    note: "typing.Optional[bytes]"
    lease: "typing.Optional[bytes]"
    static_fee: "typing.Optional[int]"
    extra_fee: "typing.Optional[int]"
    max_fee: "typing.Optional[int]"
    validity_window: "typing.Optional[int]"
    first_valid_round: "typing.Optional[int]"
    last_valid_round: "typing.Optional[int]"
    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round

    def __str__(self):
        return "CommonParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        return True

class _UniffiConverterTypeCommonParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CommonParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt64.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)


class NonParticipationKeyRegistrationParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round

    def __str__(self):
        return "NonParticipationKeyRegistrationParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        return True

class _UniffiConverterTypeNonParticipationKeyRegistrationParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NonParticipationKeyRegistrationParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)


class OfflineKeyRegistrationParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round

    def __str__(self):
        return "OfflineKeyRegistrationParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        return True

class _UniffiConverterTypeOfflineKeyRegistrationParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OfflineKeyRegistrationParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)


class OnlineKeyRegistrationParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    vote_key: "bytes"
    """
    The root participation public key.
    """

    selection_key: "bytes"
    """
    The VRF public key.
    """

    vote_first: "int"
    """
    The first round that the participation key is valid.
    """

    vote_last: "int"
    """
    The last round that the participation key is valid.
    """

    vote_key_dilution: "int"
    """
    This is the dilution for the 2-level participation key.
    """

    state_proof_key: "typing.Optional[bytes]"
    """
    The 64 byte state proof public key commitment.
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, vote_key: "bytes", selection_key: "bytes", vote_first: "int", vote_last: "int", vote_key_dilution: "int", state_proof_key: "typing.Optional[bytes]" = _DEFAULT):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.vote_key = vote_key
        self.selection_key = selection_key
        self.vote_first = vote_first
        self.vote_last = vote_last
        self.vote_key_dilution = vote_key_dilution
        if state_proof_key is _DEFAULT:
            self.state_proof_key = None
        else:
            self.state_proof_key = state_proof_key

    def __str__(self):
        return "OnlineKeyRegistrationParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, vote_key={}, selection_key={}, vote_first={}, vote_last={}, vote_key_dilution={}, state_proof_key={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.vote_key, self.selection_key, self.vote_first, self.vote_last, self.vote_key_dilution, self.state_proof_key)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.vote_key != other.vote_key:
            return False
        if self.selection_key != other.selection_key:
            return False
        if self.vote_first != other.vote_first:
            return False
        if self.vote_last != other.vote_last:
            return False
        if self.vote_key_dilution != other.vote_key_dilution:
            return False
        if self.state_proof_key != other.state_proof_key:
            return False
        return True

class _UniffiConverterTypeOnlineKeyRegistrationParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OnlineKeyRegistrationParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            vote_key=_UniffiConverterBytes.read(buf),
            selection_key=_UniffiConverterBytes.read(buf),
            vote_first=_UniffiConverterUInt64.read(buf),
            vote_last=_UniffiConverterUInt64.read(buf),
            vote_key_dilution=_UniffiConverterUInt64.read(buf),
            state_proof_key=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterBytes.check_lower(value.vote_key)
        _UniffiConverterBytes.check_lower(value.selection_key)
        _UniffiConverterUInt64.check_lower(value.vote_first)
        _UniffiConverterUInt64.check_lower(value.vote_last)
        _UniffiConverterUInt64.check_lower(value.vote_key_dilution)
        _UniffiConverterOptionalBytes.check_lower(value.state_proof_key)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterBytes.write(value.vote_key, buf)
        _UniffiConverterBytes.write(value.selection_key, buf)
        _UniffiConverterUInt64.write(value.vote_first, buf)
        _UniffiConverterUInt64.write(value.vote_last, buf)
        _UniffiConverterUInt64.write(value.vote_key_dilution, buf)
        _UniffiConverterOptionalBytes.write(value.state_proof_key, buf)


class PaymentParams:
    sender: "str"
    """
    The address of the account sending the transaction.
    """

    signer: "typing.Optional[TransactionSigner]"
    """
    A signer used to sign transaction(s); if not specified then
    an attempt will be made to find a registered signer for the
    given `sender` or use a default signer (if configured).
    """

    rekey_to: "typing.Optional[str]"
    """
    Change the signing key of the sender to the given address.
    **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://dev.algorand.co/concepts/accounts/rekeying).
    """

    note: "typing.Optional[bytes]"
    """
    Note to attach to the transaction. Max of 1000 bytes.
    """

    lease: "typing.Optional[bytes]"
    """
    Prevent multiple transactions with the same lease being included within the validity window.

    A [lease](https://dev.algorand.co/concepts/transactions/leases)
    enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
    """

    static_fee: "typing.Optional[int]"
    """
    The static transaction fee. In most cases you want to use extra fee unless setting the fee to 0 to be covered by another transaction.
    """

    extra_fee: "typing.Optional[int]"
    """
    The fee to pay IN ADDITION to the suggested fee. Useful for manually covering inner transaction fees.
    """

    max_fee: "typing.Optional[int]"
    """
    Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods.
    """

    validity_window: "typing.Optional[int]"
    """
    How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used.
    """

    first_valid_round: "typing.Optional[int]"
    """
    Set the first round this transaction is valid.
    If left undefined, the value from algod will be used.

    We recommend you only set this when you intentionally want this to be some time in the future.
    """

    last_valid_round: "typing.Optional[int]"
    """
    The last round this transaction is valid. It is recommended to use validity window instead.
    """

    receiver: "str"
    """
    The address of the account receiving the ALGO payment.
    """

    amount: "int"
    """
    The amount of microALGO to send.

    Specified in microALGO (1 ALGO = 1,000,000 microALGO).
    """

    def __init__(self, *, sender: "str", signer: "typing.Optional[TransactionSigner]" = _DEFAULT, rekey_to: "typing.Optional[str]" = _DEFAULT, note: "typing.Optional[bytes]" = _DEFAULT, lease: "typing.Optional[bytes]" = _DEFAULT, static_fee: "typing.Optional[int]" = _DEFAULT, extra_fee: "typing.Optional[int]" = _DEFAULT, max_fee: "typing.Optional[int]" = _DEFAULT, validity_window: "typing.Optional[int]" = _DEFAULT, first_valid_round: "typing.Optional[int]" = _DEFAULT, last_valid_round: "typing.Optional[int]" = _DEFAULT, receiver: "str", amount: "int"):
        self.sender = sender
        if signer is _DEFAULT:
            self.signer = None
        else:
            self.signer = signer
        if rekey_to is _DEFAULT:
            self.rekey_to = None
        else:
            self.rekey_to = rekey_to
        if note is _DEFAULT:
            self.note = None
        else:
            self.note = note
        if lease is _DEFAULT:
            self.lease = None
        else:
            self.lease = lease
        if static_fee is _DEFAULT:
            self.static_fee = None
        else:
            self.static_fee = static_fee
        if extra_fee is _DEFAULT:
            self.extra_fee = None
        else:
            self.extra_fee = extra_fee
        if max_fee is _DEFAULT:
            self.max_fee = None
        else:
            self.max_fee = max_fee
        if validity_window is _DEFAULT:
            self.validity_window = None
        else:
            self.validity_window = validity_window
        if first_valid_round is _DEFAULT:
            self.first_valid_round = None
        else:
            self.first_valid_round = first_valid_round
        if last_valid_round is _DEFAULT:
            self.last_valid_round = None
        else:
            self.last_valid_round = last_valid_round
        self.receiver = receiver
        self.amount = amount

    def __str__(self):
        return "PaymentParams(sender={}, signer={}, rekey_to={}, note={}, lease={}, static_fee={}, extra_fee={}, max_fee={}, validity_window={}, first_valid_round={}, last_valid_round={}, receiver={}, amount={})".format(self.sender, self.signer, self.rekey_to, self.note, self.lease, self.static_fee, self.extra_fee, self.max_fee, self.validity_window, self.first_valid_round, self.last_valid_round, self.receiver, self.amount)

    def __eq__(self, other):
        if self.sender != other.sender:
            return False
        if self.signer != other.signer:
            return False
        if self.rekey_to != other.rekey_to:
            return False
        if self.note != other.note:
            return False
        if self.lease != other.lease:
            return False
        if self.static_fee != other.static_fee:
            return False
        if self.extra_fee != other.extra_fee:
            return False
        if self.max_fee != other.max_fee:
            return False
        if self.validity_window != other.validity_window:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.receiver != other.receiver:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypePaymentParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaymentParams(
            sender=_UniffiConverterString.read(buf),
            signer=_UniffiConverterOptionalTypeTransactionSigner.read(buf),
            rekey_to=_UniffiConverterOptionalString.read(buf),
            note=_UniffiConverterOptionalBytes.read(buf),
            lease=_UniffiConverterOptionalBytes.read(buf),
            static_fee=_UniffiConverterOptionalUInt64.read(buf),
            extra_fee=_UniffiConverterOptionalUInt64.read(buf),
            max_fee=_UniffiConverterOptionalUInt64.read(buf),
            validity_window=_UniffiConverterOptionalUInt32.read(buf),
            first_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            last_valid_round=_UniffiConverterOptionalUInt64.read(buf),
            receiver=_UniffiConverterString.read(buf),
            amount=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.sender)
        _UniffiConverterOptionalTypeTransactionSigner.check_lower(value.signer)
        _UniffiConverterOptionalString.check_lower(value.rekey_to)
        _UniffiConverterOptionalBytes.check_lower(value.note)
        _UniffiConverterOptionalBytes.check_lower(value.lease)
        _UniffiConverterOptionalUInt64.check_lower(value.static_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.extra_fee)
        _UniffiConverterOptionalUInt64.check_lower(value.max_fee)
        _UniffiConverterOptionalUInt32.check_lower(value.validity_window)
        _UniffiConverterOptionalUInt64.check_lower(value.first_valid_round)
        _UniffiConverterOptionalUInt64.check_lower(value.last_valid_round)
        _UniffiConverterString.check_lower(value.receiver)
        _UniffiConverterUInt64.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.sender, buf)
        _UniffiConverterOptionalTypeTransactionSigner.write(value.signer, buf)
        _UniffiConverterOptionalString.write(value.rekey_to, buf)
        _UniffiConverterOptionalBytes.write(value.note, buf)
        _UniffiConverterOptionalBytes.write(value.lease, buf)
        _UniffiConverterOptionalUInt64.write(value.static_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.extra_fee, buf)
        _UniffiConverterOptionalUInt64.write(value.max_fee, buf)
        _UniffiConverterOptionalUInt32.write(value.validity_window, buf)
        _UniffiConverterOptionalUInt64.write(value.first_valid_round, buf)
        _UniffiConverterOptionalUInt64.write(value.last_valid_round, buf)
        _UniffiConverterString.write(value.receiver, buf)
        _UniffiConverterUInt64.write(value.amount, buf)


class SuggestedParams:
    fee: "int"
    first_valid_round: "int"
    last_valid_round: "int"
    genesis_hash: "bytes"
    genesis_id: "str"
    def __init__(self, *, fee: "int", first_valid_round: "int", last_valid_round: "int", genesis_hash: "bytes", genesis_id: "str"):
        self.fee = fee
        self.first_valid_round = first_valid_round
        self.last_valid_round = last_valid_round
        self.genesis_hash = genesis_hash
        self.genesis_id = genesis_id

    def __str__(self):
        return "SuggestedParams(fee={}, first_valid_round={}, last_valid_round={}, genesis_hash={}, genesis_id={})".format(self.fee, self.first_valid_round, self.last_valid_round, self.genesis_hash, self.genesis_id)

    def __eq__(self, other):
        if self.fee != other.fee:
            return False
        if self.first_valid_round != other.first_valid_round:
            return False
        if self.last_valid_round != other.last_valid_round:
            return False
        if self.genesis_hash != other.genesis_hash:
            return False
        if self.genesis_id != other.genesis_id:
            return False
        return True

class _UniffiConverterTypeSuggestedParams(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SuggestedParams(
            fee=_UniffiConverterUInt64.read(buf),
            first_valid_round=_UniffiConverterUInt64.read(buf),
            last_valid_round=_UniffiConverterUInt64.read(buf),
            genesis_hash=_UniffiConverterBytes.read(buf),
            genesis_id=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.fee)
        _UniffiConverterUInt64.check_lower(value.first_valid_round)
        _UniffiConverterUInt64.check_lower(value.last_valid_round)
        _UniffiConverterBytes.check_lower(value.genesis_hash)
        _UniffiConverterString.check_lower(value.genesis_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.fee, buf)
        _UniffiConverterUInt64.write(value.first_valid_round, buf)
        _UniffiConverterUInt64.write(value.last_valid_round, buf)
        _UniffiConverterBytes.write(value.genesis_hash, buf)
        _UniffiConverterString.write(value.genesis_id, buf)


class TempSendResponse:
    transaction_ids: "typing.List[str]"
    app_ids: "typing.List[typing.Optional[int]]"
    def __init__(self, *, transaction_ids: "typing.List[str]", app_ids: "typing.List[typing.Optional[int]]"):
        self.transaction_ids = transaction_ids
        self.app_ids = app_ids

    def __str__(self):
        return "TempSendResponse(transaction_ids={}, app_ids={})".format(self.transaction_ids, self.app_ids)

    def __eq__(self, other):
        if self.transaction_ids != other.transaction_ids:
            return False
        if self.app_ids != other.app_ids:
            return False
        return True

class _UniffiConverterTypeTempSendResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TempSendResponse(
            transaction_ids=_UniffiConverterSequenceString.read(buf),
            app_ids=_UniffiConverterSequenceOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceString.check_lower(value.transaction_ids)
        _UniffiConverterSequenceOptionalUInt64.check_lower(value.app_ids)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceString.write(value.transaction_ids, buf)
        _UniffiConverterSequenceOptionalUInt64.write(value.app_ids, buf)


class TestAccount:
    address: "str"
    private_key: "bytes"
    mnemonic: "str"
    def __init__(self, *, address: "str", private_key: "bytes", mnemonic: "str"):
        self.address = address
        self.private_key = private_key
        self.mnemonic = mnemonic

    def __str__(self):
        return "TestAccount(address={}, private_key={}, mnemonic={})".format(self.address, self.private_key, self.mnemonic)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.private_key != other.private_key:
            return False
        if self.mnemonic != other.mnemonic:
            return False
        return True

class _UniffiConverterTypeTestAccount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TestAccount(
            address=_UniffiConverterString.read(buf),
            private_key=_UniffiConverterBytes.read(buf),
            mnemonic=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.address)
        _UniffiConverterBytes.check_lower(value.private_key)
        _UniffiConverterString.check_lower(value.mnemonic)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.address, buf)
        _UniffiConverterBytes.write(value.private_key, buf)
        _UniffiConverterString.write(value.mnemonic, buf)


class TestResult:
    """
    Result of a single test
    """

    name: "str"
    passed: "bool"
    duration_ms: "int"
    error: "typing.Optional[str]"
    def __init__(self, *, name: "str", passed: "bool", duration_ms: "int", error: "typing.Optional[str]"):
        self.name = name
        self.passed = passed
        self.duration_ms = duration_ms
        self.error = error

    def __str__(self):
        return "TestResult(name={}, passed={}, duration_ms={}, error={})".format(self.name, self.passed, self.duration_ms, self.error)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.passed != other.passed:
            return False
        if self.duration_ms != other.duration_ms:
            return False
        if self.error != other.error:
            return False
        return True

class _UniffiConverterTypeTestResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TestResult(
            name=_UniffiConverterString.read(buf),
            passed=_UniffiConverterBool.read(buf),
            duration_ms=_UniffiConverterUInt64.read(buf),
            error=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterBool.check_lower(value.passed)
        _UniffiConverterUInt64.check_lower(value.duration_ms)
        _UniffiConverterOptionalString.check_lower(value.error)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterBool.write(value.passed, buf)
        _UniffiConverterUInt64.write(value.duration_ms, buf)
        _UniffiConverterOptionalString.write(value.error, buf)


class TestSuiteResult:
    """
    Result of an entire test suite
    """

    name: "str"
    results: "typing.List[TestResult]"
    all_passed: "bool"
    total_duration_ms: "int"
    def __init__(self, *, name: "str", results: "typing.List[TestResult]", all_passed: "bool", total_duration_ms: "int"):
        self.name = name
        self.results = results
        self.all_passed = all_passed
        self.total_duration_ms = total_duration_ms

    def __str__(self):
        return "TestSuiteResult(name={}, results={}, all_passed={}, total_duration_ms={})".format(self.name, self.results, self.all_passed, self.total_duration_ms)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.results != other.results:
            return False
        if self.all_passed != other.all_passed:
            return False
        if self.total_duration_ms != other.total_duration_ms:
            return False
        return True

class _UniffiConverterTypeTestSuiteResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TestSuiteResult(
            name=_UniffiConverterString.read(buf),
            results=_UniffiConverterSequenceTypeTestResult.read(buf),
            all_passed=_UniffiConverterBool.read(buf),
            total_duration_ms=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterSequenceTypeTestResult.check_lower(value.results)
        _UniffiConverterBool.check_lower(value.all_passed)
        _UniffiConverterUInt64.check_lower(value.total_duration_ms)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterSequenceTypeTestResult.write(value.results, buf)
        _UniffiConverterBool.write(value.all_passed, buf)
        _UniffiConverterUInt64.write(value.total_duration_ms, buf)


class TransactionInfo:
    tx_id: "str"
    confirmed_round: "typing.Optional[int]"
    asset_id: "typing.Optional[int]"
    app_id: "typing.Optional[int]"
    def __init__(self, *, tx_id: "str", confirmed_round: "typing.Optional[int]", asset_id: "typing.Optional[int]", app_id: "typing.Optional[int]"):
        self.tx_id = tx_id
        self.confirmed_round = confirmed_round
        self.asset_id = asset_id
        self.app_id = app_id

    def __str__(self):
        return "TransactionInfo(tx_id={}, confirmed_round={}, asset_id={}, app_id={})".format(self.tx_id, self.confirmed_round, self.asset_id, self.app_id)

    def __eq__(self, other):
        if self.tx_id != other.tx_id:
            return False
        if self.confirmed_round != other.confirmed_round:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.app_id != other.app_id:
            return False
        return True

class _UniffiConverterTypeTransactionInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionInfo(
            tx_id=_UniffiConverterString.read(buf),
            confirmed_round=_UniffiConverterOptionalUInt64.read(buf),
            asset_id=_UniffiConverterOptionalUInt64.read(buf),
            app_id=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.tx_id)
        _UniffiConverterOptionalUInt64.check_lower(value.confirmed_round)
        _UniffiConverterOptionalUInt64.check_lower(value.asset_id)
        _UniffiConverterOptionalUInt64.check_lower(value.app_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.tx_id, buf)
        _UniffiConverterOptionalUInt64.write(value.confirmed_round, buf)
        _UniffiConverterOptionalUInt64.write(value.asset_id, buf)
        _UniffiConverterOptionalUInt64.write(value.app_id, buf)


class TransactionWithSigner:
    transaction: "Transaction"
    signer: "TransactionSigner"
    def __init__(self, *, transaction: "Transaction", signer: "TransactionSigner"):
        self.transaction = transaction
        self.signer = signer

    def __str__(self):
        return "TransactionWithSigner(transaction={}, signer={})".format(self.transaction, self.signer)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.signer != other.signer:
            return False
        return True

class _UniffiConverterTypeTransactionWithSigner(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionWithSigner(
            transaction=_UniffiConverterTypeTransaction.read(buf),
            signer=_UniffiConverterTypeTransactionSigner.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTransaction.check_lower(value.transaction)
        _UniffiConverterTypeTransactionSigner.check_lower(value.signer)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTransaction.write(value.transaction, buf)
        _UniffiConverterTypeTransactionSigner.write(value.signer, buf)





class AbiMethodArgType:
    def __init__(self):
        raise RuntimeError("AbiMethodArgType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class VALUE:
        """
        A value that is directly encoded in the app arguments.
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AbiMethodArgType.VALUE{self._values!r}"

        def __eq__(self, other):
            if not other.is_VALUE():
                return False
            return self._values == other._values
    class TRANSACTION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AbiMethodArgType.TRANSACTION{self._values!r}"

        def __eq__(self, other):
            if not other.is_TRANSACTION():
                return False
            return self._values == other._values
    class REFERENCE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AbiMethodArgType.REFERENCE{self._values!r}"

        def __eq__(self, other):
            if not other.is_REFERENCE():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_VALUE(self) -> bool:
        return isinstance(self, AbiMethodArgType.VALUE)
    def is_value(self) -> bool:
        return isinstance(self, AbiMethodArgType.VALUE)
    def is_TRANSACTION(self) -> bool:
        return isinstance(self, AbiMethodArgType.TRANSACTION)
    def is_transaction(self) -> bool:
        return isinstance(self, AbiMethodArgType.TRANSACTION)
    def is_REFERENCE(self) -> bool:
        return isinstance(self, AbiMethodArgType.REFERENCE)
    def is_reference(self) -> bool:
        return isinstance(self, AbiMethodArgType.REFERENCE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AbiMethodArgType.VALUE = type("AbiMethodArgType.VALUE", (AbiMethodArgType.VALUE, AbiMethodArgType,), {})  # type: ignore
AbiMethodArgType.TRANSACTION = type("AbiMethodArgType.TRANSACTION", (AbiMethodArgType.TRANSACTION, AbiMethodArgType,), {})  # type: ignore
AbiMethodArgType.REFERENCE = type("AbiMethodArgType.REFERENCE", (AbiMethodArgType.REFERENCE, AbiMethodArgType,), {})  # type: ignore




class _UniffiConverterTypeAbiMethodArgType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AbiMethodArgType.VALUE(
                _UniffiConverterTypeAbiType.read(buf),
            )
        if variant == 2:
            return AbiMethodArgType.TRANSACTION(
                _UniffiConverterTypeAbiTransactionType.read(buf),
            )
        if variant == 3:
            return AbiMethodArgType.REFERENCE(
                _UniffiConverterTypeAbiReferenceType.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_VALUE():
            _UniffiConverterTypeAbiType.check_lower(value._values[0])
            return
        if value.is_TRANSACTION():
            _UniffiConverterTypeAbiTransactionType.check_lower(value._values[0])
            return
        if value.is_REFERENCE():
            _UniffiConverterTypeAbiReferenceType.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_VALUE():
            buf.write_i32(1)
            _UniffiConverterTypeAbiType.write(value._values[0], buf)
        if value.is_TRANSACTION():
            buf.write_i32(2)
            _UniffiConverterTypeAbiTransactionType.write(value._values[0], buf)
        if value.is_REFERENCE():
            buf.write_i32(3)
            _UniffiConverterTypeAbiReferenceType.write(value._values[0], buf)







class AbiReferenceType(enum.Enum):
    ACCOUNT = 0
    """
    Reference to an account in the Accounts reference array
    """

    
    APPLICATION = 1
    """
    Reference to an application in the Applications reference array
    """

    
    ASSET = 2
    """
    Reference to an asset in the Assets reference array
    """

    


class _UniffiConverterTypeAbiReferenceType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AbiReferenceType.ACCOUNT
        if variant == 2:
            return AbiReferenceType.APPLICATION
        if variant == 3:
            return AbiReferenceType.ASSET
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AbiReferenceType.ACCOUNT:
            return
        if value == AbiReferenceType.APPLICATION:
            return
        if value == AbiReferenceType.ASSET:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AbiReferenceType.ACCOUNT:
            buf.write_i32(1)
        if value == AbiReferenceType.APPLICATION:
            buf.write_i32(2)
        if value == AbiReferenceType.ASSET:
            buf.write_i32(3)







class AbiReferenceValue:
    def __init__(self):
        raise RuntimeError("AbiReferenceValue cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCOUNT:
        """
        The address to an Algorand account.
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AbiReferenceValue.ACCOUNT{self._values!r}"

        def __eq__(self, other):
            if not other.is_ACCOUNT():
                return False
            return self._values == other._values
    class ASSET:
        """
        An Algorand asset ID.
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AbiReferenceValue.ASSET{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET():
                return False
            return self._values == other._values
    class APPLICATION:
        """
        An Algorand app ID.
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AbiReferenceValue.APPLICATION{self._values!r}"

        def __eq__(self, other):
            if not other.is_APPLICATION():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_ACCOUNT(self) -> bool:
        return isinstance(self, AbiReferenceValue.ACCOUNT)
    def is_account(self) -> bool:
        return isinstance(self, AbiReferenceValue.ACCOUNT)
    def is_ASSET(self) -> bool:
        return isinstance(self, AbiReferenceValue.ASSET)
    def is_asset(self) -> bool:
        return isinstance(self, AbiReferenceValue.ASSET)
    def is_APPLICATION(self) -> bool:
        return isinstance(self, AbiReferenceValue.APPLICATION)
    def is_application(self) -> bool:
        return isinstance(self, AbiReferenceValue.APPLICATION)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AbiReferenceValue.ACCOUNT = type("AbiReferenceValue.ACCOUNT", (AbiReferenceValue.ACCOUNT, AbiReferenceValue,), {})  # type: ignore
AbiReferenceValue.ASSET = type("AbiReferenceValue.ASSET", (AbiReferenceValue.ASSET, AbiReferenceValue,), {})  # type: ignore
AbiReferenceValue.APPLICATION = type("AbiReferenceValue.APPLICATION", (AbiReferenceValue.APPLICATION, AbiReferenceValue,), {})  # type: ignore




class _UniffiConverterTypeAbiReferenceValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AbiReferenceValue.ACCOUNT(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return AbiReferenceValue.ASSET(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return AbiReferenceValue.APPLICATION(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ACCOUNT():
            _UniffiConverterString.check_lower(value._values[0])
            return
        if value.is_ASSET():
            _UniffiConverterUInt64.check_lower(value._values[0])
            return
        if value.is_APPLICATION():
            _UniffiConverterUInt64.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ACCOUNT():
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if value.is_ASSET():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value._values[0], buf)
        if value.is_APPLICATION():
            buf.write_i32(3)
            _UniffiConverterUInt64.write(value._values[0], buf)







class AbiTransactionType(enum.Enum):
    TXN = 0
    """
    Any transaction type
    """

    
    PAYMENT = 1
    """
    Payment (algo transfer)
    """

    
    KEY_REGISTRATION = 2
    """
    Key registration (configure consensus participation)
    """

    
    ASSET_CONFIG = 3
    """
    Asset configuration (create, configure, or destroy ASAs)
    """

    
    ASSET_TRANSFER = 4
    """
    Asset transfer (ASA transfer)
    """

    
    ASSET_FREEZE = 5
    """
    Asset freeze (freeze or unfreeze ASAs)
    """

    
    APP_CALL = 6
    """
    App call (create, update, delete and call an app)
    """

    


class _UniffiConverterTypeAbiTransactionType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AbiTransactionType.TXN
        if variant == 2:
            return AbiTransactionType.PAYMENT
        if variant == 3:
            return AbiTransactionType.KEY_REGISTRATION
        if variant == 4:
            return AbiTransactionType.ASSET_CONFIG
        if variant == 5:
            return AbiTransactionType.ASSET_TRANSFER
        if variant == 6:
            return AbiTransactionType.ASSET_FREEZE
        if variant == 7:
            return AbiTransactionType.APP_CALL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AbiTransactionType.TXN:
            return
        if value == AbiTransactionType.PAYMENT:
            return
        if value == AbiTransactionType.KEY_REGISTRATION:
            return
        if value == AbiTransactionType.ASSET_CONFIG:
            return
        if value == AbiTransactionType.ASSET_TRANSFER:
            return
        if value == AbiTransactionType.ASSET_FREEZE:
            return
        if value == AbiTransactionType.APP_CALL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AbiTransactionType.TXN:
            buf.write_i32(1)
        if value == AbiTransactionType.PAYMENT:
            buf.write_i32(2)
        if value == AbiTransactionType.KEY_REGISTRATION:
            buf.write_i32(3)
        if value == AbiTransactionType.ASSET_CONFIG:
            buf.write_i32(4)
        if value == AbiTransactionType.ASSET_TRANSFER:
            buf.write_i32(5)
        if value == AbiTransactionType.ASSET_FREEZE:
            buf.write_i32(6)
        if value == AbiTransactionType.APP_CALL:
            buf.write_i32(7)







class AppMethodCallArg:
    def __init__(self):
        raise RuntimeError("AppMethodCallArg cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ABI_REFERENCE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ABI_REFERENCE{self._values!r}"

        def __eq__(self, other):
            if not other.is_ABI_REFERENCE():
                return False
            return self._values == other._values
    class DEFAULT_VALUE:
        """
        Sentinel to request ARC-56 default resolution for this argument (handled by AppClient params builder)
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "AppMethodCallArg.DEFAULT_VALUE()".format()

        def __eq__(self, other):
            if not other.is_DEFAULT_VALUE():
                return False
            return True
    
    class TRANSACTION_PLACE_HOLDER:
        """
        Placeholder for a transaction-typed argument. Not encoded; satisfied by a transaction
        included in the same group (extracted from other method call arguments).
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "AppMethodCallArg.TRANSACTION_PLACE_HOLDER()".format()

        def __eq__(self, other):
            if not other.is_TRANSACTION_PLACE_HOLDER():
                return False
            return True
    
    class ABI_VALUE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ABI_VALUE{self._values!r}"

        def __eq__(self, other):
            if not other.is_ABI_VALUE():
                return False
            return self._values == other._values
    class APP_CREATE_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_CREATE_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_CREATE_CALL():
                return False
            return self._values == other._values
    class APP_UPDATE_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_UPDATE_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_UPDATE_CALL():
                return False
            return self._values == other._values
    class APP_DELETE_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_DELETE_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_DELETE_CALL():
                return False
            return self._values == other._values
    class APP_CALL_METHOD_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_CALL_METHOD_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_CALL_METHOD_CALL():
                return False
            return self._values == other._values
    class APP_CREATE_METHOD_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_CREATE_METHOD_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_CREATE_METHOD_CALL():
                return False
            return self._values == other._values
    class APP_UPDATE_METHOD_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_UPDATE_METHOD_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_UPDATE_METHOD_CALL():
                return False
            return self._values == other._values
    class APP_DELETE_METHOD_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_DELETE_METHOD_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_DELETE_METHOD_CALL():
                return False
            return self._values == other._values
    class TRANSACTION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.TRANSACTION{self._values!r}"

        def __eq__(self, other):
            if not other.is_TRANSACTION():
                return False
            return self._values == other._values
    class TRANSACTION_WITH_SIGNER:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.TRANSACTION_WITH_SIGNER{self._values!r}"

        def __eq__(self, other):
            if not other.is_TRANSACTION_WITH_SIGNER():
                return False
            return self._values == other._values
    class PAYMENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.PAYMENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_PAYMENT():
                return False
            return self._values == other._values
    class ACCOUNT_CLOSE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ACCOUNT_CLOSE{self._values!r}"

        def __eq__(self, other):
            if not other.is_ACCOUNT_CLOSE():
                return False
            return self._values == other._values
    class ASSET_TRANSFER:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_TRANSFER{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_TRANSFER():
                return False
            return self._values == other._values
    class ASSET_OPT_IN:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_OPT_IN{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_OPT_IN():
                return False
            return self._values == other._values
    class ASSET_OPT_OUT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_OPT_OUT{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_OPT_OUT():
                return False
            return self._values == other._values
    class ASSET_CLAWBACK:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_CLAWBACK{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_CLAWBACK():
                return False
            return self._values == other._values
    class ASSET_CREATE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_CREATE{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_CREATE():
                return False
            return self._values == other._values
    class ASSET_CONFIG:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_CONFIG{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_CONFIG():
                return False
            return self._values == other._values
    class ASSET_DESTROY:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_DESTROY{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_DESTROY():
                return False
            return self._values == other._values
    class ASSET_FREEZE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_FREEZE{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_FREEZE():
                return False
            return self._values == other._values
    class ASSET_UNFREEZE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ASSET_UNFREEZE{self._values!r}"

        def __eq__(self, other):
            if not other.is_ASSET_UNFREEZE():
                return False
            return self._values == other._values
    class APP_CALL:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.APP_CALL{self._values!r}"

        def __eq__(self, other):
            if not other.is_APP_CALL():
                return False
            return self._values == other._values
    class ONLINE_KEY_REGISTRATION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.ONLINE_KEY_REGISTRATION{self._values!r}"

        def __eq__(self, other):
            if not other.is_ONLINE_KEY_REGISTRATION():
                return False
            return self._values == other._values
    class OFFLINE_KEY_REGISTRATION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.OFFLINE_KEY_REGISTRATION{self._values!r}"

        def __eq__(self, other):
            if not other.is_OFFLINE_KEY_REGISTRATION():
                return False
            return self._values == other._values
    class NON_PARTICIPATION_KEY_REGISTRATION:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION{self._values!r}"

        def __eq__(self, other):
            if not other.is_NON_PARTICIPATION_KEY_REGISTRATION():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_ABI_REFERENCE(self) -> bool:
        return isinstance(self, AppMethodCallArg.ABI_REFERENCE)
    def is_abi_reference(self) -> bool:
        return isinstance(self, AppMethodCallArg.ABI_REFERENCE)
    def is_DEFAULT_VALUE(self) -> bool:
        return isinstance(self, AppMethodCallArg.DEFAULT_VALUE)
    def is_default_value(self) -> bool:
        return isinstance(self, AppMethodCallArg.DEFAULT_VALUE)
    def is_TRANSACTION_PLACE_HOLDER(self) -> bool:
        return isinstance(self, AppMethodCallArg.TRANSACTION_PLACE_HOLDER)
    def is_transaction_place_holder(self) -> bool:
        return isinstance(self, AppMethodCallArg.TRANSACTION_PLACE_HOLDER)
    def is_ABI_VALUE(self) -> bool:
        return isinstance(self, AppMethodCallArg.ABI_VALUE)
    def is_abi_value(self) -> bool:
        return isinstance(self, AppMethodCallArg.ABI_VALUE)
    def is_APP_CREATE_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CREATE_CALL)
    def is_app_create_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CREATE_CALL)
    def is_APP_UPDATE_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_UPDATE_CALL)
    def is_app_update_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_UPDATE_CALL)
    def is_APP_DELETE_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_DELETE_CALL)
    def is_app_delete_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_DELETE_CALL)
    def is_APP_CALL_METHOD_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CALL_METHOD_CALL)
    def is_app_call_method_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CALL_METHOD_CALL)
    def is_APP_CREATE_METHOD_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CREATE_METHOD_CALL)
    def is_app_create_method_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CREATE_METHOD_CALL)
    def is_APP_UPDATE_METHOD_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_UPDATE_METHOD_CALL)
    def is_app_update_method_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_UPDATE_METHOD_CALL)
    def is_APP_DELETE_METHOD_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_DELETE_METHOD_CALL)
    def is_app_delete_method_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_DELETE_METHOD_CALL)
    def is_TRANSACTION(self) -> bool:
        return isinstance(self, AppMethodCallArg.TRANSACTION)
    def is_transaction(self) -> bool:
        return isinstance(self, AppMethodCallArg.TRANSACTION)
    def is_TRANSACTION_WITH_SIGNER(self) -> bool:
        return isinstance(self, AppMethodCallArg.TRANSACTION_WITH_SIGNER)
    def is_transaction_with_signer(self) -> bool:
        return isinstance(self, AppMethodCallArg.TRANSACTION_WITH_SIGNER)
    def is_PAYMENT(self) -> bool:
        return isinstance(self, AppMethodCallArg.PAYMENT)
    def is_payment(self) -> bool:
        return isinstance(self, AppMethodCallArg.PAYMENT)
    def is_ACCOUNT_CLOSE(self) -> bool:
        return isinstance(self, AppMethodCallArg.ACCOUNT_CLOSE)
    def is_account_close(self) -> bool:
        return isinstance(self, AppMethodCallArg.ACCOUNT_CLOSE)
    def is_ASSET_TRANSFER(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_TRANSFER)
    def is_asset_transfer(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_TRANSFER)
    def is_ASSET_OPT_IN(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_OPT_IN)
    def is_asset_opt_in(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_OPT_IN)
    def is_ASSET_OPT_OUT(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_OPT_OUT)
    def is_asset_opt_out(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_OPT_OUT)
    def is_ASSET_CLAWBACK(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_CLAWBACK)
    def is_asset_clawback(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_CLAWBACK)
    def is_ASSET_CREATE(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_CREATE)
    def is_asset_create(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_CREATE)
    def is_ASSET_CONFIG(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_CONFIG)
    def is_asset_config(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_CONFIG)
    def is_ASSET_DESTROY(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_DESTROY)
    def is_asset_destroy(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_DESTROY)
    def is_ASSET_FREEZE(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_FREEZE)
    def is_asset_freeze(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_FREEZE)
    def is_ASSET_UNFREEZE(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_UNFREEZE)
    def is_asset_unfreeze(self) -> bool:
        return isinstance(self, AppMethodCallArg.ASSET_UNFREEZE)
    def is_APP_CALL(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CALL)
    def is_app_call(self) -> bool:
        return isinstance(self, AppMethodCallArg.APP_CALL)
    def is_ONLINE_KEY_REGISTRATION(self) -> bool:
        return isinstance(self, AppMethodCallArg.ONLINE_KEY_REGISTRATION)
    def is_online_key_registration(self) -> bool:
        return isinstance(self, AppMethodCallArg.ONLINE_KEY_REGISTRATION)
    def is_OFFLINE_KEY_REGISTRATION(self) -> bool:
        return isinstance(self, AppMethodCallArg.OFFLINE_KEY_REGISTRATION)
    def is_offline_key_registration(self) -> bool:
        return isinstance(self, AppMethodCallArg.OFFLINE_KEY_REGISTRATION)
    def is_NON_PARTICIPATION_KEY_REGISTRATION(self) -> bool:
        return isinstance(self, AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION)
    def is_non_participation_key_registration(self) -> bool:
        return isinstance(self, AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AppMethodCallArg.ABI_REFERENCE = type("AppMethodCallArg.ABI_REFERENCE", (AppMethodCallArg.ABI_REFERENCE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.DEFAULT_VALUE = type("AppMethodCallArg.DEFAULT_VALUE", (AppMethodCallArg.DEFAULT_VALUE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.TRANSACTION_PLACE_HOLDER = type("AppMethodCallArg.TRANSACTION_PLACE_HOLDER", (AppMethodCallArg.TRANSACTION_PLACE_HOLDER, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ABI_VALUE = type("AppMethodCallArg.ABI_VALUE", (AppMethodCallArg.ABI_VALUE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_CREATE_CALL = type("AppMethodCallArg.APP_CREATE_CALL", (AppMethodCallArg.APP_CREATE_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_UPDATE_CALL = type("AppMethodCallArg.APP_UPDATE_CALL", (AppMethodCallArg.APP_UPDATE_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_DELETE_CALL = type("AppMethodCallArg.APP_DELETE_CALL", (AppMethodCallArg.APP_DELETE_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_CALL_METHOD_CALL = type("AppMethodCallArg.APP_CALL_METHOD_CALL", (AppMethodCallArg.APP_CALL_METHOD_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_CREATE_METHOD_CALL = type("AppMethodCallArg.APP_CREATE_METHOD_CALL", (AppMethodCallArg.APP_CREATE_METHOD_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_UPDATE_METHOD_CALL = type("AppMethodCallArg.APP_UPDATE_METHOD_CALL", (AppMethodCallArg.APP_UPDATE_METHOD_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_DELETE_METHOD_CALL = type("AppMethodCallArg.APP_DELETE_METHOD_CALL", (AppMethodCallArg.APP_DELETE_METHOD_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.TRANSACTION = type("AppMethodCallArg.TRANSACTION", (AppMethodCallArg.TRANSACTION, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.TRANSACTION_WITH_SIGNER = type("AppMethodCallArg.TRANSACTION_WITH_SIGNER", (AppMethodCallArg.TRANSACTION_WITH_SIGNER, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.PAYMENT = type("AppMethodCallArg.PAYMENT", (AppMethodCallArg.PAYMENT, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ACCOUNT_CLOSE = type("AppMethodCallArg.ACCOUNT_CLOSE", (AppMethodCallArg.ACCOUNT_CLOSE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_TRANSFER = type("AppMethodCallArg.ASSET_TRANSFER", (AppMethodCallArg.ASSET_TRANSFER, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_OPT_IN = type("AppMethodCallArg.ASSET_OPT_IN", (AppMethodCallArg.ASSET_OPT_IN, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_OPT_OUT = type("AppMethodCallArg.ASSET_OPT_OUT", (AppMethodCallArg.ASSET_OPT_OUT, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_CLAWBACK = type("AppMethodCallArg.ASSET_CLAWBACK", (AppMethodCallArg.ASSET_CLAWBACK, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_CREATE = type("AppMethodCallArg.ASSET_CREATE", (AppMethodCallArg.ASSET_CREATE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_CONFIG = type("AppMethodCallArg.ASSET_CONFIG", (AppMethodCallArg.ASSET_CONFIG, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_DESTROY = type("AppMethodCallArg.ASSET_DESTROY", (AppMethodCallArg.ASSET_DESTROY, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_FREEZE = type("AppMethodCallArg.ASSET_FREEZE", (AppMethodCallArg.ASSET_FREEZE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ASSET_UNFREEZE = type("AppMethodCallArg.ASSET_UNFREEZE", (AppMethodCallArg.ASSET_UNFREEZE, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.APP_CALL = type("AppMethodCallArg.APP_CALL", (AppMethodCallArg.APP_CALL, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.ONLINE_KEY_REGISTRATION = type("AppMethodCallArg.ONLINE_KEY_REGISTRATION", (AppMethodCallArg.ONLINE_KEY_REGISTRATION, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.OFFLINE_KEY_REGISTRATION = type("AppMethodCallArg.OFFLINE_KEY_REGISTRATION", (AppMethodCallArg.OFFLINE_KEY_REGISTRATION, AppMethodCallArg,), {})  # type: ignore
AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION = type("AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION", (AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION, AppMethodCallArg,), {})  # type: ignore




class _UniffiConverterTypeAppMethodCallArg(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AppMethodCallArg.ABI_REFERENCE(
                _UniffiConverterTypeAbiReferenceValue.read(buf),
            )
        if variant == 2:
            return AppMethodCallArg.DEFAULT_VALUE(
            )
        if variant == 3:
            return AppMethodCallArg.TRANSACTION_PLACE_HOLDER(
            )
        if variant == 4:
            return AppMethodCallArg.ABI_VALUE(
                _UniffiConverterTypeAbiValue.read(buf),
            )
        if variant == 5:
            return AppMethodCallArg.APP_CREATE_CALL(
                _UniffiConverterTypeAppCreateParams.read(buf),
            )
        if variant == 6:
            return AppMethodCallArg.APP_UPDATE_CALL(
                _UniffiConverterTypeAppUpdateParams.read(buf),
            )
        if variant == 7:
            return AppMethodCallArg.APP_DELETE_CALL(
                _UniffiConverterTypeAppDeleteParams.read(buf),
            )
        if variant == 8:
            return AppMethodCallArg.APP_CALL_METHOD_CALL(
                _UniffiConverterTypeAppCallMethodCallParams.read(buf),
            )
        if variant == 9:
            return AppMethodCallArg.APP_CREATE_METHOD_CALL(
                _UniffiConverterTypeAppCreateMethodCallParams.read(buf),
            )
        if variant == 10:
            return AppMethodCallArg.APP_UPDATE_METHOD_CALL(
                _UniffiConverterTypeAppUpdateMethodCallParams.read(buf),
            )
        if variant == 11:
            return AppMethodCallArg.APP_DELETE_METHOD_CALL(
                _UniffiConverterTypeAppDeleteMethodCallParams.read(buf),
            )
        if variant == 12:
            return AppMethodCallArg.TRANSACTION(
                _UniffiConverterTypeTransaction.read(buf),
            )
        if variant == 13:
            return AppMethodCallArg.TRANSACTION_WITH_SIGNER(
                _UniffiConverterTypeTransactionWithSigner.read(buf),
            )
        if variant == 14:
            return AppMethodCallArg.PAYMENT(
                _UniffiConverterTypePaymentParams.read(buf),
            )
        if variant == 15:
            return AppMethodCallArg.ACCOUNT_CLOSE(
                _UniffiConverterTypeAccountCloseParams.read(buf),
            )
        if variant == 16:
            return AppMethodCallArg.ASSET_TRANSFER(
                _UniffiConverterTypeAssetTransferParams.read(buf),
            )
        if variant == 17:
            return AppMethodCallArg.ASSET_OPT_IN(
                _UniffiConverterTypeAssetOptInParams.read(buf),
            )
        if variant == 18:
            return AppMethodCallArg.ASSET_OPT_OUT(
                _UniffiConverterTypeAssetOptOutParams.read(buf),
            )
        if variant == 19:
            return AppMethodCallArg.ASSET_CLAWBACK(
                _UniffiConverterTypeAssetClawbackParams.read(buf),
            )
        if variant == 20:
            return AppMethodCallArg.ASSET_CREATE(
                _UniffiConverterTypeAssetCreateParams.read(buf),
            )
        if variant == 21:
            return AppMethodCallArg.ASSET_CONFIG(
                _UniffiConverterTypeAssetConfigParams.read(buf),
            )
        if variant == 22:
            return AppMethodCallArg.ASSET_DESTROY(
                _UniffiConverterTypeAssetDestroyParams.read(buf),
            )
        if variant == 23:
            return AppMethodCallArg.ASSET_FREEZE(
                _UniffiConverterTypeAssetFreezeParams.read(buf),
            )
        if variant == 24:
            return AppMethodCallArg.ASSET_UNFREEZE(
                _UniffiConverterTypeAssetUnfreezeParams.read(buf),
            )
        if variant == 25:
            return AppMethodCallArg.APP_CALL(
                _UniffiConverterTypeAppCallParams.read(buf),
            )
        if variant == 26:
            return AppMethodCallArg.ONLINE_KEY_REGISTRATION(
                _UniffiConverterTypeOnlineKeyRegistrationParams.read(buf),
            )
        if variant == 27:
            return AppMethodCallArg.OFFLINE_KEY_REGISTRATION(
                _UniffiConverterTypeOfflineKeyRegistrationParams.read(buf),
            )
        if variant == 28:
            return AppMethodCallArg.NON_PARTICIPATION_KEY_REGISTRATION(
                _UniffiConverterTypeNonParticipationKeyRegistrationParams.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_ABI_REFERENCE():
            _UniffiConverterTypeAbiReferenceValue.check_lower(value._values[0])
            return
        if value.is_DEFAULT_VALUE():
            return
        if value.is_TRANSACTION_PLACE_HOLDER():
            return
        if value.is_ABI_VALUE():
            _UniffiConverterTypeAbiValue.check_lower(value._values[0])
            return
        if value.is_APP_CREATE_CALL():
            _UniffiConverterTypeAppCreateParams.check_lower(value._values[0])
            return
        if value.is_APP_UPDATE_CALL():
            _UniffiConverterTypeAppUpdateParams.check_lower(value._values[0])
            return
        if value.is_APP_DELETE_CALL():
            _UniffiConverterTypeAppDeleteParams.check_lower(value._values[0])
            return
        if value.is_APP_CALL_METHOD_CALL():
            _UniffiConverterTypeAppCallMethodCallParams.check_lower(value._values[0])
            return
        if value.is_APP_CREATE_METHOD_CALL():
            _UniffiConverterTypeAppCreateMethodCallParams.check_lower(value._values[0])
            return
        if value.is_APP_UPDATE_METHOD_CALL():
            _UniffiConverterTypeAppUpdateMethodCallParams.check_lower(value._values[0])
            return
        if value.is_APP_DELETE_METHOD_CALL():
            _UniffiConverterTypeAppDeleteMethodCallParams.check_lower(value._values[0])
            return
        if value.is_TRANSACTION():
            _UniffiConverterTypeTransaction.check_lower(value._values[0])
            return
        if value.is_TRANSACTION_WITH_SIGNER():
            _UniffiConverterTypeTransactionWithSigner.check_lower(value._values[0])
            return
        if value.is_PAYMENT():
            _UniffiConverterTypePaymentParams.check_lower(value._values[0])
            return
        if value.is_ACCOUNT_CLOSE():
            _UniffiConverterTypeAccountCloseParams.check_lower(value._values[0])
            return
        if value.is_ASSET_TRANSFER():
            _UniffiConverterTypeAssetTransferParams.check_lower(value._values[0])
            return
        if value.is_ASSET_OPT_IN():
            _UniffiConverterTypeAssetOptInParams.check_lower(value._values[0])
            return
        if value.is_ASSET_OPT_OUT():
            _UniffiConverterTypeAssetOptOutParams.check_lower(value._values[0])
            return
        if value.is_ASSET_CLAWBACK():
            _UniffiConverterTypeAssetClawbackParams.check_lower(value._values[0])
            return
        if value.is_ASSET_CREATE():
            _UniffiConverterTypeAssetCreateParams.check_lower(value._values[0])
            return
        if value.is_ASSET_CONFIG():
            _UniffiConverterTypeAssetConfigParams.check_lower(value._values[0])
            return
        if value.is_ASSET_DESTROY():
            _UniffiConverterTypeAssetDestroyParams.check_lower(value._values[0])
            return
        if value.is_ASSET_FREEZE():
            _UniffiConverterTypeAssetFreezeParams.check_lower(value._values[0])
            return
        if value.is_ASSET_UNFREEZE():
            _UniffiConverterTypeAssetUnfreezeParams.check_lower(value._values[0])
            return
        if value.is_APP_CALL():
            _UniffiConverterTypeAppCallParams.check_lower(value._values[0])
            return
        if value.is_ONLINE_KEY_REGISTRATION():
            _UniffiConverterTypeOnlineKeyRegistrationParams.check_lower(value._values[0])
            return
        if value.is_OFFLINE_KEY_REGISTRATION():
            _UniffiConverterTypeOfflineKeyRegistrationParams.check_lower(value._values[0])
            return
        if value.is_NON_PARTICIPATION_KEY_REGISTRATION():
            _UniffiConverterTypeNonParticipationKeyRegistrationParams.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_ABI_REFERENCE():
            buf.write_i32(1)
            _UniffiConverterTypeAbiReferenceValue.write(value._values[0], buf)
        if value.is_DEFAULT_VALUE():
            buf.write_i32(2)
        if value.is_TRANSACTION_PLACE_HOLDER():
            buf.write_i32(3)
        if value.is_ABI_VALUE():
            buf.write_i32(4)
            _UniffiConverterTypeAbiValue.write(value._values[0], buf)
        if value.is_APP_CREATE_CALL():
            buf.write_i32(5)
            _UniffiConverterTypeAppCreateParams.write(value._values[0], buf)
        if value.is_APP_UPDATE_CALL():
            buf.write_i32(6)
            _UniffiConverterTypeAppUpdateParams.write(value._values[0], buf)
        if value.is_APP_DELETE_CALL():
            buf.write_i32(7)
            _UniffiConverterTypeAppDeleteParams.write(value._values[0], buf)
        if value.is_APP_CALL_METHOD_CALL():
            buf.write_i32(8)
            _UniffiConverterTypeAppCallMethodCallParams.write(value._values[0], buf)
        if value.is_APP_CREATE_METHOD_CALL():
            buf.write_i32(9)
            _UniffiConverterTypeAppCreateMethodCallParams.write(value._values[0], buf)
        if value.is_APP_UPDATE_METHOD_CALL():
            buf.write_i32(10)
            _UniffiConverterTypeAppUpdateMethodCallParams.write(value._values[0], buf)
        if value.is_APP_DELETE_METHOD_CALL():
            buf.write_i32(11)
            _UniffiConverterTypeAppDeleteMethodCallParams.write(value._values[0], buf)
        if value.is_TRANSACTION():
            buf.write_i32(12)
            _UniffiConverterTypeTransaction.write(value._values[0], buf)
        if value.is_TRANSACTION_WITH_SIGNER():
            buf.write_i32(13)
            _UniffiConverterTypeTransactionWithSigner.write(value._values[0], buf)
        if value.is_PAYMENT():
            buf.write_i32(14)
            _UniffiConverterTypePaymentParams.write(value._values[0], buf)
        if value.is_ACCOUNT_CLOSE():
            buf.write_i32(15)
            _UniffiConverterTypeAccountCloseParams.write(value._values[0], buf)
        if value.is_ASSET_TRANSFER():
            buf.write_i32(16)
            _UniffiConverterTypeAssetTransferParams.write(value._values[0], buf)
        if value.is_ASSET_OPT_IN():
            buf.write_i32(17)
            _UniffiConverterTypeAssetOptInParams.write(value._values[0], buf)
        if value.is_ASSET_OPT_OUT():
            buf.write_i32(18)
            _UniffiConverterTypeAssetOptOutParams.write(value._values[0], buf)
        if value.is_ASSET_CLAWBACK():
            buf.write_i32(19)
            _UniffiConverterTypeAssetClawbackParams.write(value._values[0], buf)
        if value.is_ASSET_CREATE():
            buf.write_i32(20)
            _UniffiConverterTypeAssetCreateParams.write(value._values[0], buf)
        if value.is_ASSET_CONFIG():
            buf.write_i32(21)
            _UniffiConverterTypeAssetConfigParams.write(value._values[0], buf)
        if value.is_ASSET_DESTROY():
            buf.write_i32(22)
            _UniffiConverterTypeAssetDestroyParams.write(value._values[0], buf)
        if value.is_ASSET_FREEZE():
            buf.write_i32(23)
            _UniffiConverterTypeAssetFreezeParams.write(value._values[0], buf)
        if value.is_ASSET_UNFREEZE():
            buf.write_i32(24)
            _UniffiConverterTypeAssetUnfreezeParams.write(value._values[0], buf)
        if value.is_APP_CALL():
            buf.write_i32(25)
            _UniffiConverterTypeAppCallParams.write(value._values[0], buf)
        if value.is_ONLINE_KEY_REGISTRATION():
            buf.write_i32(26)
            _UniffiConverterTypeOnlineKeyRegistrationParams.write(value._values[0], buf)
        if value.is_OFFLINE_KEY_REGISTRATION():
            buf.write_i32(27)
            _UniffiConverterTypeOfflineKeyRegistrationParams.write(value._values[0], buf)
        if value.is_NON_PARTICIPATION_KEY_REGISTRATION():
            buf.write_i32(28)
            _UniffiConverterTypeNonParticipationKeyRegistrationParams.write(value._values[0], buf)







class StructFieldType:
    def __init__(self):
        raise RuntimeError("StructFieldType cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TYPE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"StructFieldType.TYPE{self._values!r}"

        def __eq__(self, other):
            if not other.is_TYPE():
                return False
            return self._values == other._values
    class FIELDS:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"StructFieldType.FIELDS{self._values!r}"

        def __eq__(self, other):
            if not other.is_FIELDS():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_TYPE(self) -> bool:
        return isinstance(self, StructFieldType.TYPE)
    def is_type(self) -> bool:
        return isinstance(self, StructFieldType.TYPE)
    def is_FIELDS(self) -> bool:
        return isinstance(self, StructFieldType.FIELDS)
    def is_fields(self) -> bool:
        return isinstance(self, StructFieldType.FIELDS)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
StructFieldType.TYPE = type("StructFieldType.TYPE", (StructFieldType.TYPE, StructFieldType,), {})  # type: ignore
StructFieldType.FIELDS = type("StructFieldType.FIELDS", (StructFieldType.FIELDS, StructFieldType,), {})  # type: ignore




class _UniffiConverterTypeStructFieldType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return StructFieldType.TYPE(
                _UniffiConverterTypeAbiType.read(buf),
            )
        if variant == 2:
            return StructFieldType.FIELDS(
                _UniffiConverterSequenceTypeStructField.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_TYPE():
            _UniffiConverterTypeAbiType.check_lower(value._values[0])
            return
        if value.is_FIELDS():
            _UniffiConverterSequenceTypeStructField.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_TYPE():
            buf.write_i32(1)
            _UniffiConverterTypeAbiType.write(value._values[0], buf)
        if value.is_FIELDS():
            buf.write_i32(2)
            _UniffiConverterSequenceTypeStructField.write(value._values[0], buf)




# UtilsError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class UtilsError(Exception):
    pass

_UniffiTempUtilsError = UtilsError

class UtilsError:  # type: ignore
    class UtilsError(_UniffiTempUtilsError):
        def __init__(self, message):
            super().__init__(", ".join([
                "message={!r}".format(message),
            ]))
            self.message = message

        def __repr__(self):
            return "UtilsError.UtilsError({})".format(str(self))
    _UniffiTempUtilsError.UtilsError = UtilsError # type: ignore

UtilsError = _UniffiTempUtilsError # type: ignore
del _UniffiTempUtilsError


class _UniffiConverterTypeUtilsError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UtilsError.UtilsError(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, UtilsError.UtilsError):
            _UniffiConverterString.check_lower(value.message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, UtilsError.UtilsError):
            buf.write_i32(1)
            _UniffiConverterString.write(value.message, buf)



class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBool.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBool.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBool.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAbiType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAbiType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAbiType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAbiType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionSigner(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionSigner.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionSigner.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionSigner.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeStateSchema(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeStateSchema.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeStateSchema.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeStateSchema.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTestAccount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTestAccount.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTestAccount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTestAccount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeBoxReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeBoxReference.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeBoxReference.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeBoxReference.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt32.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt32.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBytes.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAbiType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAbiType.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAbiType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAbiType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAbiValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAbiValue.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAbiValue.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAbiValue.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeStructField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeStructField.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeStructField.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeStructField.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeBoxReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeBoxReference.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeBoxReference.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeBoxReference.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSignedTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSignedTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSignedTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSignedTransaction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTransaction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAbiMethodArg(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAbiMethodArg.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAbiMethodArg.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAbiMethodArg.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTestResult(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTestResult.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTestResult.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTestResult.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAppMethodCallArg(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAppMethodCallArg.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAppMethodCallArg.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAppMethodCallArg.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterOptionalUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterOptionalUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterOptionalUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringTypeAbiValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterTypeAbiValue.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterTypeAbiValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterTypeAbiValue.read(buf)
            d[key] = val
        return d

# objects.
class AlgodClientTraitProtocol(typing.Protocol):
    def send_transaction(self, txn: "bytes"):
        raise NotImplementedError
    def get_account_info(self, address: "str"):
        raise NotImplementedError
    def get_transaction_info(self, tx_id: "str"):
        raise NotImplementedError
    def wait_for_confirmation(self, tx_id: "str"):
        raise NotImplementedError
    def get_suggested_params(self, ):
        raise NotImplementedError
# AlgodClientTrait is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class AlgodClientTrait():
    def send_transaction(self, txn: "bytes"):
        raise NotImplementedError
    def get_account_info(self, address: "str"):
        raise NotImplementedError
    def get_transaction_info(self, tx_id: "str"):
        raise NotImplementedError
    def wait_for_confirmation(self, tx_id: "str"):
        raise NotImplementedError
    def get_suggested_params(self, ):
        raise NotImplementedError
# `AlgodClientTraitImpl` is the implementation for a Rust implemented version.
class AlgodClientTraitImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_algodclienttrait, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_algodclienttrait, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def send_transaction(self, txn: "bytes") -> "str":
        _UniffiConverterBytes.check_lower(txn)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_send_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBytes.lower(txn)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def get_account_info(self, address: "str") -> "AccountInfo":
        _UniffiConverterString.check_lower(address)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_account_info(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(address)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeAccountInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def get_transaction_info(self, tx_id: "str") -> "TransactionInfo":
        _UniffiConverterString.check_lower(tx_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_transaction_info(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(tx_id)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def wait_for_confirmation(self, tx_id: "str") -> "TransactionInfo":
        _UniffiConverterString.check_lower(tx_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_wait_for_confirmation(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(tx_id)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def get_suggested_params(self, ) -> "SuggestedParams":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_algodclienttrait_get_suggested_params(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSuggestedParams.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplAlgodClientTrait:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD0
    def send_transaction(
            uniffi_handle,
            txn,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterBytes.lift(txn), )
            method = uniffi_obj.send_transaction
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD1
    def get_account_info(
            uniffi_handle,
            address,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), )
            method = uniffi_obj.get_account_info
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeAccountInfo.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD2
    def get_transaction_info(
            uniffi_handle,
            tx_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(tx_id), )
            method = uniffi_obj.get_transaction_info
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTransactionInfo.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD3
    def wait_for_confirmation(
            uniffi_handle,
            tx_id,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(tx_id), )
            method = uniffi_obj.wait_for_confirmation
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeTransactionInfo.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_ALGOD_CLIENT_TRAIT_METHOD4
    def get_suggested_params(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeAlgodClientTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.get_suggested_params
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeSuggestedParams.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeAlgodClientTrait._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceAlgodClientTrait(
        send_transaction,
        get_account_info,
        get_transaction_info,
        wait_for_confirmation,
        get_suggested_params,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_algodclienttrait(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeAlgodClientTrait:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return AlgodClientTraitImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: AlgodClientTrait):
        pass

    @staticmethod
    def lower(value: AlgodClientTraitProtocol):
        return _UniffiConverterTypeAlgodClientTrait._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AlgodClientTraitProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ComposerFactoryProtocol(typing.Protocol):
    def create_composer(self, ):
        raise NotImplementedError
# ComposerFactory is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class ComposerFactory():
    def create_composer(self, ):
        raise NotImplementedError
# `ComposerFactoryImpl` is the implementation for a Rust implemented version.
class ComposerFactoryImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composerfactory, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composerfactory, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def create_composer(self, ) -> "ComposerTrait":
        return _UniffiConverterTypeComposerTrait.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composerfactory_create_composer,self._uniffi_clone_pointer(),)
        )





# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplComposerFactory:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_FACTORY_METHOD0
    def create_composer(
            uniffi_handle,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeComposerFactory._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.create_composer
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterTypeComposerTrait.lower(v)
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeComposerFactory._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceComposerFactory(
        create_composer,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_composerfactory(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeComposerFactory:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return ComposerFactoryImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: ComposerFactory):
        pass

    @staticmethod
    def lower(value: ComposerFactoryProtocol):
        return _UniffiConverterTypeComposerFactory._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ComposerFactoryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ComposerTraitProtocol(typing.Protocol):
    def build(self, ):
        raise NotImplementedError
    def send(self, ):
        raise NotImplementedError
    def add_payment(self, params: "PaymentParams"):
        raise NotImplementedError
    def add_asset_create(self, params: "AssetCreateParams"):
        raise NotImplementedError
    def add_asset_reconfigure(self, params: "AssetConfigParams"):
        raise NotImplementedError
    def add_asset_destroy(self, params: "AssetDestroyParams"):
        raise NotImplementedError
    def add_asset_freeze(self, params: "AssetFreezeParams"):
        raise NotImplementedError
    def add_asset_unfreeze(self, params: "AssetUnfreezeParams"):
        raise NotImplementedError
    def add_asset_transfer(self, params: "AssetTransferParams"):
        raise NotImplementedError
    def add_asset_opt_in(self, params: "AssetOptInParams"):
        raise NotImplementedError
    def add_asset_opt_out(self, params: "AssetOptOutParams"):
        raise NotImplementedError
    def add_asset_clawback(self, params: "AssetClawbackParams"):
        raise NotImplementedError
    def add_app_create(self, params: "AppCreateParams"):
        raise NotImplementedError
    def add_app_call(self, params: "AppCallParams"):
        raise NotImplementedError
    def add_app_update(self, params: "AppUpdateParams"):
        raise NotImplementedError
    def add_app_delete(self, params: "AppDeleteParams"):
        raise NotImplementedError
    def add_app_call_method_call(self, params: "AppCallMethodCallParams"):
        raise NotImplementedError
    def add_app_create_method_call(self, params: "AppCreateMethodCallParams"):
        raise NotImplementedError
    def add_app_update_method_call(self, params: "AppUpdateMethodCallParams"):
        raise NotImplementedError
    def add_app_delete_method_call(self, params: "AppDeleteMethodCallParams"):
        raise NotImplementedError
# ComposerTrait is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class ComposerTrait():
    def build(self, ):
        raise NotImplementedError
    def send(self, ):
        raise NotImplementedError
    def add_payment(self, params: "PaymentParams"):
        raise NotImplementedError
    def add_asset_create(self, params: "AssetCreateParams"):
        raise NotImplementedError
    def add_asset_reconfigure(self, params: "AssetConfigParams"):
        raise NotImplementedError
    def add_asset_destroy(self, params: "AssetDestroyParams"):
        raise NotImplementedError
    def add_asset_freeze(self, params: "AssetFreezeParams"):
        raise NotImplementedError
    def add_asset_unfreeze(self, params: "AssetUnfreezeParams"):
        raise NotImplementedError
    def add_asset_transfer(self, params: "AssetTransferParams"):
        raise NotImplementedError
    def add_asset_opt_in(self, params: "AssetOptInParams"):
        raise NotImplementedError
    def add_asset_opt_out(self, params: "AssetOptOutParams"):
        raise NotImplementedError
    def add_asset_clawback(self, params: "AssetClawbackParams"):
        raise NotImplementedError
    def add_app_create(self, params: "AppCreateParams"):
        raise NotImplementedError
    def add_app_call(self, params: "AppCallParams"):
        raise NotImplementedError
    def add_app_update(self, params: "AppUpdateParams"):
        raise NotImplementedError
    def add_app_delete(self, params: "AppDeleteParams"):
        raise NotImplementedError
    def add_app_call_method_call(self, params: "AppCallMethodCallParams"):
        raise NotImplementedError
    def add_app_create_method_call(self, params: "AppCreateMethodCallParams"):
        raise NotImplementedError
    def add_app_update_method_call(self, params: "AppUpdateMethodCallParams"):
        raise NotImplementedError
    def add_app_delete_method_call(self, params: "AppDeleteMethodCallParams"):
        raise NotImplementedError
# `ComposerTraitImpl` is the implementation for a Rust implemented version.
class ComposerTraitImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composertrait, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composertrait, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def build(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_build(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def send(self, ) -> "typing.List[str]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_send(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceString.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_payment(self, params: "PaymentParams") -> None:

        _UniffiConverterTypePaymentParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_payment(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypePaymentParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_create(self, params: "AssetCreateParams") -> None:

        _UniffiConverterTypeAssetCreateParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_create(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetCreateParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_reconfigure(self, params: "AssetConfigParams") -> None:

        _UniffiConverterTypeAssetConfigParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_reconfigure(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetConfigParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_destroy(self, params: "AssetDestroyParams") -> None:

        _UniffiConverterTypeAssetDestroyParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_destroy(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetDestroyParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_freeze(self, params: "AssetFreezeParams") -> None:

        _UniffiConverterTypeAssetFreezeParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_freeze(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetFreezeParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_unfreeze(self, params: "AssetUnfreezeParams") -> None:

        _UniffiConverterTypeAssetUnfreezeParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_unfreeze(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetUnfreezeParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_transfer(self, params: "AssetTransferParams") -> None:

        _UniffiConverterTypeAssetTransferParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_transfer(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetTransferParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_opt_in(self, params: "AssetOptInParams") -> None:

        _UniffiConverterTypeAssetOptInParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_opt_in(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetOptInParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_opt_out(self, params: "AssetOptOutParams") -> None:

        _UniffiConverterTypeAssetOptOutParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_opt_out(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetOptOutParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_asset_clawback(self, params: "AssetClawbackParams") -> None:

        _UniffiConverterTypeAssetClawbackParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_asset_clawback(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAssetClawbackParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_create(self, params: "AppCreateParams") -> None:

        _UniffiConverterTypeAppCreateParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_create(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppCreateParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_call(self, params: "AppCallParams") -> None:

        _UniffiConverterTypeAppCallParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_call(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppCallParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_update(self, params: "AppUpdateParams") -> None:

        _UniffiConverterTypeAppUpdateParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_update(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppUpdateParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_delete(self, params: "AppDeleteParams") -> None:

        _UniffiConverterTypeAppDeleteParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_delete(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppDeleteParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_call_method_call(self, params: "AppCallMethodCallParams") -> None:

        _UniffiConverterTypeAppCallMethodCallParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_call_method_call(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppCallMethodCallParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_create_method_call(self, params: "AppCreateMethodCallParams") -> None:

        _UniffiConverterTypeAppCreateMethodCallParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_create_method_call(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppCreateMethodCallParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_update_method_call(self, params: "AppUpdateMethodCallParams") -> None:

        _UniffiConverterTypeAppUpdateMethodCallParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_update_method_call(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppUpdateMethodCallParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def add_app_delete_method_call(self, params: "AppDeleteMethodCallParams") -> None:

        _UniffiConverterTypeAppDeleteMethodCallParams.check_lower(params)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composertrait_add_app_delete_method_call(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAppDeleteMethodCallParams.lower(params)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplComposerTrait:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD0
    def build(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.build
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD1
    def send(
            uniffi_handle,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = ()
            method = uniffi_obj.send
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceString.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD2
    def add_payment(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypePaymentParams.lift(params), )
            method = uniffi_obj.add_payment
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD3
    def add_asset_create(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetCreateParams.lift(params), )
            method = uniffi_obj.add_asset_create
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD4
    def add_asset_reconfigure(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetConfigParams.lift(params), )
            method = uniffi_obj.add_asset_reconfigure
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD5
    def add_asset_destroy(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetDestroyParams.lift(params), )
            method = uniffi_obj.add_asset_destroy
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD6
    def add_asset_freeze(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetFreezeParams.lift(params), )
            method = uniffi_obj.add_asset_freeze
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD7
    def add_asset_unfreeze(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetUnfreezeParams.lift(params), )
            method = uniffi_obj.add_asset_unfreeze
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD8
    def add_asset_transfer(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetTransferParams.lift(params), )
            method = uniffi_obj.add_asset_transfer
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD9
    def add_asset_opt_in(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetOptInParams.lift(params), )
            method = uniffi_obj.add_asset_opt_in
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD10
    def add_asset_opt_out(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetOptOutParams.lift(params), )
            method = uniffi_obj.add_asset_opt_out
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD11
    def add_asset_clawback(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAssetClawbackParams.lift(params), )
            method = uniffi_obj.add_asset_clawback
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD12
    def add_app_create(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppCreateParams.lift(params), )
            method = uniffi_obj.add_app_create
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD13
    def add_app_call(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppCallParams.lift(params), )
            method = uniffi_obj.add_app_call
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD14
    def add_app_update(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppUpdateParams.lift(params), )
            method = uniffi_obj.add_app_update
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD15
    def add_app_delete(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppDeleteParams.lift(params), )
            method = uniffi_obj.add_app_delete
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD16
    def add_app_call_method_call(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppCallMethodCallParams.lift(params), )
            method = uniffi_obj.add_app_call_method_call
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD17
    def add_app_create_method_call(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppCreateMethodCallParams.lift(params), )
            method = uniffi_obj.add_app_create_method_call
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD18
    def add_app_update_method_call(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppUpdateMethodCallParams.lift(params), )
            method = uniffi_obj.add_app_update_method_call
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_COMPOSER_TRAIT_METHOD19
    def add_app_delete_method_call(
            uniffi_handle,
            params,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeComposerTrait._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeAppDeleteMethodCallParams.lift(params), )
            method = uniffi_obj.add_app_delete_method_call
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructVoid(
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeComposerTrait._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceComposerTrait(
        build,
        send,
        add_payment,
        add_asset_create,
        add_asset_reconfigure,
        add_asset_destroy,
        add_asset_freeze,
        add_asset_unfreeze,
        add_asset_transfer,
        add_asset_opt_in,
        add_asset_opt_out,
        add_asset_clawback,
        add_app_create,
        add_app_call,
        add_app_update,
        add_app_delete,
        add_app_call_method_call,
        add_app_create_method_call,
        add_app_update_method_call,
        add_app_delete_method_call,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_composertrait(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeComposerTrait:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return ComposerTraitImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: ComposerTrait):
        pass

    @staticmethod
    def lower(value: ComposerTraitProtocol):
        return _UniffiConverterTypeComposerTrait._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ComposerTraitProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionSignerProtocol(typing.Protocol):
    def sign_transactions(self, transactions: "typing.List[Transaction]",indices: "typing.List[int]"):
        raise NotImplementedError
    def sign_transaction(self, transaction: "Transaction"):
        raise NotImplementedError
# TransactionSigner is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class TransactionSigner():
    def sign_transactions(self, transactions: "typing.List[Transaction]",indices: "typing.List[int]"):
        raise NotImplementedError
    def sign_transaction(self, transaction: "Transaction"):
        raise NotImplementedError
# `TransactionSignerImpl` is the implementation for a Rust implemented version.
class TransactionSignerImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_transactionsigner, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_transactionsigner, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def sign_transactions(self, transactions: "typing.List[Transaction]",indices: "typing.List[int]") -> "typing.List[SignedTransaction]":
        _UniffiConverterSequenceTypeTransaction.check_lower(transactions)
        
        _UniffiConverterSequenceUInt32.check_lower(indices)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsigner_sign_transactions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeTransaction.lower(transactions),
        _UniffiConverterSequenceUInt32.lower(indices)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeSignedTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def sign_transaction(self, transaction: "Transaction") -> "SignedTransaction":
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsigner_sign_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeTransaction.lower(transaction)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSignedTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )




# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplTransactionSigner:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_METHOD0
    def sign_transactions(
            uniffi_handle,
            transactions,
            indices,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeTransactionSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterSequenceTypeTransaction.lift(transactions), _UniffiConverterSequenceUInt32.lift(indices), )
            method = uniffi_obj.sign_transactions
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterSequenceTypeSignedTransaction.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBuffer.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_METHOD1
    def sign_transaction(
            uniffi_handle,
            transaction,
            uniffi_future_callback,
            uniffi_callback_data,
            uniffi_out_return,
        ):
        uniffi_obj = _UniffiConverterTypeTransactionSigner._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeTransaction.lift(transaction), )
            method = uniffi_obj.sign_transaction
            return method(*args)

        
        def handle_success(return_value):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiConverterTypeSignedTransaction.lower(return_value),
                    _UniffiRustCallStatus.default()
                )
            )

        def handle_error(status_code, rust_buffer):
            uniffi_future_callback(
                uniffi_callback_data,
                _UniffiForeignFutureStructRustBuffer(
                    _UniffiRustBufferSignedTransaction.default(),
                    _UniffiRustCallStatus(status_code, rust_buffer),
                )
            )
        uniffi_out_return[0] = _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, UtilsError, _UniffiConverterTypeUtilsError.lower)

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeTransactionSigner._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceTransactionSigner(
        sign_transactions,
        sign_transaction,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_transactionsigner(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeTransactionSigner:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return TransactionSignerImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionSigner):
        pass

    @staticmethod
    def lower(value: TransactionSignerProtocol):
        return _UniffiConverterTypeTransactionSigner._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionSignerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionSignerGetterProtocol(typing.Protocol):
    def get_signer(self, address: "str"):
        raise NotImplementedError
    def register_account(self, address: "str",mnemonic: "str"):
        """
        Register an account with the signer getter
        This allows test fixtures to register accounts so they can be retrieved later via get_signer
        """

        raise NotImplementedError
# TransactionSignerGetter is a foreign trait so treated like a callback interface, where the
# primary use-case is the trait being implemented locally.
# It is a base-class local implementations might subclass.


class TransactionSignerGetter():
    def get_signer(self, address: "str"):
        raise NotImplementedError
    def register_account(self, address: "str",mnemonic: "str"):
        """
        Register an account with the signer getter
        This allows test fixtures to register accounts so they can be retrieved later via get_signer
        """

        raise NotImplementedError
# `TransactionSignerGetterImpl` is the implementation for a Rust implemented version.
class TransactionSignerGetterImpl():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_transactionsignergetter, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_transactionsignergetter, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_signer(self, address: "str") -> "TransactionSigner":
        _UniffiConverterString.check_lower(address)
        
        return _UniffiConverterTypeTransactionSigner.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsignergetter_get_signer,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(address))
        )





    def register_account(self, address: "str",mnemonic: "str") -> None:
        """
        Register an account with the signer getter
        This allows test fixtures to register accounts so they can be retrieved later via get_signer
        """

        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterString.check_lower(mnemonic)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_transactionsignergetter_register_account,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(address),
        _UniffiConverterString.lower(mnemonic))






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplTransactionSignerGetter:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_GETTER_METHOD0
    def get_signer(
            uniffi_handle,
            address,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeTransactionSignerGetter._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), )
            method = uniffi_obj.get_signer
            return method(*args)

        
        def write_return_value(v):
            uniffi_out_return[0] = _UniffiConverterTypeTransactionSigner.lower(v)
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                UtilsError,
                _UniffiConverterTypeUtilsError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_TRANSACTION_SIGNER_GETTER_METHOD1
    def register_account(
            uniffi_handle,
            address,
            mnemonic,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeTransactionSignerGetter._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterString.lift(address), _UniffiConverterString.lift(mnemonic), )
            method = uniffi_obj.register_account
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call_with_error(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
                UtilsError,
                _UniffiConverterTypeUtilsError.lower,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeTransactionSignerGetter._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceTransactionSignerGetter(
        get_signer,
        register_account,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_algokit_utils_ffi_fn_init_callback_vtable_transactionsignergetter(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeTransactionSignerGetter:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return TransactionSignerGetterImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionSignerGetter):
        pass

    @staticmethod
    def lower(value: TransactionSignerGetterProtocol):
        return _UniffiConverterTypeTransactionSignerGetter._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionSignerGetterProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class AbiStructProtocol(typing.Protocol):
    pass
# AbiStruct is a Rust-only trait - it's a wrapper around a Rust implementation.
class AbiStruct():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abistruct, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abistruct, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeAbiStruct:

    @staticmethod
    def lift(value: int):
        return AbiStruct._make_instance_(value)

    @staticmethod
    def check_lower(value: AbiStruct):
        if not isinstance(value, AbiStruct):
            raise TypeError("Expected AbiStruct instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AbiStructProtocol):
        if not isinstance(value, AbiStruct):
            raise TypeError("Expected AbiStruct instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AbiStructProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class AbiTypeProtocol(typing.Protocol):
    def decode(self, data: "bytes"):
        raise NotImplementedError
    def encode(self, value: "AbiValue"):
        raise NotImplementedError
    def to_string(self, ):
        raise NotImplementedError
# AbiType is a Rust-only trait - it's a wrapper around a Rust implementation.
class AbiType():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abitype, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abitype, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def address(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_address,)
        return cls._make_instance_(pointer)

    @classmethod
    def avm_bytes(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_bytes,)
        return cls._make_instance_(pointer)

    @classmethod
    def avm_string(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_string,)
        return cls._make_instance_(pointer)

    @classmethod
    def avm_uint64(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_avm_uint64,)
        return cls._make_instance_(pointer)

    @classmethod
    def bool(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_bool,)
        return cls._make_instance_(pointer)

    @classmethod
    def byte(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_byte,)
        return cls._make_instance_(pointer)

    @classmethod
    def dynamic_array(cls, element_type: "AbiType"):
        _UniffiConverterTypeAbiType.check_lower(element_type)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_dynamic_array,
        _UniffiConverterTypeAbiType.lower(element_type))
        return cls._make_instance_(pointer)

    @classmethod
    def from_string(cls, type_str: "str"):
        _UniffiConverterString.check_lower(type_str)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_from_string,
        _UniffiConverterString.lower(type_str))
        return cls._make_instance_(pointer)

    @classmethod
    def static_array(cls, element_type: "AbiType",length: "int"):
        _UniffiConverterTypeAbiType.check_lower(element_type)
        
        _UniffiConverterUInt16.check_lower(length)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_static_array,
        _UniffiConverterTypeAbiType.lower(element_type),
        _UniffiConverterUInt16.lower(length))
        return cls._make_instance_(pointer)

    @classmethod
    def string(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_string,)
        return cls._make_instance_(pointer)

    @classmethod
    def struct_fields(cls, name: "str",fields: "typing.List[StructField]"):
        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterSequenceTypeStructField.check_lower(fields)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_struct_fields,
        _UniffiConverterString.lower(name),
        _UniffiConverterSequenceTypeStructField.lower(fields))
        return cls._make_instance_(pointer)

    @classmethod
    def tuple(cls, elements: "typing.List[AbiType]"):
        _UniffiConverterSequenceTypeAbiType.check_lower(elements)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_tuple,
        _UniffiConverterSequenceTypeAbiType.lower(elements))
        return cls._make_instance_(pointer)

    @classmethod
    def ufixed(cls, bit_size: "int",precision: "int"):
        _UniffiConverterUInt16.check_lower(bit_size)
        
        _UniffiConverterUInt8.check_lower(precision)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_ufixed,
        _UniffiConverterUInt16.lower(bit_size),
        _UniffiConverterUInt8.lower(precision))
        return cls._make_instance_(pointer)

    @classmethod
    def uint(cls, bit_size: "int"):
        _UniffiConverterUInt16.check_lower(bit_size)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abitype_uint,
        _UniffiConverterUInt16.lower(bit_size))
        return cls._make_instance_(pointer)



    def decode(self, data: "bytes") -> "AbiValue":
        _UniffiConverterBytes.check_lower(data)
        
        return _UniffiConverterTypeAbiValue.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_decode,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(data))
        )





    def encode(self, value: "AbiValue") -> "bytes":
        _UniffiConverterTypeAbiValue.check_lower(value)
        
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_encode,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAbiValue.lower(value))
        )





    def to_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abitype_to_string,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAbiType:

    @staticmethod
    def lift(value: int):
        return AbiType._make_instance_(value)

    @staticmethod
    def check_lower(value: AbiType):
        if not isinstance(value, AbiType):
            raise TypeError("Expected AbiType instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AbiTypeProtocol):
        if not isinstance(value, AbiType):
            raise TypeError("Expected AbiType instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AbiTypeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class AbiValueProtocol(typing.Protocol):
    def get_address(self, ):
        raise NotImplementedError
    def get_array(self, ):
        raise NotImplementedError
    def get_big_uint(self, ):
        raise NotImplementedError
    def get_bool(self, ):
        raise NotImplementedError
    def get_byte(self, ):
        raise NotImplementedError
    def get_bytes(self, ):
        raise NotImplementedError
    def get_string(self, ):
        raise NotImplementedError
    def get_struct_fields(self, ):
        raise NotImplementedError
    def get_uint(self, ):
        raise NotImplementedError
# AbiValue is a Rust-only trait - it's a wrapper around a Rust implementation.
class AbiValue():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_abivalue, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_abivalue, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def address(cls, value: "str"):
        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_address,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def array(cls, values: "typing.List[AbiValue]"):
        _UniffiConverterSequenceTypeAbiValue.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_array,
        _UniffiConverterSequenceTypeAbiValue.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def biguint(cls, value: "bytes"):
        _UniffiConverterBytes.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_biguint,
        _UniffiConverterBytes.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def bool(cls, value: "bool"):
        _UniffiConverterBool.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_bool,
        _UniffiConverterBool.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def byte(cls, value: "int"):
        _UniffiConverterUInt8.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_byte,
        _UniffiConverterUInt8.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def bytes(cls, value: "bytes"):
        _UniffiConverterBytes.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_bytes,
        _UniffiConverterBytes.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def string(cls, value: "str"):
        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_string,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def struct_fields(cls, fields: "dict[str, AbiValue]"):
        _UniffiConverterMapStringTypeAbiValue.check_lower(fields)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_struct_fields,
        _UniffiConverterMapStringTypeAbiValue.lower(fields))
        return cls._make_instance_(pointer)

    @classmethod
    def uint(cls, value: "int"):
        _UniffiConverterUInt64.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_abivalue_uint,
        _UniffiConverterUInt64.lower(value))
        return cls._make_instance_(pointer)



    def get_address(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_address,self._uniffi_clone_pointer(),)
        )





    def get_array(self, ) -> "typing.List[AbiValue]":
        return _UniffiConverterSequenceTypeAbiValue.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_array,self._uniffi_clone_pointer(),)
        )





    def get_big_uint(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_big_uint,self._uniffi_clone_pointer(),)
        )





    def get_bool(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_bool,self._uniffi_clone_pointer(),)
        )





    def get_byte(self, ) -> "int":
        return _UniffiConverterUInt8.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_byte,self._uniffi_clone_pointer(),)
        )





    def get_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_bytes,self._uniffi_clone_pointer(),)
        )





    def get_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_string,self._uniffi_clone_pointer(),)
        )





    def get_struct_fields(self, ) -> "dict[str, AbiValue]":
        return _UniffiConverterMapStringTypeAbiValue.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_struct_fields,self._uniffi_clone_pointer(),)
        )





    def get_uint(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_get_uint,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, AbiValue):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAbiValue.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, AbiValue):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_method_abivalue_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAbiValue.lower(other)))



class _UniffiConverterTypeAbiValue:

    @staticmethod
    def lift(value: int):
        return AbiValue._make_instance_(value)

    @staticmethod
    def check_lower(value: AbiValue):
        if not isinstance(value, AbiValue):
            raise TypeError("Expected AbiValue instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AbiValueProtocol):
        if not isinstance(value, AbiValue):
            raise TypeError("Expected AbiValue instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AbiValueProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ComposerProtocol(typing.Protocol):
    def add_app_call(self, params: "AppCallParams"):
        raise NotImplementedError
    def add_app_call_method_call(self, params: "AppCallMethodCallParams"):
        raise NotImplementedError
    def add_app_create(self, params: "AppCreateParams"):
        raise NotImplementedError
    def add_app_create_method_call(self, params: "AppCreateMethodCallParams"):
        raise NotImplementedError
    def add_app_delete(self, params: "AppDeleteParams"):
        raise NotImplementedError
    def add_app_delete_method_call(self, params: "AppDeleteMethodCallParams"):
        raise NotImplementedError
    def add_app_update(self, params: "AppUpdateParams"):
        raise NotImplementedError
    def add_app_update_method_call(self, params: "AppUpdateMethodCallParams"):
        raise NotImplementedError
    def add_asset_clawback(self, params: "AssetClawbackParams"):
        raise NotImplementedError
    def add_asset_config(self, params: "AssetConfigParams"):
        raise NotImplementedError
    def add_asset_create(self, params: "AssetCreateParams"):
        raise NotImplementedError
    def add_asset_destroy(self, params: "AssetDestroyParams"):
        raise NotImplementedError
    def add_asset_freeze(self, params: "AssetFreezeParams"):
        raise NotImplementedError
    def add_asset_opt_in(self, params: "AssetOptInParams"):
        raise NotImplementedError
    def add_asset_opt_out(self, params: "AssetOptOutParams"):
        raise NotImplementedError
    def add_asset_transfer(self, params: "AssetTransferParams"):
        raise NotImplementedError
    def add_asset_unfreeze(self, params: "AssetUnfreezeParams"):
        raise NotImplementedError
    def add_payment(self, params: "PaymentParams"):
        raise NotImplementedError
    def build(self, ):
        raise NotImplementedError
    def send(self, ):
        raise NotImplementedError
# Composer is a Rust-only trait - it's a wrapper around a Rust implementation.
class Composer():
    _pointer: ctypes.c_void_p
    def __init__(self, algod_client: "AlgodClient",signer_getter: "TransactionSignerGetter"):
        _UniffiConverterTypeAlgodClient.check_lower(algod_client)
        
        _UniffiConverterTypeTransactionSignerGetter.check_lower(signer_getter)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_composer_new,
        _UniffiConverterTypeAlgodClient.lower(algod_client),
        _UniffiConverterTypeTransactionSignerGetter.lower(signer_getter))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_composer, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_composer, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add_app_call(self, params: "AppCallParams") -> None:
        _UniffiConverterTypeAppCallParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppCallParams.lower(params))






    def add_app_call_method_call(self, params: "AppCallMethodCallParams") -> None:
        _UniffiConverterTypeAppCallMethodCallParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_call_method_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppCallMethodCallParams.lower(params))






    def add_app_create(self, params: "AppCreateParams") -> None:
        _UniffiConverterTypeAppCreateParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_create,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppCreateParams.lower(params))






    def add_app_create_method_call(self, params: "AppCreateMethodCallParams") -> None:
        _UniffiConverterTypeAppCreateMethodCallParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_create_method_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppCreateMethodCallParams.lower(params))






    def add_app_delete(self, params: "AppDeleteParams") -> None:
        _UniffiConverterTypeAppDeleteParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_delete,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppDeleteParams.lower(params))






    def add_app_delete_method_call(self, params: "AppDeleteMethodCallParams") -> None:
        _UniffiConverterTypeAppDeleteMethodCallParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_delete_method_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppDeleteMethodCallParams.lower(params))






    def add_app_update(self, params: "AppUpdateParams") -> None:
        _UniffiConverterTypeAppUpdateParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_update,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppUpdateParams.lower(params))






    def add_app_update_method_call(self, params: "AppUpdateMethodCallParams") -> None:
        _UniffiConverterTypeAppUpdateMethodCallParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_app_update_method_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAppUpdateMethodCallParams.lower(params))






    def add_asset_clawback(self, params: "AssetClawbackParams") -> None:
        _UniffiConverterTypeAssetClawbackParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_clawback,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetClawbackParams.lower(params))






    def add_asset_config(self, params: "AssetConfigParams") -> None:
        _UniffiConverterTypeAssetConfigParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_config,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetConfigParams.lower(params))






    def add_asset_create(self, params: "AssetCreateParams") -> None:
        _UniffiConverterTypeAssetCreateParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_create,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetCreateParams.lower(params))






    def add_asset_destroy(self, params: "AssetDestroyParams") -> None:
        _UniffiConverterTypeAssetDestroyParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_destroy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetDestroyParams.lower(params))






    def add_asset_freeze(self, params: "AssetFreezeParams") -> None:
        _UniffiConverterTypeAssetFreezeParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_freeze,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetFreezeParams.lower(params))






    def add_asset_opt_in(self, params: "AssetOptInParams") -> None:
        _UniffiConverterTypeAssetOptInParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_opt_in,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetOptInParams.lower(params))






    def add_asset_opt_out(self, params: "AssetOptOutParams") -> None:
        _UniffiConverterTypeAssetOptOutParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_opt_out,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetOptOutParams.lower(params))






    def add_asset_transfer(self, params: "AssetTransferParams") -> None:
        _UniffiConverterTypeAssetTransferParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_transfer,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetTransferParams.lower(params))






    def add_asset_unfreeze(self, params: "AssetUnfreezeParams") -> None:
        _UniffiConverterTypeAssetUnfreezeParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_asset_unfreeze,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAssetUnfreezeParams.lower(params))






    def add_payment(self, params: "PaymentParams") -> None:
        _UniffiConverterTypePaymentParams.check_lower(params)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_add_payment,self._uniffi_clone_pointer(),
        _UniffiConverterTypePaymentParams.lower(params))





    async def build(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_build(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_void,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )



    async def send(self, ) -> "TempSendResponse":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_composer_send(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTempSendResponse.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )





class _UniffiConverterTypeComposer:

    @staticmethod
    def lift(value: int):
        return Composer._make_instance_(value)

    @staticmethod
    def check_lower(value: Composer):
        if not isinstance(value, Composer):
            raise TypeError("Expected Composer instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ComposerProtocol):
        if not isinstance(value, Composer):
            raise TypeError("Expected Composer instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ComposerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class DefaultComposerFactoryProtocol(typing.Protocol):
    pass
# DefaultComposerFactory is a Rust-only trait - it's a wrapper around a Rust implementation.
class DefaultComposerFactory():
    _pointer: ctypes.c_void_p
    def __init__(self, algod_client: "AlgodClient",signer_getter: "TransactionSignerGetter"):
        _UniffiConverterTypeAlgodClient.check_lower(algod_client)
        
        _UniffiConverterTypeTransactionSignerGetter.check_lower(signer_getter)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_defaultcomposerfactory_new,
        _UniffiConverterTypeAlgodClient.lower(algod_client),
        _UniffiConverterTypeTransactionSignerGetter.lower(signer_getter))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_defaultcomposerfactory, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_defaultcomposerfactory, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeDefaultComposerFactory:

    @staticmethod
    def lift(value: int):
        return DefaultComposerFactory._make_instance_(value)

    @staticmethod
    def check_lower(value: DefaultComposerFactory):
        if not isinstance(value, DefaultComposerFactory):
            raise TypeError("Expected DefaultComposerFactory instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DefaultComposerFactoryProtocol):
        if not isinstance(value, DefaultComposerFactory):
            raise TypeError("Expected DefaultComposerFactory instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DefaultComposerFactoryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class StructFieldProtocol(typing.Protocol):
    """
    Represents a field in a struct
    """

    pass
# StructField is a Rust-only trait - it's a wrapper around a Rust implementation.
class StructField():
    """
    Represents a field in a struct
    """

    _pointer: ctypes.c_void_p
    def __init__(self, name: "str",field_type: "StructFieldType"):
        _UniffiConverterString.check_lower(name)
        
        _UniffiConverterTypeStructFieldType.check_lower(field_type)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_constructor_structfield_new,
        _UniffiConverterString.lower(name),
        _UniffiConverterTypeStructFieldType.lower(field_type))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_structfield, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_structfield, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeStructField:

    @staticmethod
    def lift(value: int):
        return StructField._make_instance_(value)

    @staticmethod
    def check_lower(value: StructField):
        if not isinstance(value, StructField):
            raise TypeError("Expected StructField instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StructFieldProtocol):
        if not isinstance(value, StructField):
            raise TypeError("Expected StructField instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StructFieldProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TestFixtureProtocol(typing.Protocol):
    """
    Test fixture that provides high-level test operations using foreign traits
    This enables test orchestration in Rust while delegating I/O to target languages
    """

    def create_test_asset(self, creator: "TestAccount",freeze_manager: "typing.Optional[TestAccount]"):
        """
        Create a test asset with optional freeze manager
        Returns the asset ID
        """

        raise NotImplementedError
    def dispenser_account(self, ):
        """
        Get the dispenser account (useful for tests)
        """

        raise NotImplementedError
    def fund_account(self, account: "TestAccount",amount: "int"):
        """
        Fund an account with ALGO from the dispenser
        Uses the composer factory to create a fresh composer for this operation
        """

        raise NotImplementedError
    def generate_account(self, ):
        """
        Generate a new test account and register it with the signer getter
        """

        raise NotImplementedError
# TestFixture is a Rust-only trait - it's a wrapper around a Rust implementation.
class TestFixture():
    """
    Test fixture that provides high-level test operations using foreign traits
    This enables test orchestration in Rust while delegating I/O to target languages
    """

    _pointer: ctypes.c_void_p
    def __init__(self, *args, **kw):
        raise ValueError("async constructors not supported.")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_free_testfixture, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_clone_testfixture, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def create_test_asset(self, creator: "TestAccount",freeze_manager: "typing.Optional[TestAccount]") -> "int":
        """
        Create a test asset with optional freeze manager
        Returns the asset ID
        """

        _UniffiConverterTypeTestAccount.check_lower(creator)
        
        _UniffiConverterOptionalTypeTestAccount.check_lower(freeze_manager)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_create_test_asset(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeTestAccount.lower(creator),
        _UniffiConverterOptionalTypeTestAccount.lower(freeze_manager)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_u64,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_u64,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_u64,
            # lift function
            _UniffiConverterUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )




    def dispenser_account(self, ) -> "TestAccount":
        """
        Get the dispenser account (useful for tests)
        """

        return _UniffiConverterTypeTestAccount.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_dispenser_account,self._uniffi_clone_pointer(),)
        )




    async def fund_account(self, account: "TestAccount",amount: "int") -> "str":
        """
        Fund an account with ALGO from the dispenser
        Uses the composer factory to create a fresh composer for this operation
        """

        _UniffiConverterTypeTestAccount.check_lower(account)
        
        _UniffiConverterUInt64.check_lower(amount)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_fund_account(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeTestAccount.lower(account),
        _UniffiConverterUInt64.lower(amount)
            ),
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeUtilsError,

        )




    def generate_account(self, ) -> "TestAccount":
        """
        Generate a new test account and register it with the signer getter
        """

        return _UniffiConverterTypeTestAccount.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeUtilsError,_UniffiLib.uniffi_algokit_utils_ffi_fn_method_testfixture_generate_account,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTestFixture:

    @staticmethod
    def lift(value: int):
        return TestFixture._make_instance_(value)

    @staticmethod
    def check_lower(value: TestFixture):
        if not isinstance(value, TestFixture):
            raise TypeError("Expected TestFixture instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TestFixtureProtocol):
        if not isinstance(value, TestFixture):
            raise TypeError("Expected TestFixture instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TestFixtureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# External type AlgodClient: `from .algod_client_ffi import AlgodClient`

# External type BoxReference: `from algokit_transact.algokit_transact_ffi import BoxReference`

# External type SignedTransaction: `from algokit_transact.algokit_transact_ffi import SignedTransaction`

# External type StateSchema: `from algokit_transact.algokit_transact_ffi import StateSchema`

# External type Transaction: `from algokit_transact.algokit_transact_ffi import Transaction`

# External type OnApplicationComplete: `from algokit_transact.algokit_transact_ffi import OnApplicationComplete`

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)
def _uniffi_trait_interface_call_async(make_call, handle_success, handle_error):
    async def make_call_and_call_callback():
        try:
            handle_success(await make_call())
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

def _uniffi_trait_interface_call_async_with_error(make_call, handle_success, handle_error, error_type, lower_error):
    async def make_call_and_call_callback():
        try:
            try:
                handle_success(await make_call())
            except error_type as e:
                handle_error(
                    _UniffiRustCallStatus.CALL_ERROR,
                    lower_error(e),
                )
        except Exception as e:
            print("UniFFI: Unhandled exception in trait interface call", file=sys.stderr)
            traceback.print_exc(file=sys.stderr)
            handle_error(
                _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR,
                _UniffiConverterString.lower(repr(e)),
            )
    eventloop = _uniffi_get_event_loop()
    task = asyncio.run_coroutine_threadsafe(make_call_and_call_callback(), eventloop)
    handle = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert((eventloop, task))
    return _UniffiForeignFuture(handle, _uniffi_foreign_future_free)

_UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = _UniffiHandleMap()

@_UNIFFI_FOREIGN_FUTURE_FREE
def _uniffi_foreign_future_free(handle):
    (eventloop, task) = _UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle)
    eventloop.call_soon(_uniffi_foreign_future_do_free, task)

def _uniffi_foreign_future_do_free(task):
    if not task.done():
        task.cancel()
async def run_asset_freeze_test_suite(algod_client: "AlgodClientTrait",composer_factory: "ComposerFactory",signer_getter: "TransactionSignerGetter") -> "TestSuiteResult":

    """
    Run the complete asset freeze test suite
    This is the main entry point called from Python/Swift/Kotlin
    """

    _UniffiConverterTypeAlgodClientTrait.check_lower(algod_client)
    
    _UniffiConverterTypeComposerFactory.check_lower(composer_factory)
    
    _UniffiConverterTypeTransactionSignerGetter.check_lower(signer_getter)
    
    return await _uniffi_rust_call_async(
        _UniffiLib.uniffi_algokit_utils_ffi_fn_func_run_asset_freeze_test_suite(
        _UniffiConverterTypeAlgodClientTrait.lower(algod_client),
        _UniffiConverterTypeComposerFactory.lower(composer_factory),
        _UniffiConverterTypeTransactionSignerGetter.lower(signer_getter)),
        _UniffiLib.ffi_algokit_utils_ffi_rust_future_poll_rust_buffer,
        _UniffiLib.ffi_algokit_utils_ffi_rust_future_complete_rust_buffer,
        _UniffiLib.ffi_algokit_utils_ffi_rust_future_free_rust_buffer,
        # lift function
        _UniffiConverterTypeTestSuiteResult.lift,
        
    # Error FFI converter
_UniffiConverterTypeUtilsError,

    )

__all__ = [
    "InternalError",
    "AbiMethodArgType",
    "AbiReferenceType",
    "AbiReferenceValue",
    "AbiTransactionType",
    "AppMethodCallArg",
    "StructFieldType",
    "UtilsError",
    "AbiMethod",
    "AbiMethodArg",
    "AccountCloseParams",
    "AccountInfo",
    "AppCallMethodCallParams",
    "AppCallParams",
    "AppCreateMethodCallParams",
    "AppCreateParams",
    "AppDeleteMethodCallParams",
    "AppDeleteParams",
    "AppUpdateMethodCallParams",
    "AppUpdateParams",
    "AssetClawbackParams",
    "AssetConfigParams",
    "AssetCreateParams",
    "AssetDestroyParams",
    "AssetFreezeParams",
    "AssetOptInParams",
    "AssetOptOutParams",
    "AssetTransferParams",
    "AssetUnfreezeParams",
    "CommonParams",
    "NonParticipationKeyRegistrationParams",
    "OfflineKeyRegistrationParams",
    "OnlineKeyRegistrationParams",
    "PaymentParams",
    "SuggestedParams",
    "TempSendResponse",
    "TestAccount",
    "TestResult",
    "TestSuiteResult",
    "TransactionInfo",
    "TransactionWithSigner",
    "run_asset_freeze_test_suite",
    "AbiStruct",
    "AbiType",
    "AbiValue",
    "AlgodClientTrait",
    "Composer",
    "ComposerFactory",
    "ComposerTrait",
    "DefaultComposerFactory",
    "StructField",
    "TestFixture",
    "TransactionSigner",
    "TransactionSignerGetter",
]

