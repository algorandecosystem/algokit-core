/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};
{% if operation.supports_msgpack %}
use algokit_transact::AlgorandMsgpack;
{% endif %}

// Import all custom types used by this endpoint
{% set used_types = get_operation_used_types(operation) %}
{% if used_types %}
use crate::models::{
{% for used_type in used_types %}
    {{ used_type }},
{% endfor %}
};
{% endif %}

// Import request body type if needed
{% if has_request_body(operation) %}
{% set request_body_type = get_request_body_type(operation) %}
{% if should_import_request_body_type(request_body_type) %}
use crate::models::{{ request_body_type }};
{% endif %}
{% endif %}

/// struct for typed errors of method [`{{ operation.rust_function_name }}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{ operation.rust_error_enum }} {
{% for error_type in get_error_types(operation) %}
    {{ error_type }},
{% endfor %}
}

{% if operation.description %}
{{ operation.description | rust_doc_comment }}
{% elif operation.summary %}
{{ operation.summary | rust_doc_comment }}
{% endif %}
pub async fn {{ operation.rust_function_name }}(
    configuration: &configuration::Configuration,
{% if has_request_body(operation) %}
    {% set request_body_name = get_request_body_name(operation) %}
    {% set request_body_type = get_request_body_type(operation) %}
    {% if is_request_body_required(operation) %}{{ request_body_name }}: {{ request_body_type }},
    {% else %}{{ request_body_name }}: Option<{{ request_body_type }}>,
    {% endif %}
{% endif %}
{% for param in operation.parameters %}
    {% if param.required %}{{ param.rust_name }}: {% if param.rust_type == "String" %}&str{% else %}{{ param.rust_type }}{% endif %},
    {% else %}{{ param.rust_name }}: Option<{% if param.rust_type == "String" %}&str{% else %}{{ param.rust_type }}{% endif %}>,
    {% endif %}
{% endfor %}

) -> Result<{% if get_success_response_type(operation) %}{{ get_success_response_type(operation) }}{% else %}(){% endif %}, Error<{{ operation.rust_error_enum }}>> {
    // add a prefix to parameters to efficiently prevent name collisions
{% if has_request_body(operation) %}
    let p_{{ get_request_body_name(operation) }} = {{ get_request_body_name(operation) }};
{% endif %}
{% for param in operation.parameters %}
    let p_{{ param.rust_name }} = {{ param.rust_name }};
{% endfor %}

    let uri_str = format!("{}{{ operation.path | replace("-", "_") }}", configuration.base_path{% if has_path_parameters(operation) %}, {% for param in get_path_parameters(operation) %}{{ param.name | replace("-", "_") }}={% if param.rust_type in ["i32", "i64", "u32", "u64", "f32", "f64"] %}p_{{ param.rust_name }}{% else %}crate::apis::urlencode(p_{{ param.rust_name }}){% endif %}{% if not loop.last %}, {% endif %}{% endfor %}{% endif %});
    let mut req_builder = configuration.client.request(reqwest::Method::{{ operation.method }}, &uri_str);

{% if has_query_parameters(operation) %}
{% for param in get_query_parameters(operation) %}
    {% if param.required %}
        {% if param.rust_type.startswith("Vec<") %}
    for item in &p_{{ param.rust_name }} {
        req_builder = req_builder.query(&[("{{ param.name }}", &item.to_string())]);
    }
        {% else %}
    req_builder = req_builder.query(&[("{{ param.name }}", &p_{{ param.rust_name }}.to_string())]);
        {% endif %}
    {% else %}
    if let Some(ref param_value) = p_{{ param.rust_name }} {
        {% if param.rust_type.startswith("Vec<") %}
        for item in param_value {
            req_builder = req_builder.query(&[("{{ param.name }}", &item.to_string())]);
        }
        {% else %}
        req_builder = req_builder.query(&[("{{ param.name }}", &param_value.to_string())]);
        {% endif %}
    }
    {% endif %}
{% endfor %}
{% endif %}

{% if has_header_parameters(operation) %}
{% for param in get_header_parameters(operation) %}
    {% if param.required %}
    req_builder = req_builder.header("{{ param.name }}", p_{{ param.rust_name }}.to_string());
    {% else %}
    if let Some(ref param_value) = p_{{ param.rust_name }} {
        req_builder = req_builder.header("{{ param.name }}", param_value.to_string());
    }
    {% endif %}
{% endfor %}
{% endif %}

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Algo-API-Token", value);
    };

{% if has_request_body(operation) %}
    {% set request_body_type = get_request_body_type(operation) %}
    {% if operation.request_body_supports_msgpack %}
    // Determine content type: use msgpack by default if supported, unless format explicitly requests JSON
    let use_msgpack = {% for param in operation.parameters if param.name == "format" %}p_{{ param.rust_name }}.map(|f| f != "json").unwrap_or(true){% else %}true{% endfor %};

    {% if is_request_body_required(operation) %}
    if use_msgpack {
        {% if request_body_type == "Vec<u8>" %}
        // For binary data, use directly - detect if it's a binary endpoint or msgpack endpoint
        {% if "application/x-binary" in (operation.request_body.content if operation.request_body else {}) %}
        req_builder = req_builder
            .header("Content-Type", "application/x-binary")
            .body(p_{{ get_request_body_name(operation) }});
        {% else %}
        req_builder = req_builder
            .header("Content-Type", "application/msgpack")
            .body(p_{{ get_request_body_name(operation) }});
        {% endif %}
        {% else %}
        // Serialize using msgpack
        let msgpack_bytes = p_{{ get_request_body_name(operation) }}.encode()
            .map_err(|e| Error::from(serde_json::Error::custom(format!("Failed to serialize to msgpack: {}", e))))?;
        req_builder = req_builder
            .header("Content-Type", "application/msgpack")
            .body(msgpack_bytes);
        {% endif %}
    } else {
        // Use JSON
        req_builder = req_builder.json(&p_{{ get_request_body_name(operation) }});
    }
    {% else %}
    if let Some(ref request_body) = p_{{ get_request_body_name(operation) }} {
        if use_msgpack {
            {% if request_body_type == "Vec<u8>" %}
            // For binary data, use directly - detect if it's a binary endpoint or msgpack endpoint
            {% if "application/x-binary" in (operation.request_body.content if operation.request_body else {}) %}
            req_builder = req_builder
                .header("Content-Type", "application/x-binary")
                .body(request_body.clone());
            {% else %}
            req_builder = req_builder
                .header("Content-Type", "application/msgpack")
                .body(request_body.clone());
            {% endif %}
            {% else %}
            // Serialize using msgpack
            let msgpack_bytes = request_body.encode()
                .map_err(|e| Error::from(serde_json::Error::custom(format!("Failed to serialize to msgpack: {}", e))))?;
            req_builder = req_builder
                .header("Content-Type", "application/msgpack")
                .body(msgpack_bytes);
            {% endif %}
        } else {
            // Use JSON
            req_builder = req_builder.json(request_body);
        }
    }
    {% endif %}
    {% else %}
    {% if is_request_body_required(operation) %}
    req_builder = req_builder.json(&p_{{ get_request_body_name(operation) }});
    {% else %}
    if let Some(ref request_body) = p_{{ get_request_body_name(operation) }} {
        req_builder = req_builder.json(request_body);
    }
    {% endif %}
    {% endif %}
{% endif %}

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    {% if get_success_response_type(operation) %}
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);
    {% endif %}

    if !status.is_client_error() && !status.is_server_error() {
        {% if get_success_response_type(operation) %}
        {% set success_response_type = get_success_response_type(operation) %}
        match content_type {
            ContentType::Json => {
                let content = resp.text().await?;
                serde_json::from_str(&content).map_err(Error::from)
            },
            ContentType::MsgPack => {
                {% if operation.supports_msgpack %}
                {% for response_code, response in operation.responses.items() if response_code.startswith('2') and response.supports_msgpack %}
                let content = resp.bytes().await?;
                {{ get_success_response_type(operation) }}::decode(&content)
                    .map_err(|e| Error::from(serde_json::Error::custom(format!("Failed to decode msgpack response: {}", e))))
                {% else %}
                return Err(Error::from(serde_json::Error::custom("MsgPack response handling not supported for this endpoint")))
                {% endfor %}
                {% else %}
                return Err(Error::from(serde_json::Error::custom("MsgPack response handling not supported for this endpoint")))
                {% endif %}
            },
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `{{ success_response_type }}`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `{{ success_response_type }}`")))),
        }
        {% else %}
        let _content = resp.text().await?;
        Ok(())
        {% endif %}
    } else {
        let content = resp.text().await?;
        let entity: Option<{{ operation.rust_error_enum }}> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}
