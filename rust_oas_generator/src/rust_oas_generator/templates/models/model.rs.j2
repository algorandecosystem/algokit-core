/*
 * {{ spec.info.title }}
 *
 * {{ spec.info.description or "API client generated from OpenAPI specification" }}
 *
 * The version of the OpenAPI document: {{ spec.info.version }}
 {% if spec.info.contact and spec.info.contact.email %} * Contact: {{ spec.info.contact.email }}
 {% endif %} * Generated by: Rust OpenAPI Generator
 */

use crate::models;
use serde::{Deserialize, Serialize};
{% if schema.has_msgpack_fields %}
use serde_with::serde_as;
{% endif %}
{% if schema.vendor_extensions.get('x-algokit-signed-txn') or schema.properties | selectattr('is_signed_transaction') | list | length > 0 %}
use algokit_transact::{SignedTransaction as AlgokitSignedTransaction, AlgorandMsgpack};
{% endif %}

{% if schema.description %}
{{ schema.description | rust_doc_comment }}
{% endif %}
{% if schema.has_msgpack_fields %}
#[serde_as]
{% endif %}
{% set has_signed_tx = schema.properties | selectattr('is_signed_transaction') | list | length > 0 %}
#[derive(Clone, {% if not has_signed_tx %}Default, {% endif %}Debug, PartialEq, Serialize, Deserialize)]
{% if schema.vendor_extensions.get('x-algokit-signed-txn') %}
// This struct represents a SignedTransaction and can be converted to/from AlgoKit's SignedTransaction
{% endif %}
pub struct {{ schema.rust_struct_name }} {
{% for property in schema.properties %}
    {% if property.description %}
    {{ property.description | rust_doc_comment(4) }}
    {% endif %}
    {% if property.is_base64_encoded %}
    {% if property.required %}
    #[serde_as(as = "serde_with::base64::Base64")]
    {% else %}
    #[serde_as(as = "Option<serde_with::base64::Base64>")]
    {% endif %}
    {% endif %}
    #[serde(rename = "{{ property.name }}"{% if not property.required %}, skip_serializing_if = "Option::is_none"{% endif %})]
    {% if property.is_signed_transaction %}
    pub {{ property.rust_field_name }}: {% if property.required %}{% if property.rust_type.startswith('Vec<') %}Vec<AlgokitSignedTransaction>{% else %}AlgokitSignedTransaction{% endif %}{% else %}Option<{% if property.rust_type.startswith('Vec<') %}Vec<AlgokitSignedTransaction>{% else %}AlgokitSignedTransaction{% endif %}>{% endif %},
    {% else %}
    pub {{ property.rust_field_name }}: {% if property.required %}{{ property.rust_type_with_msgpack }}{% else %}Option<{{ property.rust_type_with_msgpack }}>{% endif %},
    {% endif %}
{% endfor %}
}

{% if has_signed_tx %}
impl Default for {{ schema.rust_struct_name }} {
    fn default() -> Self {
        Self {
{% for property in schema.properties %}
            {% if property.is_signed_transaction %}
            {{ property.rust_field_name }}: {% if property.required %}{% if property.rust_type.startswith('Vec<') %}Vec::new(){% else %}todo!("Provide default AlgokitSignedTransaction"){% endif %}{% else %}None{% endif %},
            {% elif property.required %}
            {{ property.rust_field_name }}: {% if property.rust_type == "String" %}"".to_string(){% elif property.rust_type.startswith('Vec<') %}Vec::new(){% elif property.rust_type.startswith('i') or property.rust_type.startswith('u') %}0{% elif property.rust_type == "bool" %}false{% else %}Default::default(){% endif %},
            {% else %}
            {{ property.rust_field_name }}: None,
            {% endif %}
{% endfor %}
        }
    }
}
{% endif %}

{% if schema.vendor_extensions.get('x-algokit-signed-txn') %}
impl From<AlgokitSignedTransaction> for {{ schema.rust_struct_name }} {
    fn from(signed_tx: AlgokitSignedTransaction) -> Self {
        // Convert AlgoKit SignedTransaction to this struct
        // This conversion should map the fields appropriately
        Self {
            // Map fields based on the actual schema structure
            // You may need to customize this based on the specific fields in your schema
            ..Default::default()
        }
    }
}

impl TryFrom<{{ schema.rust_struct_name }}> for AlgokitSignedTransaction {
    type Error = Box<dyn std::error::Error>;

    fn try_from(value: {{ schema.rust_struct_name }}) -> Result<Self, Self::Error> {
        // Convert this struct to AlgoKit SignedTransaction
        // This conversion should map the fields appropriately
        // You may need to customize this based on the specific fields in your schema
        todo!("Implement conversion to AlgoKit SignedTransaction based on your schema fields")
    }
}

impl AlgorandMsgpack for {{ schema.rust_struct_name }} {
    const PREFIX: &'static [u8] = b"";  // No prefix for SignedTransaction
}
{% endif %}

impl {{ schema.rust_struct_name }} {
    {% if schema.has_required_fields %}
    /// Constructor for {{ schema.rust_struct_name }}
    pub fn new({% for property in schema.properties if property.required %}{{ property.rust_field_name }}: {% if property.is_signed_transaction %}{% if property.rust_type.startswith('Vec<') %}Vec<AlgokitSignedTransaction>{% else %}AlgokitSignedTransaction{% endif %}{% else %}{{ property.rust_type_with_msgpack }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}) -> {{ schema.rust_struct_name }} {
        {{ schema.rust_struct_name }} {
{% for property in schema.properties if property.required %}
            {{ property.rust_field_name }},
{% endfor %}
{% for property in schema.properties if not property.required %}
            {{ property.rust_field_name }}: None,
{% endfor %}
        }
    }
    {% else %}
    /// Default constructor for {{ schema.rust_struct_name }}
    pub fn new() -> {{ schema.rust_struct_name }} {
        {{ schema.rust_struct_name }}::default()
    }
    {% endif %}
}

